import numpy as np
from collections import defaultdict
from wepy import WepyHDF5

def transmat(cluster_array, sliding_window):

	"""
	This determines a transition matrix for a variable lag time.

	Inputs:

	cluster_array (numpy array [n_timestep x n_walker numpy array]): 
	This is an array that indicates the cluster number for each walker at each timestep.

	sliding_window(iterable): Contains several lists of length of the lag time.
	Each list contains (2 x 1) tuples indicating the cycle and walker parents for a single
	cycle of WExplore.  

	Outputs: transition_matrix (numpy array [n_cluster x n_cluster]):

	A transition matrix based upon the lag time.

	"""

	# Obtains the number of clusters.
	n_cluster = np.max(cluster_array)

	# Allocates memory for the transition matrix
	transition_matrix = np.zeros([n_cluster + 1, n_cluster + 1])

	for step in windows:

	    # Determines the starting and ending walker
	    start_time = step[0][0]
	    original_walker = step[0][1]
	    end_time = step[-1][0]
	    final_walker = step[-1][1]

	    # Determines the cluster number of the begining walker
	    # and end walker.

	    start_cluster = cluster_array[start_time][original_walker]
	    end_cluster = cluster_array[end_time][final_walker]

	    # Adds a counter to the transition matrix
	    transition_matrix[star_cluster][end_cluster] += 1

	# Transforms transition matrix to show probabilities

	for cluster in range(n_cluster):
	    total = np.sum(transition_matrix[cluster]
	    transition_matrix[cluster] /= total
	
	return(transition_matrix)
	
	def transmat_hdf5(wepy, sliding_windows, run_idx, cluster):

	"""
	This determines a transition matrix for a variable lag time using cluster 
	data stored in a Wepy hdf5 file.

	Inputs:

	wepy: (hdf5 file generated by Wepy): An hdf5 file that contains your data.
	
	sliding_window(iterable): Contains several lists of length of the lag time.
	Each list contains (2 x 1) tuples indicating the cycle and walker parents 
	for a single cycle of WExplore. 

	run_idx (float)

	cluster (string): The field name that indicates what type of clustering you want
	a transition matrix for. 

	Outputs: 

	transition_matrix (numpy array [n_cluster x n_cluster]): 
	A transition matrix based upon the lag time.

	"""
	
	# A dynamic dictionary to count all instances of cluster pairs
	cluster_pair_dict = defaultdict(int)

	# Counter for the total number of clusters
	n_cluster = 0


	for step in windows:

		# Obtains frame and walker for the
		# initial and final positions according to lag time.
		start_time = [0][0]
		original_walker = [0][1]
		end_time = [-1][0]
		final_walker = [-1][1]

		# Gets cluster pair from the hdf5 file
		cluster_pair_step = wepy.get_trace_fields(run_idx, 
		                                         [(start_time, original_walker),
		                                          (end_time, final_walker)], 
		                                         [cluster])

		# If the cluster number is higher than previously seen clusters,
		# update the total number of clusters 
		cluster_pair = tuple(cluster_pair_step[cluster])
		for cluster in cluster_pair:
			if n_cluster < cluster:
				n_cluster = cluster

		# Add a count to the cluster pair in the dictionary
		cluster_pair_dict(cluster_pair) += 1

	# Allocates memory for transition matrix.
	transition_matrix = np.zeros([n_cluster, n_cluster])

	Transfers values from dictionary to the transition matrix

	for c_pair in cluster_pair_dict:
		transition_matrix[c_pair[0]][c_pair[1]] = cluster_pair_dict[c_pair]


	# Transforms transition matrix to show probabilities

	for cluster in range(n_cluster):
	    total = np.sum(transition_matrix[cluster]
	    transition_matrix[cluster] /= total


	return(transition_matrix)

