
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>wepy.hdf5 &#8212; wepy  documentation</title>
    <link rel="stylesheet" href="../../_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">wepy  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="../../search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="../../index.html">Docs</a></li>
              
                <li><a href="../index.html">Module code</a></li>
              
              <li>wepy.hdf5</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <h1>Source code for wepy.hdf5</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;Primary wepy simulation database driver and access API using the</span>
<span class="sd">HDF5 format.</span>

<span class="sd">The HDF5 Format Specification</span>
<span class="sd">=============================</span>

<span class="sd">As part of the wepy framework this module provides a fully-featured</span>
<span class="sd">API for creating and accessing data generated in weighted ensemble</span>
<span class="sd">simulations run with wepy.</span>

<span class="sd">The need for a special purpose format is many-fold but primarily it is</span>
<span class="sd">the nonlinear branching structure of walker trajectories coupled with</span>
<span class="sd">weights.</span>

<span class="sd">That is for standard simulations data is organized as independent</span>
<span class="sd">linear trajectories of frames each related linearly to the one before</span>
<span class="sd">it and after it.</span>

<span class="sd">In weighted ensemble due to the resampling (i.e. cloning and merging)</span>
<span class="sd">of walkers, a single frame may have multiple &#39;child&#39; frames.</span>

<span class="sd">This is the primary motivation for this format.</span>

<span class="sd">However, in practice it solves several other issues and itself is a</span>
<span class="sd">more general and flexible format than for just weighted ensemble</span>
<span class="sd">simulations.</span>

<span class="sd">Concretely the WepyHDF5 format is simply an informally described</span>
<span class="sd">schema that is commensurable with the HDF5 constructs of hierarchical</span>
<span class="sd">groups (similar to unix filesystem directories) arranged as a tree</span>
<span class="sd">with datasets as the leaves.</span>

<span class="sd">The hierarchy is fairly deep and so we will progress downwards from</span>
<span class="sd">the top and describe each broad section in turn breaking it down when</span>
<span class="sd">necessary.</span>

<span class="sd">Header</span>
<span class="sd">------</span>

<span class="sd">The items right under the root of the tree are:</span>

<span class="sd">- runs</span>
<span class="sd">- topology</span>
<span class="sd">- _settings</span>

<span class="sd">The first item &#39;runs&#39; is itself a group that contains all of the</span>
<span class="sd">primary data from simulations. In WepyHDF5 the run is the unit</span>
<span class="sd">dataset. All data internal to a run is self contained. That is for</span>
<span class="sd">multiple dependent trajectories (e.g. from cloning and merging) all</span>
<span class="sd">exist within a single run.</span>

<span class="sd">This excludes metadata-like things that may be needed for interpreting</span>
<span class="sd">this data, such as the molecular topology that imposes structure over</span>
<span class="sd">a frame of atom positions. This information is placed in the</span>
<span class="sd">&#39;topology&#39; item.</span>

<span class="sd">The topology field has no specified internal structure at this</span>
<span class="sd">time. However, with the current implementation of the WepyHDF5Reporter</span>
<span class="sd">(which is the principal implementation of generating a WepyHDF5</span>
<span class="sd">object/file from simulations) this is simply a string dataset. This</span>
<span class="sd">string dataset should be a JSON compliant string. The format of which</span>
<span class="sd">is specified elsewhere and was borrowed from the mdtraj library.</span>

<span class="sd">Warning! this format and specification for the topology is subject to</span>
<span class="sd">change in the future and will likely be kept unspecified indefinitely.</span>

<span class="sd">For most intents and purposes (which we assume to be for molecular or</span>
<span class="sd">molecular-like simulations) the &#39;topology&#39; item (and perhaps any other</span>
<span class="sd">item at the top level other than those proceeded by and underscore,</span>
<span class="sd">such as in the &#39;_settings&#39; item) is merely useful metadata that</span>
<span class="sd">applies to ALL runs and is not dynamical.</span>

<span class="sd">In the language of the orchestration module all data in &#39;runs&#39; uses</span>
<span class="sd">the same &#39;apparatus&#39; which is the function that takes in the initial</span>
<span class="sd">conditions for walkers and produces new walkers. The apparatus may</span>
<span class="sd">differ in the specific values of parameters but not in kind. This is</span>
<span class="sd">to facilitate runs that are continuations of other runs. For these</span>
<span class="sd">kinds of simulations the state of the resampler, boundary conditions,</span>
<span class="sd">etc. will not be as they were initially but are the same in kind or</span>
<span class="sd">type.</span>

<span class="sd">All of the necessary type information of data in runs is kept in the</span>
<span class="sd">&#39;_settings&#39; group. This is used to serialize information about the</span>
<span class="sd">data types, shapes, run to run continuations etc. This allows for the</span>
<span class="sd">initialization of an empty (no runs) WepyHDF5 database at one time and</span>
<span class="sd">filling of data at another time. Otherwise types of datasets would</span>
<span class="sd">have to be inferred from the data itself, which may not exist yet.</span>

<span class="sd">As a convention items which are preceeded by an underscore (following</span>
<span class="sd">the python convention) are to be considered hidden and mechanical to</span>
<span class="sd">the proper functioning of various WepyHDF5 API features, such as</span>
<span class="sd">sparse trajectory fields.</span>

<span class="sd">The &#39;_settings&#39; is specified as a simple key-value structure, however</span>
<span class="sd">values may be arbitrarily complex.</span>

<span class="sd">Runs</span>
<span class="sd">----</span>

<span class="sd">The meat of the format is contained within the runs group:</span>

<span class="sd">- runs</span>

<span class="sd">  - 0</span>
<span class="sd">  - 1</span>
<span class="sd">  - 2</span>
<span class="sd">  - ...</span>

<span class="sd">Under the runs group are a series of groups for each run. Runs are</span>
<span class="sd">named according to the order in which they were added to the database.</span>

<span class="sd">Within a run (say &#39;0&#39; from above) we have a number of items:</span>

<span class="sd">- 0</span>

<span class="sd">  - init_walkers</span>
<span class="sd">  - trajectories</span>
<span class="sd">  - decision</span>
<span class="sd">  - resampling</span>
<span class="sd">  - resampler</span>
<span class="sd">  - warping</span>
<span class="sd">  - progress</span>
<span class="sd">  - boundary_conditions</span>

<span class="sd">Trajectories</span>
<span class="sd">^^^^^^^^^^^^</span>

<span class="sd">The &#39;trajectories&#39; group is where the data for the frames of the</span>
<span class="sd">walker trajectories is stored.</span>

<span class="sd">Even though the tree-like trajectories of weighted ensemble data may</span>
<span class="sd">be well suited to having a tree-like storage topology we have opted to</span>
<span class="sd">use something more familiar to the field, and have used a collection</span>
<span class="sd">of linear &quot;trajectories&quot;.</span>

<span class="sd">This way of breaking up the trajectory data coupled with proper</span>
<span class="sd">records of resampling (see below) allows for the imposition of a tree</span>
<span class="sd">structure without committing to that as the data storage topology.</span>

<span class="sd">This allows the WepyHDF5 format to be easily used as a container</span>
<span class="sd">format for collections of linear trajectories. While this is not</span>
<span class="sd">supported in any real capacity it is one small step to convergence. We</span>
<span class="sd">feel that a format that contains multiple trajectories is important</span>
<span class="sd">for situations like weighted ensemble where trajectories are</span>
<span class="sd">interdependent. The transition to a storage format like HDF5 however</span>
<span class="sd">opens up many possibilities for new features for trajectories that</span>
<span class="sd">have not occurred despite several attempts to forge new formats based</span>
<span class="sd">on HDF5 (TODO: get references right; see work in mdtraj and MDHDF5).</span>

<span class="sd">Perhaps these formats have not caught on because the existing formats</span>
<span class="sd">(e.g. XTC, DCD) for simple linear trajectories are good enough and</span>
<span class="sd">there is little motivation to migrate.</span>

<span class="sd">However, by making the WepyHDF5 format (and related sub-formats to be</span>
<span class="sd">described e.g. record groups and the trajectory format) both cover a</span>
<span class="sd">new use case which can&#39;t be achieved with old formats and old ones</span>
<span class="sd">with ease.</span>

<span class="sd">Once users see the power of using a format like HDF5 from using wepy</span>
<span class="sd">they may continue to use it for simpler simulations.</span>


<span class="sd">In any case the &#39;trajectories&#39; in the group for weighted ensemble</span>
<span class="sd">simulations should be thought of only as containers and not literally</span>
<span class="sd">as trajectories. That is frame 4 does not necessarily follow from</span>
<span class="sd">frame 3. So one may think of them more as &quot;lanes&quot; or &quot;slots&quot; for</span>
<span class="sd">trajectory data that needs to be stitched together with the</span>
<span class="sd">appropriate resampling records.</span>

<span class="sd">The routines and methods for generating contiguous trajectories from</span>
<span class="sd">the data in WepyHDF5 are given through the &#39;analysis&#39; module, which</span>
<span class="sd">generates &quot;traces&quot; through the dataset.</span>

<span class="sd">With this in mind we will describe the sub-format of a trajectory now.</span>

<span class="sd">The &#39;trajectories&#39; group is similar to the &#39;runs&#39; group in that it has</span>
<span class="sd">sub-groups whose names are numbers. These numbers however are not the</span>
<span class="sd">order in which they are created but an index of that trajectory which</span>
<span class="sd">are typically laid out all at once.</span>

<span class="sd">For a wepy simulation with a constant number of walkers you will only</span>
<span class="sd">ever need as many trajectories/slots as there are walkers. So if you</span>
<span class="sd">have 8 walkers then you will have trajectories 0 through 7. Concretely:</span>

<span class="sd">- runs</span>

<span class="sd">  - 0</span>

<span class="sd">    - trajectories</span>

<span class="sd">      - 0</span>
<span class="sd">      - 1</span>
<span class="sd">      - 2</span>
<span class="sd">      - 3</span>
<span class="sd">      - 4</span>
<span class="sd">      - 5</span>
<span class="sd">      - 6</span>
<span class="sd">      - 7</span>

<span class="sd">If we look at trajectory 0 we might see the following groups within:</span>

<span class="sd">- positions</span>
<span class="sd">- box_vectors</span>
<span class="sd">- velocities</span>
<span class="sd">- weights</span>

<span class="sd">Which is what you would expect for a constant pressure molecular</span>
<span class="sd">dynamics simulation where you have the positions of the atoms, the box</span>
<span class="sd">size, and velocities of the atoms.</span>

<span class="sd">The particulars for what &quot;fields&quot; a trajectory in general has are not</span>
<span class="sd">important but this important use-case is directly supported in the</span>
<span class="sd">WepyHDF5 format.</span>

<span class="sd">In any such simulation, however, the &#39;weights&#39; field will appear since</span>
<span class="sd">this is the weight of the walker of this frame and is a value</span>
<span class="sd">important to weighted ensemble and not the underlying dynamics.</span>

<span class="sd">The naive approach to these fields is that each is a dataset of</span>
<span class="sd">dimension (n_frames, feature_vector_shape[0], ...) where the first dimension</span>
<span class="sd">is the cycle_idx and the rest of the dimensions are determined by the</span>
<span class="sd">atomic feature vector for each field for a single frame.</span>

<span class="sd">For example, the positions for a molecular simulation with 100 atoms</span>
<span class="sd">with x, y, and z coordinates that ran for 1000 cycles would be a</span>
<span class="sd">dataset of the shape (1000, 100, 3). Similarly the box vectors would</span>
<span class="sd">be (1000, 3, 3) and the weights would be (1000, 1).</span>

<span class="sd">This uniformity vastly simplifies accessing and adding new variables</span>
<span class="sd">and requires that individual state values in walkers always be arrays</span>
<span class="sd">with shapes, even when they are single values (e.g. energy). The</span>
<span class="sd">exception being the weight which is handled separately.</span>

<span class="sd">However, this situation is actually more complex to allow for special</span>
<span class="sd">features.</span>

<span class="sd">First of all is the presence of compound fields which allow nesting of</span>
<span class="sd">multiple groups.</span>

<span class="sd">The above &quot;trajectory fields&quot; would have identifiers such as the</span>
<span class="sd">literal strings &#39;positions&#39; and &#39;box_vectors&#39;, while a compound field</span>
<span class="sd">would have an identifier &#39;observables/rmsd&#39; or &#39;alt_reps/binding_site&#39;.</span>

<span class="sd">Use of trajectory field names using the &#39;/&#39; path separator will</span>
<span class="sd">automatically make a field a group and the last element of the field</span>
<span class="sd">name the dataset. So for the observables example we might have:</span>

<span class="sd">- 0</span>

<span class="sd">  - observables</span>

<span class="sd">    - rmsd</span>
<span class="sd">    - sasa</span>

<span class="sd">Where the rmsd would be accessed as a trajectory field of trajectory 0</span>
<span class="sd">as &#39;observables/rmsd&#39; and the solvent accessible surface area as</span>
<span class="sd">&#39;observables/sasa&#39;.</span>

<span class="sd">This example introduces how the WepyHDF5 format is not only useful for</span>
<span class="sd">storing data produced by simulation but also in the analysis of that</span>
<span class="sd">data and computation of by-frame quantities.</span>

<span class="sd">The &#39;observables&#39; compound group key prefix is special and will be</span>
<span class="sd">used in the &#39;compute_observables&#39; method.</span>

<span class="sd">The other special compound group key prefix is &#39;alt_reps&#39; which is</span>
<span class="sd">used for particle simulations to store &quot;alternate representation&quot; of</span>
<span class="sd">the positions. This is useful in cooperation with the next feature of</span>
<span class="sd">wepy trajectory fields to allow for more economical storage of data.</span>

<span class="sd">The next feature (and complication of the format) is the allowance for</span>
<span class="sd">sparse fields. As the fields were introduced we said that they should</span>
<span class="sd">have as many feature vectors as there are frames for the</span>
<span class="sd">simulation. In the example however, you will notice that storing both</span>
<span class="sd">the full atomic positions and velocities for a long simulation</span>
<span class="sd">requires a heavy storage burden.</span>

<span class="sd">So perhaps you only want to store the velocities (or forces) every 100</span>
<span class="sd">frames so that you can be able to restart a simulation form midway</span>
<span class="sd">through the simulation. This is achieved through sparse fields.</span>

<span class="sd">A sparse field is no longer a dataset but a group with two items:</span>

<span class="sd">- _sparse_idxs</span>
<span class="sd">- data</span>

<span class="sd">The &#39;_sparse_idxs&#39; are simply a dataset of integers that assign each</span>
<span class="sd">element of the &#39;data&#39; dataset to a frame index. Using the above</span>
<span class="sd">example we run a simulation for 1000 frames with 100 atoms and we save</span>
<span class="sd">the velocities every 100 frames we would have a &#39;velocities/data&#39;</span>
<span class="sd">dataset of shape (100, 100, 3) which is 10 times less data than if it</span>
<span class="sd">were saved every frame.</span>

<span class="sd">While this complicates the storage format use of the proper API</span>
<span class="sd">methods should be transparent whether you are returning a sparse field</span>
<span class="sd">or not.</span>

<span class="sd">As alluded to above the use of sparse fields can be used for more than</span>
<span class="sd">just accessory fields. In many simulations, such as those with full</span>
<span class="sd">atomistic simulations of proteins in solvent we often don&#39;t care about</span>
<span class="sd">the dynamics of most of the atoms in the simulation and so would like</span>
<span class="sd">to not have to save them.</span>

<span class="sd">The &#39;alt_reps&#39; compound field is meant to solve this. For example, the</span>
<span class="sd">WepyHDF5Reporter supports a special option to save only a subset of</span>
<span class="sd">the atoms in the main &#39;positions&#39; field but also to save the full</span>
<span class="sd">atomic system as an alternate representation, which is the field name</span>
<span class="sd">&#39;alt_reps/all_atoms&#39;. So that you can still save the full system every</span>
<span class="sd">once in a while but be economical in what positions you save every</span>
<span class="sd">single frame.</span>

<span class="sd">Note that there really isn&#39;t a way to achieve this with other</span>
<span class="sd">formats. You either make a completely new trajectory with only the</span>
<span class="sd">atoms of interest and now you are duplicating those in two places, or</span>
<span class="sd">you duplicate and then filter your full systems trajectory file and</span>
<span class="sd">rely on some sort of index to always live with it in the filesystem,</span>
<span class="sd">which is a very precarious scenario. The situation is particularly</span>
<span class="sd">hopeless for weighted ensemble trajectories.</span>

<span class="sd">Init Walkers</span>
<span class="sd">^^^^^^^^^^^^</span>

<span class="sd">The data stored in the &#39;trajectories&#39; section is the data that is</span>
<span class="sd">returned after running dynamics in a cycle. Since we view the WepyHDF5</span>
<span class="sd">as a completely self-contained format for simulations it seems</span>
<span class="sd">negligent to rely on outside sources (such as the filesystem) for the</span>
<span class="sd">initial structures that seeded the simulations. These states (and</span>
<span class="sd">weights) can be stored in this group.</span>

<span class="sd">The format of this group is identical to the one for trajectories</span>
<span class="sd">except that there is only one frame for each slot and so the shape of</span>
<span class="sd">the datasets for each field is just the shape of the feature vector.</span>

<span class="sd">Record Groups</span>
<span class="sd">^^^^^^^^^^^^^</span>

<span class="sd">TODO: add reference to reference groups</span>

<span class="sd">The last five items are what are called &#39;record groups&#39; and all follow</span>
<span class="sd">the same format.</span>

<span class="sd">Each record group contains itself a number of datasets, where the</span>
<span class="sd">names of the datasets correspond to the &#39;field names&#39; from the record</span>
<span class="sd">group specification. So each record groups is simply a key-value store</span>
<span class="sd">where the values must be datasets.</span>

<span class="sd">For instance the fields in the &#39;resampling&#39; (which is particularly</span>
<span class="sd">important as it encodes the branching structure) record group for a</span>
<span class="sd">WExplore resampler simulation are:</span>

<span class="sd">- step_idx</span>
<span class="sd">- walker_idx</span>
<span class="sd">- decision_id</span>
<span class="sd">- target_idxs</span>
<span class="sd">- region_assignment</span>

<span class="sd">Where the &#39;step_idx&#39; is an integer specifying which step of resampling</span>
<span class="sd">within the cycle the resampling action took place (the cycle index is</span>
<span class="sd">metadata for the group). The &#39;walker_idx&#39; is the index of the walker</span>
<span class="sd">that this action was assigned to. The &#39;decision_id&#39; is an integer that</span>
<span class="sd">is related to an enumeration of decision types that encodes which</span>
<span class="sd">discrete action is to be taken for this resampling event (the</span>
<span class="sd">enumeration is in the &#39;decision&#39; item of the run groups). The</span>
<span class="sd">&#39;target_idxs&#39; is a variable length 1-D array of integers which assigns</span>
<span class="sd">the results of the action to specific target &#39;slots&#39; (which was</span>
<span class="sd">discussed for the &#39;trajectories&#39; run group). And the</span>
<span class="sd">&#39;region_assignment&#39; is specific to WExplore which reports on which</span>
<span class="sd">region the walker was in at that time, and is a variable length 1-D</span>
<span class="sd">array of integers.</span>

<span class="sd">Additionally, record groups are broken into two types:</span>

<span class="sd">- continual</span>
<span class="sd">- sporadic</span>

<span class="sd">Continual records occur once per cycle and so there is no extra</span>
<span class="sd">indexing necessary.</span>

<span class="sd">Sporadic records can happen multiple or zero times per cycle and so</span>
<span class="sd">require a special index for them which is contained in the extra</span>
<span class="sd">dataset &#39;_cycle_idxs&#39;.</span>

<span class="sd">It is worth noting that the underlying methods for each record group</span>
<span class="sd">are general. So while these are the official wepy record groups that</span>
<span class="sd">are supported if there is a use-case that demands a new record group</span>
<span class="sd">it is a fairly straightforward task from a developers perspective.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">osp</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">namedtuple</span><span class="p">,</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Counter</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="k">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="kn">from</span> <span class="nn">wepy.analysis.parents</span> <span class="k">import</span> <span class="n">resampling_panel</span>
<span class="kn">from</span> <span class="nn">wepy.util.mdtraj</span> <span class="k">import</span> <span class="n">mdtraj_to_json_topology</span><span class="p">,</span> <span class="n">json_to_mdtraj_topology</span><span class="p">,</span> \
                             <span class="n">traj_fields_to_mdtraj</span>
<span class="kn">from</span> <span class="nn">wepy.util.util</span> <span class="k">import</span> <span class="n">traj_box_vectors_to_lengths_angles</span>
<span class="kn">from</span> <span class="nn">wepy.util.json_top</span> <span class="k">import</span> <span class="n">json_top_subset</span><span class="p">,</span> <span class="n">json_top_atom_count</span>

<span class="c1"># optional dependencies</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">mdtraj</span> <span class="k">as</span> <span class="nn">mdj</span>
<span class="k">except</span> <span class="n">ModuleNotFoundError</span><span class="p">:</span>
    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;mdtraj is not installed and that functionality will not work&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="k">except</span> <span class="n">ModuleNotFoundError</span><span class="p">:</span>
    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;pandas is not installed and that functionality will not work&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

<span class="c1">## h5py settings</span>

<span class="c1"># we set the libver to always be the latest (which should be 1.10) so</span>
<span class="c1"># that we know we can always use SWMR and the newest features. We</span>
<span class="c1"># don&#39;t care about backwards compatibility with HDF5 1.8. Just update</span>
<span class="c1"># in a new virtualenv if this is a problem for you</span>
<span class="n">H5PY_LIBVER</span> <span class="o">=</span> <span class="s1">&#39;latest&#39;</span>

<span class="c1">## Header and settings keywords</span>

<span class="n">TOPOLOGY</span> <span class="o">=</span> <span class="s1">&#39;topology&#39;</span>
<span class="sd">&quot;&quot;&quot;Default header apparatus dataset. The molecular topology dataset.&quot;&quot;&quot;</span>

<span class="n">SETTINGS</span> <span class="o">=</span> <span class="s1">&#39;_settings&#39;</span>
<span class="sd">&quot;&quot;&quot;Name of the settings group in the header group.&quot;&quot;&quot;</span>

<span class="n">RUNS</span> <span class="o">=</span> <span class="s1">&#39;runs&#39;</span>
<span class="sd">&quot;&quot;&quot;The group name for runs.&quot;&quot;&quot;</span>


<span class="c1">## metadata fields</span>
<span class="n">RUN_IDX</span> <span class="o">=</span> <span class="s1">&#39;run_idx&#39;</span>
<span class="sd">&quot;&quot;&quot;Metadata field for run groups for the run index within this file.&quot;&quot;&quot;</span>

<span class="n">RUN_START_SNAPSHOT_HASH</span> <span class="o">=</span> <span class="s1">&#39;start_snapshot_hash&#39;</span>
<span class="sd">&quot;&quot;&quot;Metadata field for a run that corresponds to the hash of the</span>
<span class="sd">starting simulation snapshot in orchestration.&quot;&quot;&quot;</span>

<span class="n">RUN_END_SNAPSHOT_HASH</span> <span class="o">=</span> <span class="s1">&#39;end_snapshot_hash&#39;</span>
<span class="sd">&quot;&quot;&quot;Metadata field for a run that corresponds to the hash of the</span>
<span class="sd">ending simulation snapshot in orchestration.&quot;&quot;&quot;</span>

<span class="n">TRAJ_IDX</span> <span class="o">=</span> <span class="s1">&#39;traj_idx&#39;</span>
<span class="sd">&quot;&quot;&quot;Metadata field for trajectory groups for the trajectory index in that run.&quot;&quot;&quot;</span>

<span class="c1">## Misc. Names</span>

<span class="n">CYCLE_IDX</span> <span class="o">=</span> <span class="s1">&#39;cycle_idx&#39;</span>
<span class="sd">&quot;&quot;&quot;String for setting the names of cycle indices in records and</span>
<span class="sd">miscellaneous situations.&quot;&quot;&quot;</span>


<span class="c1">## Settings field names</span>
<span class="n">SPARSE_FIELDS</span> <span class="o">=</span> <span class="s1">&#39;sparse_fields&#39;</span>
<span class="sd">&quot;&quot;&quot;Settings field name for sparse field trajectory field flags.&quot;&quot;&quot;</span>

<span class="n">N_ATOMS</span> <span class="o">=</span> <span class="s1">&#39;n_atoms&#39;</span>
<span class="sd">&quot;&quot;&quot;Settings field name group for the number of atoms in the default positions field.&quot;&quot;&quot;</span>

<span class="n">N_DIMS_STR</span> <span class="o">=</span> <span class="s1">&#39;n_dims&#39;</span>
<span class="sd">&quot;&quot;&quot;Settings field name for positions field spatial dimensions.&quot;&quot;&quot;</span>

<span class="n">MAIN_REP_IDXS</span> <span class="o">=</span> <span class="s1">&#39;main_rep_idxs&#39;</span>
<span class="sd">&quot;&quot;&quot;Settings field name for the indices of the full apparatus topology in</span>
<span class="sd">the default positions trajectory field.&quot;&quot;&quot;</span>

<span class="n">ALT_REPS_IDXS</span> <span class="o">=</span> <span class="s1">&#39;alt_reps_idxs&#39;</span>
<span class="sd">&quot;&quot;&quot;Settings field name for the different &#39;alt_reps&#39;. The indices of</span>
<span class="sd">the atoms from the full apparatus topology for each.&quot;&quot;&quot;</span>

<span class="n">FIELD_FEATURE_SHAPES_STR</span> <span class="o">=</span> <span class="s1">&#39;field_feature_shapes&#39;</span>
<span class="sd">&quot;&quot;&quot;Settings field name for the trajectory field shapes.&quot;&quot;&quot;</span>

<span class="n">FIELD_FEATURE_DTYPES_STR</span> <span class="o">=</span> <span class="s1">&#39;field_feature_dtypes&#39;</span>
<span class="sd">&quot;&quot;&quot;Settings field name for the trajectory field data types.&quot;&quot;&quot;</span>

<span class="n">UNITS</span> <span class="o">=</span> <span class="s1">&#39;units&#39;</span>
<span class="sd">&quot;&quot;&quot;Settings field name for the units of the trajectory fields.&quot;&quot;&quot;</span>

<span class="n">RECORD_FIELDS</span> <span class="o">=</span> <span class="s1">&#39;record_fields&#39;</span>
<span class="sd">&quot;&quot;&quot;Settings field name for the record fields that are to be included</span>
<span class="sd">in the truncated listing of record group fields.&quot;&quot;&quot;</span>

<span class="n">CONTINUATIONS</span> <span class="o">=</span> <span class="s1">&#39;continuations&#39;</span>
<span class="sd">&quot;&quot;&quot;Settings field name for the continuations relationships between runs.&quot;&quot;&quot;</span>


<span class="c1">## Run Fields Names</span>
<span class="n">TRAJECTORIES</span> <span class="o">=</span> <span class="s1">&#39;trajectories&#39;</span>
<span class="sd">&quot;&quot;&quot;Run field name for the trajectories group.&quot;&quot;&quot;</span>

<span class="n">INIT_WALKERS</span> <span class="o">=</span> <span class="s1">&#39;init_walkers&#39;</span>
<span class="sd">&quot;&quot;&quot;Run field name for the initial walkers group.&quot;&quot;&quot;</span>

<span class="n">DECISION</span> <span class="o">=</span> <span class="s1">&#39;decision&#39;</span>
<span class="sd">&quot;&quot;&quot;Run field name for the decision enumeration group.&quot;&quot;&quot;</span>

<span class="c1">## Record Groups Names</span>
<span class="n">RESAMPLING</span> <span class="o">=</span> <span class="s1">&#39;resampling&#39;</span>
<span class="sd">&quot;&quot;&quot;Record group run field name for the resampling records &quot;&quot;&quot;</span>

<span class="n">RESAMPLER</span> <span class="o">=</span> <span class="s1">&#39;resampler&#39;</span>
<span class="sd">&quot;&quot;&quot;Record group run field name for the resampler records &quot;&quot;&quot;</span>

<span class="n">WARPING</span> <span class="o">=</span> <span class="s1">&#39;warping&#39;</span>
<span class="sd">&quot;&quot;&quot;Record group run field name for the warping records &quot;&quot;&quot;</span>

<span class="n">PROGRESS</span> <span class="o">=</span> <span class="s1">&#39;progress&#39;</span>
<span class="sd">&quot;&quot;&quot;Record group run field name for the progress records &quot;&quot;&quot;</span>

<span class="n">BC</span> <span class="o">=</span> <span class="s1">&#39;boundary_conditions&#39;</span>
<span class="sd">&quot;&quot;&quot;Record group run field name for the boundary conditions records &quot;&quot;&quot;</span>

<span class="c1">## Record groups constants</span>

<span class="c1"># special datatypes strings</span>
<span class="n">NONE_STR</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
<span class="sd">&quot;&quot;&quot;String signifying a field of unspecified shape. Used for</span>
<span class="sd">serializing the None python object.&quot;&quot;&quot;</span>

<span class="n">CYCLE_IDXS</span> <span class="o">=</span> <span class="s1">&#39;_cycle_idxs&#39;</span>
<span class="sd">&quot;&quot;&quot;Group name for the cycle indices of sporadic records.&quot;&quot;&quot;</span>

<span class="c1"># records can be sporadic or continual. Continual records are</span>
<span class="c1"># generated every cycle and are saved every cycle and are for all</span>
<span class="c1"># walkers.  Sporadic records are generated conditional on specific</span>
<span class="c1"># events taking place and thus may or may not be produced each</span>
<span class="c1"># cycle. There also is not a single record for each (cycle, step) like</span>
<span class="c1"># there would be for continual ones because they can occur for single</span>
<span class="c1"># walkers, boundary conditions, or resamplers.</span>
<span class="n">SPORADIC_RECORDS</span> <span class="o">=</span> <span class="p">(</span><span class="n">RESAMPLER</span><span class="p">,</span> <span class="n">WARPING</span><span class="p">,</span> <span class="n">RESAMPLING</span><span class="p">,</span> <span class="n">BC</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Enumeration of the record groups that are sporadic.&quot;&quot;&quot;</span>

<span class="c1">## Trajectories Group</span>

<span class="c1"># Default Trajectory Constants</span>

<span class="n">N_DIMS</span> <span class="o">=</span> <span class="mi">3</span>
<span class="sd">&quot;&quot;&quot;Number of dimensions for the default positions.&quot;&quot;&quot;</span>


<span class="c1"># Required Trajectory Fields</span>

<span class="n">WEIGHTS</span> <span class="o">=</span> <span class="s1">&#39;weights&#39;</span>
<span class="sd">&quot;&quot;&quot;The field name for the frame weights.&quot;&quot;&quot;</span>

<span class="c1"># default fields for trajectories</span>

<span class="n">POSITIONS</span> <span class="o">=</span> <span class="s1">&#39;positions&#39;</span>
<span class="sd">&quot;&quot;&quot;The field name for the default positions.&quot;&quot;&quot;</span>

<span class="n">BOX_VECTORS</span> <span class="o">=</span> <span class="s1">&#39;box_vectors&#39;</span>
<span class="sd">&quot;&quot;&quot;The field name for the default box vectors.&quot;&quot;&quot;</span>

<span class="n">VELOCITIES</span> <span class="o">=</span> <span class="s1">&#39;velocities&#39;</span>
<span class="sd">&quot;&quot;&quot;The field name for the default velocities.&quot;&quot;&quot;</span>

<span class="n">FORCES</span> <span class="o">=</span> <span class="s1">&#39;forces&#39;</span>
<span class="sd">&quot;&quot;&quot;The field name for the default forces.&quot;&quot;&quot;</span>

<span class="n">TIME</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span>
<span class="sd">&quot;&quot;&quot;The field name for the default time.&quot;&quot;&quot;</span>

<span class="n">KINETIC_ENERGY</span> <span class="o">=</span> <span class="s1">&#39;kinetic_energy&#39;</span>
<span class="sd">&quot;&quot;&quot;The field name for the default kinetic energy.&quot;&quot;&quot;</span>

<span class="n">POTENTIAL_ENERGY</span> <span class="o">=</span> <span class="s1">&#39;potential_energy&#39;</span>
<span class="sd">&quot;&quot;&quot;The field name for the default potential energy.&quot;&quot;&quot;</span>

<span class="n">BOX_VOLUME</span> <span class="o">=</span> <span class="s1">&#39;box_volume&#39;</span>
<span class="sd">&quot;&quot;&quot;The field name for the default box volume.&quot;&quot;&quot;</span>

<span class="n">PARAMETERS</span> <span class="o">=</span> <span class="s1">&#39;parameters&#39;</span>
<span class="sd">&quot;&quot;&quot;The field name for the default parameters.&quot;&quot;&quot;</span>

<span class="n">PARAMETER_DERIVATIVES</span> <span class="o">=</span> <span class="s1">&#39;parameter_derivatives&#39;</span>
<span class="sd">&quot;&quot;&quot;The field name for the default parameter derivatives.&quot;&quot;&quot;</span>

<span class="n">ALT_REPS</span> <span class="o">=</span> <span class="s1">&#39;alt_reps&#39;</span>
<span class="sd">&quot;&quot;&quot;The field name for the default compound field observables.&quot;&quot;&quot;</span>

<span class="n">OBSERVABLES</span> <span class="o">=</span> <span class="s1">&#39;observables&#39;</span>
<span class="sd">&quot;&quot;&quot;The field name for the default compound field observables.&quot;&quot;&quot;</span>

<span class="c1">## Trajectory Field Constants</span>

<span class="n">WEIGHT_SHAPE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
<span class="sd">&quot;&quot;&quot;Weights feature vector shape.&quot;&quot;&quot;</span>

<span class="n">WEIGHT_DTYPE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span>
<span class="sd">&quot;&quot;&quot;Weights feature vector data type.&quot;&quot;&quot;</span>

<span class="c1"># Default Trajectory Field Constants</span>
<span class="n">FIELD_FEATURE_SHAPES</span> <span class="o">=</span> <span class="p">((</span><span class="n">TIME</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
                        <span class="p">(</span><span class="n">BOX_VECTORS</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span>
                        <span class="p">(</span><span class="n">BOX_VOLUME</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
                        <span class="p">(</span><span class="n">KINETIC_ENERGY</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
                        <span class="p">(</span><span class="n">POTENTIAL_ENERGY</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
                        <span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Default shapes for the default fields.&quot;&quot;&quot;</span>

<span class="n">FIELD_FEATURE_DTYPES</span> <span class="o">=</span> <span class="p">((</span><span class="n">POSITIONS</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">VELOCITIES</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">FORCES</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">TIME</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">BOX_VECTORS</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">BOX_VOLUME</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">KINETIC_ENERGY</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">POTENTIAL_ENERGY</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                        <span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Default data types for the default fields.&quot;&quot;&quot;</span>

<span class="c1"># Positions (and thus velocities and forces) are determined by the</span>
<span class="c1"># N_DIMS (which can be customized) and more importantly the number of</span>
<span class="c1"># particles which is always different. All the others are always wacky</span>
<span class="c1"># and different.</span>
<span class="n">POSITIONS_LIKE_FIELDS</span> <span class="o">=</span> <span class="p">(</span><span class="n">VELOCITIES</span><span class="p">,</span> <span class="n">FORCES</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Default trajectory fields which are the same shape as the main positions field.&quot;&quot;&quot;</span>

<span class="c1">## Trajectory field features keys</span>

<span class="c1"># sparse trajectory fields</span>
<span class="n">DATA</span> <span class="o">=</span> <span class="s1">&#39;data&#39;</span>
<span class="sd">&quot;&quot;&quot;Name of the dataset in sparse trajectory fields.&quot;&quot;&quot;</span>

<span class="n">SPARSE_IDXS</span> <span class="o">=</span> <span class="s1">&#39;_sparse_idxs&#39;</span>
<span class="sd">&quot;&quot;&quot;Name of the dataset that indexes sparse trajectory fields.&quot;&quot;&quot;</span>

<span class="c1"># utility for paths</span>
<span class="k">def</span> <span class="nf">_iter_field_paths</span><span class="p">(</span><span class="n">grp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return all subgroup field name paths from a group.</span>

<span class="sd">    Useful for compound fields. For example if you have the group</span>
<span class="sd">    observables with multiple subfields:</span>

<span class="sd">    - observables</span>
<span class="sd">      - rmsd</span>
<span class="sd">      - sasa</span>

<span class="sd">    Passing the h5py group &#39;observables&#39; will return the full field</span>
<span class="sd">    names for each subfield:</span>

<span class="sd">    - &#39;observables/rmsd&#39;</span>
<span class="sd">    - &#39;observables/sasa&#39;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grp : h5py.Group</span>
<span class="sd">        The group to enumerate subfield names for.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    subfield_names : list of str</span>
<span class="sd">        The full names for the subfields of the group.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">field_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">grp</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grp</span><span class="p">[</span><span class="n">field_name</span><span class="p">],</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Group</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">subfield</span> <span class="ow">in</span> <span class="n">grp</span><span class="p">[</span><span class="n">field_name</span><span class="p">]:</span>

                <span class="c1"># if it is a sparse field don&#39;t do the subfields since</span>
                <span class="c1"># they will be _sparse_idxs and data which are not</span>
                <span class="c1"># what we want here</span>
                <span class="k">if</span> <span class="n">field_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">file</span><span class="p">[</span><span class="s1">&#39;_settings/sparse_fields&#39;</span><span class="p">]:</span>
                    <span class="n">field_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field_name</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">subfield</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">field_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">field_paths</span>

<div class="viewcode-block" id="WepyHDF5"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5">[docs]</a><span class="k">class</span> <span class="nc">WepyHDF5</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper for h5py interface to an HDF5 file object for creation and</span>
<span class="sd">    access of WepyHDF5 data.</span>

<span class="sd">    This is the primary implementation of the API for creating,</span>
<span class="sd">    accessing, and modifying data in an HDF5 file that conforms to the</span>
<span class="sd">    WepyHDF5 specification.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">MODES</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;w-&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;The recognized modes for opening the WepyHDF5 file.&quot;&quot;&quot;</span>

    <span class="n">WRITE_MODES</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;r+&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;w-&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>


    <span class="c1">#### dunder methods</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
                 <span class="n">topology</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sparse_fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">feature_shapes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">feature_dtypes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">alt_reps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">main_rep_idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">swmr_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">expert_mode</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor for the WepyHDF5 class.</span>

<span class="sd">        Initialize a new Wepy HDF5 file. This will create an h5py.File</span>
<span class="sd">        object.</span>

<span class="sd">        The File will be closed after construction by default.</span>

<span class="sd">        mode:</span>
<span class="sd">        r        Readonly, file must exist</span>
<span class="sd">        r+       Read/write, file must exist</span>
<span class="sd">        w        Create file, truncate if exists</span>
<span class="sd">        x or w-  Create file, fail if exists</span>
<span class="sd">        a        Read/write if exists, create otherwise</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            File path</span>

<span class="sd">        mode : str</span>
<span class="sd">            Mode specification for opening the HDF5 file.</span>

<span class="sd">        topology : str</span>
<span class="sd">            JSON string representing topology of system being simulated.</span>

<span class="sd">        units : dict of str : str, optional</span>
<span class="sd">            Mapping of trajectory field names to string specs</span>
<span class="sd">            for units.</span>

<span class="sd">        sparse_fields : list of str, optional</span>
<span class="sd">            List of trajectory fields that should be initialized as sparse.</span>

<span class="sd">        feature_shapes : dict of str : shape_spec, optional</span>
<span class="sd">            Mapping of trajectory fields to their shape spec for initialization.</span>

<span class="sd">        feature_dtypes : dict of str : dtype_spec, optional</span>
<span class="sd">            Mapping of trajectory fields to their shape spec for initialization.</span>

<span class="sd">        n_dims : int, default: 3</span>
<span class="sd">            Set the number of spatial dimensions for the default</span>
<span class="sd">            positions trajectory field.</span>

<span class="sd">        alt_reps : dict of str : list of int, optional</span>
<span class="sd">            Specifies that there will be &#39;alt_reps&#39; of positions each</span>
<span class="sd">            named by the keys of this mapping and containing the</span>
<span class="sd">            indices in each value list.</span>

<span class="sd">        main_rep_idxs : list of int, optional</span>
<span class="sd">            The indices of atom positions to save as the main &#39;positions&#39;</span>
<span class="sd">            trajectory field. Defaults to all atoms.</span>

<span class="sd">        expert_mode : bool</span>
<span class="sd">            If True no initialization is performed other than the</span>
<span class="sd">            setting of the filename. Useful mainly for debugging.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>

<span class="sd">        AssertionError</span>
<span class="sd">            If the mode is not one of the supported mode specs.</span>

<span class="sd">        AssertionError</span>
<span class="sd">            If a topology is not given for a creation mode.</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>

<span class="sd">        If initialization data was given but the file was opened in a read mode.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_swmr_mode</span> <span class="o">=</span> <span class="n">swmr_mode</span>

        <span class="k">if</span> <span class="n">expert_mode</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wepy_mode</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_h5py_mode</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># terminate the constructor here</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">MODES</span><span class="p">,</span> \
          <span class="s2">&quot;mode must be either one of: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MODES</span><span class="p">))</span>

        <span class="c1"># the top level mode enforced by wepy.hdf5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wepy_mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># the lower level h5py mode. THis was originally different to</span>
        <span class="c1"># accomodate different modes at teh wepy level for</span>
        <span class="c1"># concatenation. I will leave these separate because this is</span>
        <span class="c1"># used elsewhere and could be a feature in the future.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_h5py_mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Temporary metadata: used to initialize the object but not</span>
        <span class="c1"># used after that</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span> <span class="o">=</span> <span class="n">topology</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">=</span> <span class="n">units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_dims</span> <span class="o">=</span> <span class="n">n_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_coords</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># set hidden feature shapes and dtype, which are only</span>
        <span class="c1"># referenced if needed when trajectories are created. These</span>
        <span class="c1"># will be saved in the settings section in the actual HDF5</span>
        <span class="c1"># file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_shapes_kwarg</span> <span class="o">=</span> <span class="n">feature_shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_dtypes_kwarg</span> <span class="o">=</span> <span class="n">feature_dtypes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_dtypes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_shapes</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># save the sparse fields as a private variable for use in the</span>
        <span class="c1"># create constructor</span>
        <span class="k">if</span> <span class="n">sparse_fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_fields</span> <span class="o">=</span> <span class="n">sparse_fields</span>

        <span class="c1"># if we specify an atom subset of the main POSITIONS field</span>
        <span class="c1"># we must save them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_main_rep_idxs</span> <span class="o">=</span> <span class="n">main_rep_idxs</span>

        <span class="c1"># a dictionary specifying other alt_reps to be saved</span>
        <span class="k">if</span> <span class="n">alt_reps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_alt_reps</span> <span class="o">=</span> <span class="n">alt_reps</span>
            <span class="c1"># all alt_reps are sparse</span>
            <span class="n">alt_rep_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ALT_REPS</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alt_reps</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_fields</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">alt_rep_keys</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_alt_reps</span> <span class="o">=</span> <span class="p">{}</span>


        <span class="c1"># open the file and then run the different constructors based</span>
        <span class="c1"># on the mode</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_h5py_mode</span><span class="p">,</span>
                       <span class="n">libver</span><span class="o">=</span><span class="n">H5PY_LIBVER</span><span class="p">,</span> <span class="n">swmr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_swmr_mode</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span> <span class="o">=</span> <span class="n">h5</span>

            <span class="c1"># set SWMR mode if asked for if we are in write mode also</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swmr_mode</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">WRITE_MODES</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">swmr_mode</span> <span class="o">=</span> <span class="n">swmr_mode</span>

            <span class="c1"># create file mode: &#39;w&#39; will create a new file or overwrite,</span>
            <span class="c1"># &#39;w-&#39; and &#39;x&#39; will not overwrite but will create a new file</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wepy_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;w-&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_create_init</span><span class="p">()</span>

            <span class="c1"># read/write mode: in this mode we do not completely overwrite</span>
            <span class="c1"># the old file and start again but rather write over top of</span>
            <span class="c1"># values if requested</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wepy_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;r+&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_write_init</span><span class="p">()</span>

            <span class="c1"># add mode: read/write create if doesn&#39;t exist</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wepy_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">osp</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_read_write_init</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_create_init</span><span class="p">()</span>

            <span class="c1"># read only mode</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wepy_mode</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>

                <span class="c1"># if any data was given, warn the user</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">kwarg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span>
                        <span class="p">[</span><span class="n">topology</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">sparse_fields</span><span class="p">,</span>
                         <span class="n">feature_shapes</span><span class="p">,</span> <span class="n">feature_dtypes</span><span class="p">,</span>
                         <span class="n">n_dims</span><span class="p">,</span> <span class="n">alt_reps</span><span class="p">,</span> <span class="n">main_rep_idxs</span><span class="p">]]):</span>
                   <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Data was given but opening in read-only mode&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

                <span class="c1"># then run the initialization process</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_init</span><span class="p">()</span>

            <span class="c1"># flush the buffers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

            <span class="c1"># set the h5py mode to the value in the actual h5py.File</span>
            <span class="c1"># object after creation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_h5py_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">mode</span>

        <span class="c1"># get rid of the temporary variables</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dims</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_coords</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_shapes_kwarg</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_dtypes_kwarg</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_shapes</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_dtypes</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_fields</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_main_rep_idxs</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alt_reps</span>

        <span class="c1"># variable to reflect if it is closed or not, should be closed</span>
        <span class="c1"># after initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># end of the constructor</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># TODO is this right? shouldn&#39;t we actually delete the data then close</span>
    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># context manager methods</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
        <span class="c1"># self._h5 = h5py.File(self._filename,</span>
        <span class="c1">#                      libver=H5PY_LIBVER, swmr=self._swmr_mode)</span>
        <span class="c1"># self.closed = False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">swmr_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swmr_mode</span>

    <span class="nd">@swmr_mode</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">swmr_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_swmr_mode</span> <span class="o">=</span> <span class="n">val</span>


    <span class="c1"># TODO custom deepcopy to avoid copying the actual HDF5 object</span>

    <span class="c1">#### hidden methods (_method_name)</span>

    <span class="c1">### constructors</span>
    <span class="k">def</span> <span class="nf">_create_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creation mode constructor.</span>

<span class="sd">        Completely overwrite the data in the file. Reinitialize the values</span>
<span class="sd">        and set with the new ones if given.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> \
            <span class="s2">&quot;Topology must be given for a creation constructor&quot;</span>

        <span class="c1"># initialize the runs group</span>
        <span class="n">runs_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">RUNS</span><span class="p">)</span>

        <span class="c1"># initialize the settings group</span>
        <span class="n">settings_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">)</span>

        <span class="c1"># create the topology dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">TOPOLOGY</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="p">)</span>

        <span class="c1"># sparse fields</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># make a dataset for the sparse fields allowed.  this requires</span>
            <span class="c1"># a &#39;special&#39; datatype for variable length strings. This is</span>
            <span class="c1"># supported by HDF5 but not numpy.</span>
            <span class="n">vlen_str_dt</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">special_dtype</span><span class="p">(</span><span class="n">vlen</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

            <span class="c1"># create the dataset with empty values for the length of the</span>
            <span class="c1"># sparse fields given</span>
            <span class="n">sparse_fields_ds</span> <span class="o">=</span> <span class="n">settings_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">SPARSE_FIELDS</span><span class="p">,</span>
                                                           <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_fields</span><span class="p">),),</span>
                                                           <span class="n">dtype</span><span class="o">=</span><span class="n">vlen_str_dt</span><span class="p">,</span>
                                                           <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,))</span>

            <span class="c1"># set the flags</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sparse_field</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_fields</span><span class="p">):</span>
                <span class="n">sparse_fields_ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparse_field</span>


        <span class="c1"># field feature shapes and dtypes</span>

        <span class="c1"># initialize to the defaults, this gives values to</span>
        <span class="c1"># self._n_coords, and self.field_feature_dtypes, and</span>
        <span class="c1"># self.field_feature_shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_default_init_field_attributes</span><span class="p">(</span><span class="n">n_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dims</span><span class="p">)</span>

        <span class="c1"># save the number of dimensions and number of atoms in settings</span>
        <span class="n">settings_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">N_DIMS_STR</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dims</span><span class="p">))</span>
        <span class="n">settings_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">N_ATOMS</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_coords</span><span class="p">))</span>

        <span class="c1"># the main rep atom idxs</span>
        <span class="n">settings_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">MAIN_REP_IDXS</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_main_rep_idxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="c1"># alt_reps settings</span>
        <span class="n">alt_reps_idxs_grp</span> <span class="o">=</span> <span class="n">settings_grp</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">ALT_REPS_IDXS</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">alt_rep_name</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alt_reps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">alt_reps_idxs_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">alt_rep_name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">idxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="c1"># if both feature shapes and dtypes were specified overwrite</span>
        <span class="c1"># (or initialize if not set by defaults) the defaults</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_shapes_kwarg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>\
           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_dtypes_kwarg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_shapes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_shapes_kwarg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_dtypes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_dtypes_kwarg</span><span class="p">)</span>

        <span class="c1"># any sparse field with unspecified shape and dtype must be</span>
        <span class="c1"># set to None so that it will be set at runtime</span>
        <span class="k">for</span> <span class="n">sparse_field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sparse_field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_shapes</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="p">(</span><span class="ow">not</span> <span class="n">sparse_field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_dtypes</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_shapes</span><span class="p">[</span><span class="n">sparse_field</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_dtypes</span><span class="p">[</span><span class="n">sparse_field</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>


        <span class="c1"># save the field feature shapes and dtypes in the settings group</span>
        <span class="n">shapes_grp</span> <span class="o">=</span> <span class="n">settings_grp</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">FIELD_FEATURE_SHAPES_STR</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">field_shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">field_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># set it as a dimensionless array of NaN</span>
                <span class="n">field_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="n">shapes_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">field_path</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">field_shape</span><span class="p">)</span>

        <span class="n">dtypes_grp</span> <span class="o">=</span> <span class="n">settings_grp</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">FIELD_FEATURE_DTYPES_STR</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">field_dtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_dtypes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">field_dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dt_str</span> <span class="o">=</span> <span class="n">NONE_STR</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># make a json string of the datatype that can be read</span>
                <span class="c1"># in again, we call np.dtype again because there is no</span>
                <span class="c1"># np.float.descr attribute</span>
                <span class="n">dt_str</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">field_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>

            <span class="n">dtypes_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">field_path</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">dt_str</span><span class="p">)</span>

        <span class="c1"># initialize the units group</span>
        <span class="n">unit_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">UNITS</span><span class="p">)</span>

        <span class="c1"># if units were not given set them all to None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_shapes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="p">[</span><span class="n">field_path</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># set the units</span>
        <span class="k">for</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">unit_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># ignore the field if not given</span>
            <span class="k">if</span> <span class="n">unit_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">unit_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">UNITS</span><span class="p">,</span> <span class="n">field_path</span><span class="p">)</span>

            <span class="n">unit_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">unit_path</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">unit_value</span><span class="p">)</span>


        <span class="c1"># create the group for the run data records</span>
        <span class="n">records_grp</span> <span class="o">=</span> <span class="n">settings_grp</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">RECORD_FIELDS</span><span class="p">)</span>

        <span class="c1"># create a dataset for the continuation run tuples</span>
        <span class="c1"># (continuation_run, base_run), where the first element</span>
        <span class="c1"># of the new run that is continuing the run in the second</span>
        <span class="c1"># position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_continuations</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_read_write_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read-write mode constructor.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_read_init</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_add_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The addition mode constructor.</span>

<span class="sd">        Create the dataset if it doesn&#39;t exist and put it in r+ mode,</span>
<span class="sd">        otherwise, just open in r+ mode.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exist_flags</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_init</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_write_init</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_read_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read mode constructor.&quot;&quot;&quot;</span>

        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_set_default_init_field_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the feature_shapes and feature_dtypes to be the default for</span>
<span class="sd">        this module. These will be used to initialize field datasets when no</span>
<span class="sd">        given during construction (i.e. for sparse values)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_dims : int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># we use the module defaults for the datasets to initialize them</span>
        <span class="n">field_feature_shapes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">FIELD_FEATURE_SHAPES</span><span class="p">)</span>
        <span class="n">field_feature_dtypes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">FIELD_FEATURE_DTYPES</span><span class="p">)</span>


        <span class="c1"># get the number of coordinates of positions. If there is a</span>
        <span class="c1"># main_reps then we have to set the number of atoms to that,</span>
        <span class="c1"># if not we count the number of atoms in the topology</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_main_rep_idxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_coords</span> <span class="o">=</span> <span class="n">json_top_atom_count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_main_rep_idxs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_coords</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_coords</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_main_rep_idxs</span><span class="p">)</span>

        <span class="c1"># get the number of dimensions as a default</span>
        <span class="k">if</span> <span class="n">n_dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_dims</span> <span class="o">=</span> <span class="n">N_DIMS</span>

        <span class="c1"># feature shapes for positions and positions-like fields are</span>
        <span class="c1"># not known at the module level due to different number of</span>
        <span class="c1"># coordinates (number of atoms) and number of dimensions</span>
        <span class="c1"># (default 3 spatial). We set them now that we know this</span>
        <span class="c1"># information.</span>
        <span class="c1"># add the postitions shape</span>
        <span class="n">field_feature_shapes</span><span class="p">[</span><span class="n">POSITIONS</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dims</span><span class="p">)</span>
        <span class="c1"># add the positions-like field shapes (velocities and forces) as the same</span>
        <span class="k">for</span> <span class="n">poslike_field</span> <span class="ow">in</span> <span class="n">POSITIONS_LIKE_FIELDS</span><span class="p">:</span>
            <span class="n">field_feature_shapes</span><span class="p">[</span><span class="n">poslike_field</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dims</span><span class="p">)</span>

        <span class="c1"># set the attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_shapes</span> <span class="o">=</span> <span class="n">field_feature_shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_field_feature_dtypes</span> <span class="o">=</span> <span class="n">field_feature_dtypes</span>

    <span class="k">def</span> <span class="nf">_get_field_path_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a field path for the trajectory returns the group the field&#39;s</span>
<span class="sd">        dataset goes in and the key for the field name in that group.</span>

<span class="sd">        The field path for a simple field is just the name of the</span>
<span class="sd">        field and for a compound field it is the compound field group</span>
<span class="sd">        name with the subfield separated by a &#39;/&#39; like</span>
<span class="sd">        &#39;observables/observable1&#39; where &#39;observables&#39; is the compound</span>
<span class="sd">        field group and &#39;observable1&#39; is the subfield name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>
<span class="sd">        field_path : str</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        group : h5py.Group</span>

<span class="sd">        field_name : str</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if it is compound</span>
        <span class="k">if</span> <span class="s1">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">field_path</span><span class="p">:</span>
            <span class="c1"># split it</span>
            <span class="n">grp_name</span><span class="p">,</span> <span class="n">field_name</span> <span class="o">=</span> <span class="n">field_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
            <span class="c1"># get the hdf5 group</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">grp_name</span><span class="p">)]</span>
        <span class="c1"># its simple so just return the root group and the original path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span>
            <span class="n">field_name</span> <span class="o">=</span> <span class="n">field_path</span>

        <span class="k">return</span> <span class="n">grp</span><span class="p">,</span> <span class="n">field_name</span>

    <span class="k">def</span> <span class="nf">_init_continuations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This will either create a dataset in the settings for the</span>
<span class="sd">        continuations or if continuations already exist it will reinitialize</span>
<span class="sd">        them and delete the data that exists there.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        continuation_dset : h5py.Dataset</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if the continuations dset already exists we reinitialize the</span>
        <span class="c1"># data</span>
        <span class="k">if</span> <span class="n">CONTINUATIONS</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings_grp</span><span class="p">:</span>
            <span class="n">cont_dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings_grp</span><span class="p">[</span><span class="n">CONTINUATIONS</span><span class="p">]</span>
            <span class="n">cont_dset</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>

        <span class="c1"># otherwise we just create the data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cont_dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">CONTINUATIONS</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span>
                                    <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cont_dset</span>


    <span class="k">def</span> <span class="nf">_add_run_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">continue_run</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Routines for creating a run includes updating and setting object</span>
<span class="sd">        global variables, increasing the counter for the number of runs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        continue_run : int</span>
<span class="sd">            Index of the run to continue.</span>

<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># add the run idx as metadata in the run group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">)]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">RUN_IDX</span><span class="p">]</span> <span class="o">=</span> <span class="n">run_idx</span>

        <span class="c1"># if this is continuing another run add the tuple (this_run,</span>
        <span class="c1"># continues_run) to the continutations settings</span>
        <span class="k">if</span> <span class="n">continue_run</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">add_continuation</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">continue_run</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_init_walkers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_walkers_grp</span><span class="p">,</span> <span class="n">init_walkers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the run field group for the initial walkers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        init_walkers_grp : h5py.Group</span>
<span class="sd">            The group to add the walker data to.</span>
<span class="sd">        init_walkers : list of objects implementing the Walker interface</span>
<span class="sd">            The walkers to save in the group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># add the initial walkers to the group by essentially making</span>
        <span class="c1"># new trajectories here that will only have one frame</span>
        <span class="k">for</span> <span class="n">walker_idx</span><span class="p">,</span> <span class="n">walker</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">init_walkers</span><span class="p">):</span>
            <span class="n">walker_grp</span> <span class="o">=</span> <span class="n">init_walkers_grp</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">walker_idx</span><span class="p">))</span>

            <span class="c1"># weights</span>

            <span class="c1"># get the weight from the walker and make a feature array of it</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">walker</span><span class="o">.</span><span class="n">weight</span><span class="p">]])</span>

            <span class="c1"># then create the dataset and set it</span>
            <span class="n">walker_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">WEIGHTS</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

            <span class="c1"># state fields data</span>
            <span class="k">for</span> <span class="n">field_key</span><span class="p">,</span> <span class="n">field_value</span> <span class="ow">in</span> <span class="n">walker</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="c1"># values may be None, just ignore them</span>
                <span class="k">if</span> <span class="n">field_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># just create the dataset by making it a feature array</span>
                    <span class="c1"># (wrapping it in another list)</span>
                    <span class="n">walker_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">field_key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">field_value</span><span class="p">]))</span>


    <span class="k">def</span> <span class="nf">_init_run_sporadic_record_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a sporadic record group for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        run_record_key : str</span>
<span class="sd">            The record group name.</span>
<span class="sd">        fields : list of field specs</span>
<span class="sd">            Each field spec is a 3-tuple of</span>
<span class="sd">            (field_name : str, field_shape : shape_spec, field_dtype : dtype_spec)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_group : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create the group</span>
        <span class="n">run_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>
        <span class="n">record_grp</span> <span class="o">=</span> <span class="n">run_grp</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">run_record_key</span><span class="p">)</span>

        <span class="c1"># initialize the cycles dataset that maps when the records</span>
        <span class="c1"># were recorded</span>
        <span class="n">record_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">CYCLE_IDXS</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span>
                                  <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,))</span>

        <span class="c1"># for each field simply create the dataset</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_shape</span><span class="p">,</span> <span class="n">field_dtype</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>

            <span class="c1"># initialize this field</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_run_records_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span>
                                         <span class="n">field_name</span><span class="p">,</span> <span class="n">field_shape</span><span class="p">,</span> <span class="n">field_dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">record_grp</span>


    <span class="k">def</span> <span class="nf">_init_run_continual_record_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a continual record group for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        run_record_key : str</span>
<span class="sd">            The record group name.</span>
<span class="sd">        fields : list of field specs</span>
<span class="sd">            Each field spec is a 3-tuple of</span>
<span class="sd">            (field_name : str, field_shape : shape_spec, field_dtype : dtype_spec)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_group : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create the group</span>
        <span class="n">run_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>
        <span class="n">record_grp</span> <span class="o">=</span> <span class="n">run_grp</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">run_record_key</span><span class="p">)</span>

        <span class="c1"># for each field simply create the dataset</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_shape</span><span class="p">,</span> <span class="n">field_dtype</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_init_run_records_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span>
                                         <span class="n">field_name</span><span class="p">,</span> <span class="n">field_shape</span><span class="p">,</span> <span class="n">field_dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">record_grp</span>

    <span class="k">def</span> <span class="nf">_init_run_records_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span>
                                <span class="n">field_name</span><span class="p">,</span> <span class="n">field_shape</span><span class="p">,</span> <span class="n">field_dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a single field for a run record group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        run_record_key : str</span>
<span class="sd">            The name of the record group.</span>
<span class="sd">        field_name : str</span>
<span class="sd">            The name of the field in the record group.</span>
<span class="sd">        field_shape : tuple of int</span>
<span class="sd">            The shape of the dataset for the field.</span>
<span class="sd">        field_dtype : dtype_spec</span>
<span class="sd">            An h5py recognized data type.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dataset : h5py.Dataset</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">record_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)[</span><span class="n">run_record_key</span><span class="p">]</span>

        <span class="c1"># check if it is variable length</span>
        <span class="k">if</span> <span class="n">field_shape</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="c1"># make a special dtype that allows it to be</span>
            <span class="c1"># variable length</span>
            <span class="n">vlen_dt</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">special_dtype</span><span class="p">(</span><span class="n">vlen</span><span class="o">=</span><span class="n">field_dtype</span><span class="p">)</span>

            <span class="c1"># this is only allowed to be a single dimension</span>
            <span class="c1"># since no real shape was given</span>
            <span class="n">dset</span> <span class="o">=</span> <span class="n">record_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">vlen_dt</span><span class="p">,</span>
                                        <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,))</span>

        <span class="c1"># its not just make it normally</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># create the group</span>
            <span class="n">dset</span> <span class="o">=</span> <span class="n">record_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">field_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">field_dtype</span><span class="p">,</span>
                                      <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">field_shape</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">dset</span>

    <span class="k">def</span> <span class="nf">_is_sporadic_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests whether a record group is sporadic or not.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            Record group name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_sporadic : bool</span>
<span class="sd">            True if the record group is sporadic False if not.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># assume it is continual and check if it is in the sporadic groups</span>
        <span class="k">if</span> <span class="n">run_record_key</span> <span class="ow">in</span> <span class="n">SPORADIC_RECORDS</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_init_traj_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">feature_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a trajectory field.</span>

<span class="sd">        Initialize a data field in the trajectory to be empty but</span>
<span class="sd">        resizeable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>
<span class="sd">        field_path : str</span>
<span class="sd">            Field name specification.</span>
<span class="sd">        feature_shape : shape_spec</span>
<span class="sd">            Specification of shape of a feature vector of the field.</span>
<span class="sd">        dtype : dtype_spec</span>
<span class="sd">            Specification of the feature vector datatype.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check whether this is a sparse field and create it</span>
        <span class="c1"># appropriately</span>
        <span class="k">if</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_fields</span><span class="p">:</span>
            <span class="c1"># it is a sparse field</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_sparse_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">feature_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># it is not a sparse field (AKA simple)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_contiguous_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">feature_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_contiguous_traj_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a contiguous (non-sparse) trajectory field.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>
<span class="sd">        field_path : str</span>
<span class="sd">            Field name specification.</span>
<span class="sd">        feature_shape : tuple of int</span>
<span class="sd">            Shape of the feature vector of the field.</span>
<span class="sd">        dtype : dtype_spec</span>
<span class="sd">            H5py recognized datatype</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">traj_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)]</span>

        <span class="c1"># create the empty dataset in the correct group, setting</span>
        <span class="c1"># maxshape so it can be resized for new feature vectors to be added</span>
        <span class="n">traj_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">field_path</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_init_sparse_traj_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>
<span class="sd">        field_path : str</span>
<span class="sd">            Field name specification.</span>
<span class="sd">        feature_shape : shape_spec</span>
<span class="sd">            Specification for the shape of the feature.</span>
<span class="sd">        dtype : dtype_spec</span>
<span class="sd">            Specification for the dtype of the feature.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">traj_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)]</span>

        <span class="c1"># check to see that neither the shape and dtype are</span>
        <span class="c1"># None which indicates it is a runtime defined value and</span>
        <span class="c1"># should be ignored here</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># do nothing</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># only create the group if you are going to add the</span>
            <span class="c1"># datasets so the extend function can know if it has been</span>
            <span class="c1"># properly initialized easier</span>
            <span class="n">sparse_grp</span> <span class="o">=</span> <span class="n">traj_grp</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">field_path</span><span class="p">)</span>

            <span class="c1"># create the dataset for the feature data</span>
            <span class="n">sparse_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">DATA</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                               <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">))</span>

            <span class="c1"># create the dataset for the sparse indices</span>
            <span class="n">sparse_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">SPARSE_IDXS</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,))</span>


    <span class="k">def</span> <span class="nf">_init_traj_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span>
                          <span class="n">field_paths</span><span class="p">,</span> <span class="n">field_feature_shapes</span><span class="p">,</span> <span class="n">field_feature_dtypes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a number of fields for a trajectory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>
<span class="sd">        field_paths : list of str</span>
<span class="sd">            List of field names.</span>
<span class="sd">        field_feature_shapes : list of shape_specs</span>
<span class="sd">        field_feature_dtypes : list of dtype_specs</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">field_paths</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span>
                                  <span class="n">field_path</span><span class="p">,</span> <span class="n">field_feature_shapes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">field_feature_dtypes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_add_traj_field_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">field_data</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a trajectory field to a trajectory.</span>

<span class="sd">        If the sparse indices are given the field will be created as a</span>
<span class="sd">        sparse field otherwise a normal one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        traj_idx : int</span>

<span class="sd">        field_path : str</span>
<span class="sd">            Field name.</span>

<span class="sd">        field_data : numpy.array</span>
<span class="sd">            The data array to set for the field.</span>

<span class="sd">        sparse_idxs : arraylike of int of shape (1,)</span>
<span class="sd">            List of cycle indices that the data corresponds to.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the traj group</span>
        <span class="n">traj_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)]</span>

        <span class="c1"># if it is a sparse dataset we need to add the data and add</span>
        <span class="c1"># the idxs in a group</span>
        <span class="k">if</span> <span class="n">sparse_idxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># first require that the dataset exist and is exactly the</span>
            <span class="c1"># same as the one that already exists (if indeed it</span>
            <span class="c1"># does). If it doesn&#39;t raise a specific error letting the</span>
            <span class="c1"># user know that they will have to delete the dataset if</span>
            <span class="c1"># they want to change it to something else</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">traj_grp</span><span class="o">.</span><span class="n">require_dataset</span><span class="p">(</span><span class="n">field_path</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">field_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                         <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;For changing the contents of a trajectory field it must be the same shape and dtype.&quot;</span><span class="p">)</span>

            <span class="c1"># if that succeeds then go ahead and set the data to the</span>
            <span class="c1"># dataset (overwriting if it is still there)</span>
            <span class="n">dset</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_data</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">sparse_grp</span> <span class="o">=</span> <span class="n">traj_grp</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">field_path</span><span class="p">)</span>
            <span class="c1"># add the data to this group</span>
            <span class="n">sparse_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">DATA</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">field_data</span><span class="p">,</span>
                                      <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="c1"># add the sparse idxs</span>
            <span class="n">sparse_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">SPARSE_IDXS</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">sparse_idxs</span><span class="p">,</span>
                                      <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">_extend_contiguous_traj_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">field_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add multiple new frames worth of data to the end of an existing</span>
<span class="sd">        contiguous (non-sparse)trajectory field.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>
<span class="sd">        field_path : str</span>
<span class="sd">            Field name</span>
<span class="sd">        field_data : numpy.array</span>
<span class="sd">            The frames of data to add.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">traj_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)]</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">traj_grp</span><span class="p">[</span><span class="n">field_path</span><span class="p">]</span>

        <span class="c1"># make sure this is a feature vector</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> \
            <span class="s2">&quot;field_data must be a feature vector with the same number of dimensions as the number&quot;</span>

        <span class="c1"># of datase new frames</span>
        <span class="n">n_new_frames</span> <span class="o">=</span> <span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># check the field to make sure it is not empty</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">]):</span>

            <span class="c1"># check the feature shape against the maxshape which gives</span>
            <span class="c1"># the feature dimensions for an empty dataset</span>
            <span class="k">assert</span> <span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">field</span><span class="o">.</span><span class="n">maxshape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> \
                <span class="s2">&quot;field feature dimensions must be the same, i.e. all but the first dimension&quot;</span>

            <span class="c1"># if it is empty resize it to make an array the size of</span>
            <span class="c1"># the new field_data with the maxshape for the feature</span>
            <span class="c1"># dimensions</span>
            <span class="n">feature_dims</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">maxshape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">field</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="n">n_new_frames</span><span class="p">,</span> <span class="o">*</span><span class="n">feature_dims</span><span class="p">)</span> <span class="p">)</span>

            <span class="c1"># set the new data to this</span>
            <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_data</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># make sure the new data has the right dimensions against</span>
            <span class="c1"># the shape it already has</span>
            <span class="k">assert</span> <span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> \
                <span class="s2">&quot;field feature dimensions must be the same, i.e. all but the first dimension&quot;</span>


            <span class="c1"># append to the dataset on the first dimension, keeping the</span>
            <span class="c1"># others the same, these must be feature vectors and therefore</span>
            <span class="c1"># must exist</span>
            <span class="n">field</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_new_frames</span><span class="p">,</span> <span class="o">*</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">)</span>
            <span class="c1"># add the new data</span>
            <span class="n">field</span><span class="p">[</span><span class="o">-</span><span class="n">n_new_frames</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_data</span>

    <span class="k">def</span> <span class="nf">_extend_sparse_traj_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add multiple new frames worth of data to the end of an existing</span>
<span class="sd">        contiguous (non-sparse)trajectory field.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>
<span class="sd">        field_path : str</span>
<span class="sd">            Field name</span>
<span class="sd">        values : numpy.array</span>
<span class="sd">            The frames of data to add.</span>
<span class="sd">        sparse_idxs : list of int</span>
<span class="sd">            The cycle indices the values correspond to.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">)]</span>

        <span class="n">field_data</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="n">DATA</span><span class="p">]</span>
        <span class="n">field_sparse_idxs</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="n">SPARSE_IDXS</span><span class="p">]</span>

        <span class="c1"># number of new frames</span>
        <span class="n">n_new_frames</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># if this sparse_field has been initialized empty we need to resize</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">]):</span>


            <span class="c1"># check the feature shape against the maxshape which gives</span>
            <span class="c1"># the feature dimensions for an empty dataset</span>
            <span class="k">assert</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">field_data</span><span class="o">.</span><span class="n">maxshape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> \
                <span class="s2">&quot;input value features have shape </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">field_data</span><span class="o">.</span><span class="n">maxshape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

            <span class="c1"># if it is empty resize it to make an array the size of</span>
            <span class="c1"># the new values with the maxshape for the feature</span>
            <span class="c1"># dimensions</span>
            <span class="n">feature_dims</span> <span class="o">=</span> <span class="n">field_data</span><span class="o">.</span><span class="n">maxshape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">field_data</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="n">n_new_frames</span><span class="p">,</span> <span class="o">*</span><span class="n">feature_dims</span><span class="p">)</span> <span class="p">)</span>

            <span class="c1"># set the new data to this</span>
            <span class="n">field_data</span><span class="p">[</span><span class="mi">0</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># make sure the new data has the right dimensions</span>
            <span class="k">assert</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> \
                <span class="s2">&quot;field feature dimensions must be the same, i.e. all but the first dimension&quot;</span>

            <span class="c1"># append to the dataset on the first dimension, keeping the</span>
            <span class="c1"># others the same, these must be feature vectors and therefore</span>
            <span class="c1"># must exist</span>
            <span class="n">field_data</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_new_frames</span><span class="p">,</span> <span class="o">*</span><span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">)</span>
            <span class="c1"># add the new data</span>
            <span class="n">field_data</span><span class="p">[</span><span class="o">-</span><span class="n">n_new_frames</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

        <span class="c1"># add the sparse idxs in the same way</span>
        <span class="n">field_sparse_idxs</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="n">field_sparse_idxs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_new_frames</span><span class="p">,</span>
                                   <span class="o">*</span><span class="n">field_sparse_idxs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">)</span>
        <span class="c1"># add the new data</span>
        <span class="n">field_sparse_idxs</span><span class="p">[</span><span class="o">-</span><span class="n">n_new_frames</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparse_idxs</span>

    <span class="k">def</span> <span class="nf">_add_sparse_field_flag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a trajectory field as sparse in the header settings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field_path : str</span>
<span class="sd">            Name of the trajectory field you want to flag as sparse</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sparse_fields_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">SPARSE_FIELDS</span><span class="p">)]</span>

        <span class="c1"># make sure it isn&#39;t already in the sparse_fields</span>
        <span class="k">if</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="n">sparse_fields_ds</span><span class="p">[:]:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;sparse field </span><span class="si">{}</span><span class="s2"> already a sparse field, ignoring&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field_path</span><span class="p">))</span>

        <span class="n">sparse_fields_ds</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="n">sparse_fields_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,)</span> <span class="p">)</span>
        <span class="n">sparse_fields_ds</span><span class="p">[</span><span class="n">sparse_fields_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_path</span>

    <span class="k">def</span> <span class="nf">_add_field_feature_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">field_feature_shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the shape to the header settings for a trajectory field.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field_path : str</span>
<span class="sd">            The name of the trajectory field you want to set for.</span>
<span class="sd">        field_feature_shape : shape_spec</span>
<span class="sd">            The shape spec to serialize as a dataset.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shapes_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">FIELD_FEATURE_SHAPES_STR</span><span class="p">)]</span>
        <span class="n">shapes_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">field_path</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">field_feature_shape</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_add_field_feature_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">field_feature_dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the data type to the header settings for a trajectory field.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field_path : str</span>
<span class="sd">            The name of the trajectory field you want to set for.</span>
<span class="sd">        field_feature_dtype : dtype_spec</span>
<span class="sd">            The dtype spec to serialize as a dataset.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">feature_dtype_str</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">field_feature_dtype</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>
        <span class="n">dtypes_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">FIELD_FEATURE_DTYPES_STR</span><span class="p">)]</span>
        <span class="n">dtypes_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">field_path</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">feature_dtype_str</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_set_field_feature_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">field_feature_shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the trajectory field shape to header settings or set the value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field_path : str</span>
<span class="sd">            The name of the trajectory field you want to set for.</span>
<span class="sd">        field_feature_shape : shape_spec</span>
<span class="sd">            The shape spec to serialize as a dataset.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if the field_feature_shape is already set</span>
        <span class="k">if</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_feature_shapes</span><span class="p">:</span>
            <span class="c1"># check that the shape was previously saved as &quot;None&quot; as we</span>
            <span class="c1"># won&#39;t overwrite anything else</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_feature_shapes</span><span class="p">[</span><span class="n">field_path</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">full_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">FIELD_FEATURE_SHAPES_STR</span><span class="p">,</span> <span class="n">field_path</span><span class="p">)</span>
                <span class="c1"># we have to delete the old data and set new data</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="n">full_path</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">field_feature_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot overwrite feature shape for </span><span class="si">{}</span><span class="s2"> with </span><span class="si">{}</span><span class="s2"> because it is </span><span class="si">{}</span><span class="s2"> not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">field_path</span><span class="p">,</span> <span class="n">field_feature_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_feature_shapes</span><span class="p">[</span><span class="n">field_path</span><span class="p">],</span>
                        <span class="n">NONE_STR</span><span class="p">))</span>
        <span class="c1"># it was not previously set so we must create then save it</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_field_feature_shape</span><span class="p">(</span><span class="n">field_path</span><span class="p">,</span> <span class="n">field_feature_shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_field_feature_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">field_feature_dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the trajectory field dtype to header settings or set the value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field_path : str</span>
<span class="sd">            The name of the trajectory field you want to set for.</span>
<span class="sd">        field_feature_dtype : dtype_spec</span>
<span class="sd">            The dtype spec to serialize as a dataset.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">feature_dtype_str</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">field_feature_dtype</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>
        <span class="c1"># check if the field_feature_dtype is already set</span>
        <span class="k">if</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_feature_dtypes</span><span class="p">:</span>
            <span class="c1"># check that the dtype was previously saved as &quot;None&quot; as we</span>
            <span class="c1"># won&#39;t overwrite anything else</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_feature_dtypes</span><span class="p">[</span><span class="n">field_path</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">full_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">FIELD_FEATURE_DTYPES_STR</span><span class="p">,</span> <span class="n">field_path</span><span class="p">)</span>
                <span class="c1"># we have to delete the old data and set new data</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="n">full_path</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">feature_dtype_str</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot overwrite feature dtype for </span><span class="si">{}</span><span class="s2"> with </span><span class="si">{}</span><span class="s2"> because it is </span><span class="si">{}</span><span class="s2"> not &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">field_path</span><span class="p">,</span> <span class="n">field_feature_dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_feature_dtypes</span><span class="p">[</span><span class="n">field_path</span><span class="p">],</span>
                        <span class="n">NONE_STR</span><span class="p">))</span>
        <span class="c1"># it was not previously set so we must create then save it</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_field_feature_dtype</span><span class="p">(</span><span class="n">field_path</span><span class="p">,</span> <span class="n">field_feature_dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extend_run_record_data_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span>
                                          <span class="n">field_name</span><span class="p">,</span> <span class="n">field_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Primitive record append method.</span>

<span class="sd">        Adds data for a single field dataset in a run records group. This</span>
<span class="sd">        is done without paying attention to whether it is sporadic or</span>
<span class="sd">        continual and is supposed to be only the data write method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            Name of the record group.</span>
<span class="sd">        field_name : str</span>
<span class="sd">            Name of the field in the record group to add to.</span>
<span class="sd">        field_data : arraylike</span>
<span class="sd">            The data to add to the field.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">records_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">)]</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">records_grp</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>

        <span class="c1"># make sure this is a feature vector</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> \
            <span class="s2">&quot;field_data must be a feature vector with the same number of dimensions as the number&quot;</span>

        <span class="c1"># of datase new frames</span>
        <span class="n">n_new_frames</span> <span class="o">=</span> <span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># check whether it is a variable length record, by getting the</span>
        <span class="c1"># record dataset dtype and using the checker to see if it is</span>
        <span class="c1"># the vlen special type in h5py</span>
        <span class="k">if</span> <span class="n">h5py</span><span class="o">.</span><span class="n">check_dtype</span><span class="p">(</span><span class="n">vlen</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># if it is we have to treat it differently, since it</span>
            <span class="c1"># cannot be multidimensional</span>

            <span class="c1"># if the dataset has no data in it we need to reshape it</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">]):</span>
                <span class="c1"># initialize this array</span>
                <span class="c1"># if it is empty resize it to make an array the size of</span>
                <span class="c1"># the new field_data with the maxshape for the feature</span>
                <span class="c1"># dimensions</span>
                <span class="n">field</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="n">n_new_frames</span><span class="p">,)</span> <span class="p">)</span>

                <span class="c1"># set the new data to this</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">field_data</span><span class="p">):</span>
                    <span class="n">field</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>

            <span class="c1"># otherwise just add the data</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># resize the array but it is only of rank because</span>
                <span class="c1"># of variable length data</span>
                <span class="n">field</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_new_frames</span><span class="p">,</span> <span class="p">)</span> <span class="p">)</span>

                <span class="c1"># add each row to the newly made space</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">field_data</span><span class="p">):</span>
                    <span class="n">field</span><span class="p">[(</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>

        <span class="c1"># if it is not variable length we don&#39;t have to treat it</span>
        <span class="c1"># differently</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># if this is empty we need to reshape the dataset to accomodate data</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">]):</span>

                <span class="c1"># check the feature shape against the maxshape which gives</span>
                <span class="c1"># the feature dimensions for an empty dataset</span>
                <span class="k">assert</span> <span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">field</span><span class="o">.</span><span class="n">maxshape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> \
                    <span class="s2">&quot;field feature dimensions must be the same, i.e. all but the first dimension&quot;</span>

                <span class="c1"># if it is empty resize it to make an array the size of</span>
                <span class="c1"># the new field_data with the maxshape for the feature</span>
                <span class="c1"># dimensions</span>
                <span class="n">feature_dims</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">maxshape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">field</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="n">n_new_frames</span><span class="p">,</span> <span class="o">*</span><span class="n">feature_dims</span><span class="p">)</span> <span class="p">)</span>

                <span class="c1"># set the new data to this</span>
                <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_data</span>

            <span class="c1"># otherwise just add the data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># append to the dataset on the first dimension, keeping the</span>
                <span class="c1"># others the same, these must be feature vectors and therefore</span>
                <span class="c1"># must exist</span>
                <span class="n">field</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_new_frames</span><span class="p">,</span> <span class="o">*</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">)</span>
                <span class="c1"># add the new data</span>
                <span class="n">field</span><span class="p">[</span><span class="o">-</span><span class="n">n_new_frames</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_data</span>


    <span class="k">def</span> <span class="nf">_run_record_namedtuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a namedtuple record type for a record group.</span>

<span class="sd">        The class name will be formatted like &#39;{}_Record&#39; where the {}</span>
<span class="sd">        will be replaced with the name of the record group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            Name of the record group</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RecordType : namedtuple</span>
<span class="sd">            The record type to generate records for this record group.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Record</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_Record&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">run_record_key</span><span class="p">),</span>
                            <span class="p">[</span><span class="n">CYCLE_IDX</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_fields</span><span class="p">[</span><span class="n">run_record_key</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">Record</span>

    <span class="k">def</span> <span class="nf">_convert_record_field_to_table_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span> <span class="n">record_field</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a dataset of feature vectors to more palatable values for</span>
<span class="sd">        use in external datasets.</span>

<span class="sd">        For single value feature vectors it unwraps them into single</span>
<span class="sd">        values.</span>

<span class="sd">        For 1-D feature vectors it casts them as tuples.</span>

<span class="sd">        Anything of higher rank will raise an error.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            Name of the record group</span>
<span class="sd">        record_field : str</span>
<span class="sd">            Name of the field of the record group</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        record_dset : list</span>
<span class="sd">            Table-ified values</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>

<span class="sd">        TypeError</span>
<span class="sd">            If the field feature vector shape rank is greater than 1.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the field dataset</span>
        <span class="n">rec_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">records_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">)</span>
        <span class="n">dset</span> <span class="o">=</span> <span class="n">rec_grp</span><span class="p">[</span><span class="n">record_field</span><span class="p">]</span>

        <span class="c1"># if it is variable length or if it has more than one element</span>
        <span class="c1"># cast all elements to tuples</span>
        <span class="k">if</span> <span class="n">h5py</span><span class="o">.</span><span class="n">check_dtype</span><span class="p">(</span><span class="n">vlen</span><span class="o">=</span><span class="n">dset</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rec_dset</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dset</span><span class="p">[:]]</span>

        <span class="c1"># if it is not variable length make sure it is not more than a</span>
        <span class="c1"># 1D feature vector</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;cannot convert fields with feature vectors more than 1 dimension,&quot;</span>
                <span class="s2">&quot; was given </span><span class="si">{}</span><span class="s2"> for </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">dset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">run_record_key</span><span class="p">,</span> <span class="n">record_field</span><span class="p">))</span>

        <span class="c1"># if it is only a rank 1 feature vector and it has more than</span>
        <span class="c1"># one element make a tuple out of it</span>
        <span class="k">elif</span> <span class="n">dset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rec_dset</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dset</span><span class="p">[:]]</span>

        <span class="c1"># otherwise just get the single value instead of keeping it as</span>
        <span class="c1"># a single valued feature vector</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rec_dset</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dset</span><span class="p">[:]]</span>

        <span class="k">return</span> <span class="n">rec_dset</span>

    <span class="k">def</span> <span class="nf">_convert_record_fields_to_table_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert record group data to truncated namedtuple records.</span>

<span class="sd">        This uses the specified record fields from the header settings</span>
<span class="sd">        to choose which record group fields to apply this to.</span>

<span class="sd">        Does no checking to make sure the fields are</span>
<span class="sd">        &quot;table-ifiable&quot;. If a field is not it will raise a TypeError.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            The name of the record group</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        table_fields : dict of str : list</span>
<span class="sd">            Mapping of the record group field to the table-ified values.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">record_field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_fields</span><span class="p">[</span><span class="n">run_record_key</span><span class="p">]:</span>
            <span class="n">fields</span><span class="p">[</span><span class="n">record_field</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_record_field_to_table_column</span><span class="p">(</span>
                                           <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span> <span class="n">record_field</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fields</span>

    <span class="k">def</span> <span class="nf">_make_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span> <span class="n">cycle_idxs</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a list of proper (nametuple) records for a record group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            Name of the record group</span>
<span class="sd">        cycle_idxs : list of int</span>
<span class="sd">            The cycle indices you want to get records for.</span>
<span class="sd">        fields : list of str</span>
<span class="sd">            The fields to make record entries for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records : list of namedtuple objects</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_record_namedtuple</span><span class="p">(</span><span class="n">run_record_key</span><span class="p">)</span>

        <span class="c1"># for each record we make a tuple and yield it</span>
        <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">record_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cycle_idxs</span><span class="p">)):</span>

            <span class="c1"># make a record for this cycle</span>
            <span class="n">record_d</span> <span class="o">=</span> <span class="p">{</span><span class="n">CYCLE_IDX</span> <span class="p">:</span> <span class="n">cycle_idxs</span><span class="p">[</span><span class="n">record_idx</span><span class="p">]}</span>
            <span class="k">for</span> <span class="n">record_field</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">datum</span> <span class="o">=</span> <span class="n">column</span><span class="p">[</span><span class="n">record_idx</span><span class="p">]</span>
                <span class="n">record_d</span><span class="p">[</span><span class="n">record_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">datum</span>

            <span class="n">record</span> <span class="o">=</span> <span class="n">Record</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">record_d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">Record</span><span class="o">.</span><span class="n">_fields</span><span class="p">))</span>

            <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">records</span>

    <span class="k">def</span> <span class="nf">_run_records_sporadic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate records for a sporadic record group for a multi-run</span>
<span class="sd">        contig.</span>

<span class="sd">        If multiple run indices are given assumes that these are a</span>
<span class="sd">        contig (e.g. the second run index is a continuation of the</span>
<span class="sd">        first and so on). This method is considered low-level and does</span>
<span class="sd">        no checking to make sure this is true.</span>

<span class="sd">        The cycle indices of records from &quot;continuation&quot; runs will be</span>
<span class="sd">        modified so as the records will be indexed as if they are a</span>
<span class="sd">        single run.</span>

<span class="sd">        Uses the record fields settings to decide which fields to use.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The indices of the runs in the order they are in the contig</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            Name of the record group</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records : list of namedtuple objects</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># we loop over the run_idxs in the contig and get the fields</span>
        <span class="c1"># and cycle idxs for the whole contig</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">cycle_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># keep a cumulative total of the runs cycle idxs</span>
        <span class="n">prev_run_cycle_total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="n">run_idxs</span><span class="p">:</span>

            <span class="c1"># get all the value columns from the datasets, and convert</span>
            <span class="c1"># them to something amenable to a table</span>
            <span class="n">run_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_record_fields_to_table_columns</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">)</span>

            <span class="c1"># we need to concatenate each field to the end of the</span>
            <span class="c1"># field in the master dictionary, first we need to</span>
            <span class="c1"># initialize it if it isn&#39;t already made</span>
            <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if it isn&#39;t initialized we just set it as this first</span>
                <span class="c1"># run fields dictionary</span>
                <span class="n">fields</span> <span class="o">=</span> <span class="n">run_fields</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if it is already initialized we need to go through</span>
                <span class="c1"># each field and concatenate</span>
                <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_data</span> <span class="ow">in</span> <span class="n">run_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># just add it to the list of fields that will be concatenated later</span>
                    <span class="n">fields</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">field_data</span><span class="p">)</span>

            <span class="c1"># get the cycle idxs for this run</span>
            <span class="n">rec_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">records_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">)</span>
            <span class="n">run_cycle_idxs</span> <span class="o">=</span> <span class="n">rec_grp</span><span class="p">[</span><span class="n">CYCLE_IDXS</span><span class="p">][:]</span>

            <span class="c1"># add the total number of cycles that came before this run</span>
            <span class="c1"># to each of the cycle idxs to get the cycle_idxs in terms</span>
            <span class="c1"># of the full contig</span>
            <span class="n">run_contig_cycle_idxs</span> <span class="o">=</span> <span class="n">run_cycle_idxs</span> <span class="o">+</span> <span class="n">prev_run_cycle_total</span>

            <span class="c1"># add these cycle indices to the records for the whole contig</span>
            <span class="n">cycle_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span> <span class="p">(</span><span class="n">cycle_idxs</span><span class="p">,</span> <span class="n">run_contig_cycle_idxs</span><span class="p">)</span> <span class="p">)</span>

            <span class="c1"># add the total number of cycle_idxs from this run to the</span>
            <span class="c1"># running total</span>
            <span class="n">prev_run_cycle_total</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_cycles</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>

        <span class="c1"># then make the records from the fields</span>
        <span class="n">records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_records</span><span class="p">(</span><span class="n">run_record_key</span><span class="p">,</span> <span class="n">cycle_idxs</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">records</span>

    <span class="k">def</span> <span class="nf">_run_records_continual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate records for a continual record group for a multi-run</span>
<span class="sd">        contig.</span>

<span class="sd">        If multiple run indices are given assumes that these are a</span>
<span class="sd">        contig (e.g. the second run index is a continuation of the</span>
<span class="sd">        first and so on). This method is considered low-level and does</span>
<span class="sd">        no checking to make sure this is true.</span>

<span class="sd">        The cycle indices of records from &quot;continuation&quot; runs will be</span>
<span class="sd">        modified so as the records will be indexed as if they are a</span>
<span class="sd">        single run.</span>

<span class="sd">        Uses the record fields settings to decide which fields to use.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The indices of the runs in the order they are in the contig</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            Name of the record group</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records : list of namedtuple objects</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cycle_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">prev_run_cycle_total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="n">run_idxs</span><span class="p">:</span>
            <span class="c1"># get all the value columns from the datasets, and convert</span>
            <span class="c1"># them to something amenable to a table</span>
            <span class="n">run_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_record_fields_to_table_columns</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">)</span>

            <span class="c1"># we need to concatenate each field to the end of the</span>
            <span class="c1"># field in the master dictionary, first we need to</span>
            <span class="c1"># initialize it if it isn&#39;t already made</span>
            <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if it isn&#39;t initialized we just set it as this first</span>
                <span class="c1"># run fields dictionary</span>
                <span class="n">fields</span> <span class="o">=</span> <span class="n">run_fields</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if it is already initialized we need to go through</span>
                <span class="c1"># each field and concatenate</span>
                <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_data</span> <span class="ow">in</span> <span class="n">run_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># just add it to the list of fields that will be concatenated later</span>
                    <span class="n">fields</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">field_data</span><span class="p">)</span>

            <span class="c1"># get one of the fields (if any to iterate over)</span>
            <span class="n">record_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_fields</span><span class="p">[</span><span class="n">run_record_key</span><span class="p">]</span>
            <span class="n">main_record_field</span> <span class="o">=</span> <span class="n">record_fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># make the cycle idxs from that</span>
            <span class="n">run_rec_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">records_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">)</span>
            <span class="n">run_cycle_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">run_rec_grp</span><span class="p">[</span><span class="n">main_record_field</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="c1"># add the total number of cycles that came before this run</span>
            <span class="c1"># to each of the cycle idxs to get the cycle_idxs in terms</span>
            <span class="c1"># of the full contig</span>
            <span class="n">run_contig_cycle_idxs</span> <span class="o">=</span> <span class="n">run_cycle_idxs</span> <span class="o">+</span> <span class="n">prev_run_cycle_total</span>

            <span class="c1"># add these cycle indices to the records for the whole contig</span>
            <span class="n">cycle_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span> <span class="p">(</span><span class="n">cycle_idxs</span><span class="p">,</span> <span class="n">run_contig_cycle_idxs</span><span class="p">)</span> <span class="p">)</span>

            <span class="c1"># add the total number of cycle_idxs from this run to the</span>
            <span class="c1"># running total</span>
            <span class="n">prev_run_cycle_total</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_cycles</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>


        <span class="c1"># then make the records from the fields</span>
        <span class="n">records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_records</span><span class="p">(</span><span class="n">run_record_key</span><span class="p">,</span> <span class="n">cycle_idxs</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">records</span>


    <span class="k">def</span> <span class="nf">_get_contiguous_traj_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Access actual data for a trajectory field.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>
<span class="sd">        field_path : str</span>
<span class="sd">            Trajectory field name to access</span>
<span class="sd">        frames : list of int, optional</span>
<span class="sd">            The indices of the frames to return if you don&#39;t want all of them.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        field_data : arraylike</span>
<span class="sd">            The data requested for the field.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">full_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">frames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="n">full_path</span><span class="p">][:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="n">full_path</span><span class="p">][</span><span class="nb">list</span><span class="p">(</span><span class="n">frames</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">field</span>

    <span class="k">def</span> <span class="nf">_get_sparse_traj_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">masked</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Access actual data for a trajectory field.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>
<span class="sd">        field_path : str</span>
<span class="sd">            Trajectory field name to access</span>

<span class="sd">        frames : list of int, optional</span>
<span class="sd">            The indices of the frames to return if you don&#39;t want all of them.</span>

<span class="sd">        masked : bool</span>
<span class="sd">            If True returns the array data as numpy masked array, and</span>
<span class="sd">            only the available values if False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        field_data : arraylike</span>
<span class="sd">            The data requested for the field.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">traj_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)</span>
        <span class="n">traj_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="n">traj_path</span><span class="p">]</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">traj_grp</span><span class="p">[</span><span class="n">field_path</span><span class="p">]</span>

        <span class="n">n_frames</span> <span class="o">=</span> <span class="n">traj_grp</span><span class="p">[</span><span class="n">POSITIONS</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">frames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="n">DATA</span><span class="p">][:]</span>

            <span class="c1"># if it is to be masked make the masked array</span>
            <span class="k">if</span> <span class="n">masked</span><span class="p">:</span>
                <span class="n">sparse_idxs</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="n">SPARSE_IDXS</span><span class="p">][:]</span>

                <span class="n">filled_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span> <span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">filled_data</span><span class="p">[</span><span class="n">sparse_idxs</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span> <span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">sparse_idxs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">filled_data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># get the sparse idxs and the frames to slice from the</span>
            <span class="c1"># data</span>
            <span class="n">sparse_idxs</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="n">SPARSE_IDXS</span><span class="p">][:]</span>

            <span class="c1"># we get a boolean array of the rows of the data table</span>
            <span class="c1"># that we are to slice from</span>
            <span class="n">sparse_frame_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">sparse_idxs</span><span class="p">,</span> <span class="n">frames</span><span class="p">))</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="n">DATA</span><span class="p">][</span><span class="nb">list</span><span class="p">(</span><span class="n">sparse_frame_idxs</span><span class="p">)]</span>

            <span class="c1"># if it is to be masked make the masked array</span>
            <span class="k">if</span> <span class="n">masked</span><span class="p">:</span>
                <span class="c1"># the empty arrays the size of the number of requested frames</span>
                <span class="n">filled_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">),</span> <span class="o">*</span><span class="n">field</span><span class="p">[</span><span class="n">DATA</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">),</span> <span class="o">*</span><span class="n">field</span><span class="p">[</span><span class="n">DATA</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="kc">True</span> <span class="p">)</span>

                <span class="c1"># take the data which exists and is part of the frames</span>
                <span class="c1"># selection, and put it into the filled data where it is</span>
                <span class="c1"># supposed to be</span>
                <span class="n">filled_data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data</span>

                <span class="c1"># unmask the present values</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">filled_data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>


    <span class="k">def</span> <span class="nf">_add_run_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a trajectory field to all trajectories in a run.</span>

<span class="sd">        By enforcing adding it to all trajectories at one time we</span>
<span class="sd">        promote in-run consistency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        field_path : str</span>
<span class="sd">            Name to set the trajectory field as. Can be compound.</span>
<span class="sd">        data : arraylike of shape (n_trajectories, n_cycles, feature_vector_shape[0],...)</span>
<span class="sd">            The data for all trajectories to be added.</span>
<span class="sd">        sparse_idxs : list of int</span>
<span class="sd">            If the data you are adding is sparse specify which cycles to apply them to.</span>


<span class="sd">        If &#39;force&#39; is turned on, no checking for constraints will be done.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check that the data has the correct number of trajectories</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_trajs</span><span class="p">(</span><span class="n">run_idx</span><span class="p">),</span>\
                <span class="s2">&quot;The number of trajectories in data, </span><span class="si">{}</span><span class="s2">, is different than the number&quot;</span>\
                <span class="s2">&quot;of trajectories in the run, </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_trajs</span><span class="p">(</span><span class="n">run_idx</span><span class="p">))</span>

            <span class="c1"># for each trajectory check that the data is compliant</span>
            <span class="k">for</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">traj_data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
                    <span class="c1"># check that the number of frames is not larger than that for the run</span>
                    <span class="k">if</span> <span class="n">traj_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_cycles</span><span class="p">(</span><span class="n">run_idx</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of frames in data for traj </span><span class="si">{}</span><span class="s2"> , </span><span class="si">{}</span><span class="s2">,&quot;</span>
                                          <span class="s2">&quot;is larger than the number of frames&quot;</span>
                                          <span class="s2">&quot;for this run, </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                  <span class="n">traj_idx</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_cycles</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)))</span>


                <span class="c1"># if the number of frames given is the same or less than</span>
                <span class="c1"># the number of frames in the run</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">traj_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_cycles</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)):</span>

                    <span class="c1"># if sparse idxs were given we check to see there is</span>
                    <span class="c1"># the right number of them</span>
                    <span class="c1">#  and that they match the number of frames given</span>
                    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparse_idxs</span><span class="p">[</span><span class="n">traj_idx</span><span class="p">]):</span>

                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of frames provided for traj </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">,&quot;</span>
                                          <span class="s2">&quot;was less than the total number of frames, </span><span class="si">{}</span><span class="s2">,&quot;</span>
                                          <span class="s2">&quot;but an incorrect number of sparse idxs were supplied, </span><span class="si">{}</span><span class="s2">.&quot;</span>\
                                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">traj_idx</span><span class="p">,</span> <span class="n">traj_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">num_run_cycles</span><span class="p">(</span><span class="n">run_idx</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparse_idxs</span><span class="p">[</span><span class="n">traj_idx</span><span class="p">])))</span>


                    <span class="c1"># if there were strictly fewer frames given and the</span>
                    <span class="c1"># sparse idxs were not given we need to raise an error</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">traj_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_cycles</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)):</span>

                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of frames provided for traj </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">,&quot;</span>
                                          <span class="s2">&quot;was less than the total number of frames, </span><span class="si">{}</span><span class="s2">,&quot;</span>
                                          <span class="s2">&quot;but sparse_idxs were not supplied.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                  <span class="n">traj_idx</span><span class="p">,</span> <span class="n">traj_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">num_run_cycles</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)))</span>

        <span class="c1"># add it to each traj</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx_tup</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_traj_idx_tuples</span><span class="p">([</span><span class="n">run_idx</span><span class="p">])):</span>
            <span class="k">if</span> <span class="n">sparse_idxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_traj_field_data</span><span class="p">(</span><span class="o">*</span><span class="n">idx_tup</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_traj_field_data</span><span class="p">(</span><span class="o">*</span><span class="n">idx_tup</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                          <span class="n">sparse_idxs</span><span class="o">=</span><span class="n">sparse_idxs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_add_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a trajectory field to all runs in a file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field_path : str</span>
<span class="sd">            Name of trajectory field</span>
<span class="sd">        data : list of arraylike</span>
<span class="sd">            Each element of this list corresponds to a single run. The</span>
<span class="sd">            elements of which are arraylikes of shape (n_trajectories,</span>
<span class="sd">            n_cycles, feature_vector_shape[0],...) for each run.</span>
<span class="sd">        sparse_idxs : list of list of int</span>
<span class="sd">            The list of cycle indices to set for the sparse fields. If</span>
<span class="sd">            None, no trajectories are set as sparse.</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_idxs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sparse_idxs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_run_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sparse_idxs</span><span class="o">=</span><span class="n">sparse_idxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                    <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_run_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                    <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>

    <span class="c1">#### Public Methods</span>

    <span class="c1">### File Utilities</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filename</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The path to the underlying HDF5 file.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span>

<div class="viewcode-block" id="WepyHDF5.open"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open the underlying HDF5 file for access.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        mode : str</span>
<span class="sd">           Valid mode spec. Opens the HDF5 file in this mode if given</span>
<span class="sd">           otherwise uses the existing mode.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                                 <span class="n">libver</span><span class="o">=</span><span class="n">H5PY_LIBVER</span><span class="p">,</span> <span class="n">swmr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">swmr_mode</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;This file is already open&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.close"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close the underlying HDF5 file. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The WepyHDF5 mode this object was created with.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wepy_mode</span>

    <span class="nd">@mode</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the mode for opening the file with.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

<div class="viewcode-block" id="WepyHDF5.set_mode"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.set_mode">[docs]</a>    <span class="k">def</span> <span class="nf">set_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the mode for opening the file with.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Cannot set the mode while the file is open.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_h5_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_wepy_mode</span> <span class="o">=</span> <span class="n">mode</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">h5_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The h5py.File mode the HDF5 file currently has.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">mode</span>

    <span class="k">def</span> <span class="nf">_set_h5_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the mode to open the HDF5 file with.</span>

<span class="sd">        This really shouldn&#39;t be set without using the main wepy mode</span>
<span class="sd">        as they need to be aligned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Cannot set the mode while the file is open.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_h5py_mode</span> <span class="o">=</span> <span class="n">h5_mode</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">h5</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The underlying h5py.File object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span>

    <span class="c1">### h5py object access</span>

<div class="viewcode-block" id="WepyHDF5.run"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the h5py.Group for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        run_group : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">run_idx</span><span class="p">))]</span></div>

<div class="viewcode-block" id="WepyHDF5.traj"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.traj">[docs]</a>    <span class="k">def</span> <span class="nf">traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an h5py.Group trajectory group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        traj_group : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)]</span></div>

<div class="viewcode-block" id="WepyHDF5.run_trajs"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run_trajs">[docs]</a>    <span class="k">def</span> <span class="nf">run_trajs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the trajectories group for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trajectories_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">)]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">runs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The runs group.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="n">RUNS</span><span class="p">]</span>

<div class="viewcode-block" id="WepyHDF5.run_grp"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run_grp">[docs]</a>    <span class="k">def</span> <span class="nf">run_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A group for a single run.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)]</span></div>

<div class="viewcode-block" id="WepyHDF5.run_start_snapshot_hash"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run_start_snapshot_hash">[docs]</a>    <span class="k">def</span> <span class="nf">run_start_snapshot_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hash identifier for the starting snapshot of a run from</span>
<span class="sd">        orchestration.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">RUN_START_SNAPSHOT_HASH</span><span class="p">]</span></div>

<div class="viewcode-block" id="WepyHDF5.run_end_snapshot_hash"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run_end_snapshot_hash">[docs]</a>    <span class="k">def</span> <span class="nf">run_end_snapshot_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hash identifier for the ending snapshot of a run from</span>
<span class="sd">        orchestration.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">RUN_END_SNAPSHOT_HASH</span><span class="p">]</span></div>

<div class="viewcode-block" id="WepyHDF5.set_run_start_snapshot_hash"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.set_run_start_snapshot_hash">[docs]</a>    <span class="k">def</span> <span class="nf">set_run_start_snapshot_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">snaphash</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the starting snapshot hash identifier for a run from</span>
<span class="sd">        orchestration.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">RUN_START_SNAPSHOT_HASH</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">RUN_START_SNAPSHOT_HASH</span><span class="p">]</span> <span class="o">=</span> <span class="n">snaphash</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;The snapshot has already been set.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.set_run_end_snapshot_hash"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.set_run_end_snapshot_hash">[docs]</a>    <span class="k">def</span> <span class="nf">set_run_end_snapshot_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">snaphash</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the ending snapshot hash identifier for a run from</span>
<span class="sd">        orchestration.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">RUN_END_SNAPSHOT_HASH</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">RUN_END_SNAPSHOT_HASH</span><span class="p">]</span> <span class="o">=</span> <span class="n">snaphash</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;The snapshot has already been set.&quot;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">settings_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The header settings group.&quot;&quot;&quot;</span>
        <span class="n">settings_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="n">SETTINGS</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">settings_grp</span>

<div class="viewcode-block" id="WepyHDF5.decision_grp"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.decision_grp">[docs]</a>    <span class="k">def</span> <span class="nf">decision_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the decision enumeration group for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        decision_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)[</span><span class="n">DECISION</span><span class="p">]</span></div>

<div class="viewcode-block" id="WepyHDF5.init_walkers_grp"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_walkers_grp">[docs]</a>    <span class="k">def</span> <span class="nf">init_walkers_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the group for the initial walkers for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        init_walkers_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)[</span><span class="n">INIT_WALKERS</span><span class="p">]</span></div>


<div class="viewcode-block" id="WepyHDF5.records_grp"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.records_grp">[docs]</a>    <span class="k">def</span> <span class="nf">records_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a record group h5py.Group for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            Name of the record group</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        run_record_group : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="n">path</span><span class="p">]</span></div>

<div class="viewcode-block" id="WepyHDF5.resampling_grp"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.resampling_grp">[docs]</a>    <span class="k">def</span> <span class="nf">resampling_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get this record group for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        run_record_group : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">records_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">RESAMPLING</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.resampler_grp"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.resampler_grp">[docs]</a>    <span class="k">def</span> <span class="nf">resampler_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get this record group for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        run_record_group : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">records_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">RESAMPLER</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.warping_grp"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.warping_grp">[docs]</a>    <span class="k">def</span> <span class="nf">warping_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get this record group for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        run_record_group : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">records_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">WARPING</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.bc_grp"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.bc_grp">[docs]</a>    <span class="k">def</span> <span class="nf">bc_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get this record group for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        run_record_group : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">records_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">BC</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.progress_grp"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.progress_grp">[docs]</a>    <span class="k">def</span> <span class="nf">progress_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get this record group for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        run_record_group : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">records_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">PROGRESS</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.iter_runs"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.iter_runs">[docs]</a>    <span class="k">def</span> <span class="nf">iter_runs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">run_sel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator for iterating through the runs of a file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        idxs : bool</span>
<span class="sd">            If True yields the run index in addition to the group.</span>

<span class="sd">        run_sel : list of int, optional</span>
<span class="sd">            If not None should be a list of the runs you want to iterate over.</span>


<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        run_idx : int, if idxs is True</span>

<span class="sd">        run_group : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">run_sel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">run_sel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_idxs</span>

        <span class="k">for</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_idxs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="n">run_sel</span><span class="p">:</span>
                <span class="n">run</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">idxs</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">run</span></div>

<div class="viewcode-block" id="WepyHDF5.iter_trajs"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.iter_trajs">[docs]</a>    <span class="k">def</span> <span class="nf">iter_trajs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">traj_sel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator for iterating over trajectories in a file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        idxs : bool</span>
<span class="sd">            If True returns a tuple of the run index and trajectory</span>
<span class="sd">            index in addition to the trajectory group.</span>
<span class="sd">        traj_sel : list of int, optional</span>
<span class="sd">            If not None is a list of tuples of (run_idx, traj_idx)</span>
<span class="sd">            selecting which trajectories to iterate over.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        traj_id : tuple of int, if idxs is True</span>
<span class="sd">            A tuple of (run_idx, traj_idx) for the group</span>

<span class="sd">        trajectory : h5py.Group</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># set the selection of trajectories to iterate over</span>
        <span class="k">if</span> <span class="n">traj_sel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx_tups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_traj_idx_tuples</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx_tups</span> <span class="o">=</span> <span class="n">traj_sel</span>

        <span class="c1"># get each traj for each idx_tup and yield them for the generator</span>
        <span class="k">for</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span> <span class="ow">in</span> <span class="n">idx_tups</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idxs</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">),</span> <span class="n">traj</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">traj</span></div>

<div class="viewcode-block" id="WepyHDF5.iter_run_trajs"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.iter_run_trajs">[docs]</a>    <span class="k">def</span> <span class="nf">iter_run_trajs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over the trajectories of a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        idxs : bool</span>
<span class="sd">            If True returns a tuple of the run index and trajectory</span>
<span class="sd">            index in addition to the trajectory group.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iter_trajs_generator : generator for the iter_trajs method</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">run_sel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_traj_idx_tuples</span><span class="p">([</span><span class="n">run_idx</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_trajs</span><span class="p">(</span><span class="n">idxs</span><span class="o">=</span><span class="n">idxs</span><span class="p">,</span> <span class="n">traj_sel</span><span class="o">=</span><span class="n">run_sel</span><span class="p">)</span></div>


    <span class="c1">### Settings</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">defined_traj_field_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A list of the settings defined field names all trajectories have in the file.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_feature_shapes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">observable_field_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of the names of the observables that all trajectories have.</span>

<span class="sd">        If this encounters observable fields that don&#39;t occur in all</span>
<span class="sd">        trajectories (inconsistency) raises an inconsistency error.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_trajs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajs</span>
        <span class="n">field_names</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_trajs</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">traj</span><span class="p">[</span><span class="s1">&#39;observables&#39;</span><span class="p">]):</span>
                <span class="n">field_names</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># if any of the field names has not occured for every</span>
        <span class="c1"># trajectory we raise an error</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">field_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="n">n_trajs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;observable field names are inconsistent&quot;</span><span class="p">)</span>

        <span class="c1"># otherwise return the field names for the observables</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">field_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_check_traj_field_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks that every trajectory has the given fields across</span>
<span class="sd">        the entire dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        field_names : list of str</span>
<span class="sd">            The field names to check for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        consistent : bool</span>
<span class="sd">           True if all trajs have the fields, False otherwise</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_trajs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajs</span>
        <span class="n">field_names</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_trajs</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">field_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">traj</span><span class="p">:</span>
                    <span class="n">field_names</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># if any of the field names has not occured for every</span>
        <span class="c1"># trajectory we raise an error</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">field_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="n">n_trajs</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">record_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The record fields for each record group which are selected for inclusion in the truncated records.</span>

<span class="sd">        These are the fields which are considered to be table-ified.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_fields : dict of str : list of str</span>
<span class="sd">            Mapping of record group name to alist of the record group fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">record_fields_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings_grp</span><span class="p">[</span><span class="n">RECORD_FIELDS</span><span class="p">]</span>

        <span class="n">record_fields_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">group_name</span><span class="p">,</span> <span class="n">dset</span> <span class="ow">in</span> <span class="n">record_fields_grp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">record_fields_dict</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dset</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">record_fields_dict</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sparse_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The trajectory fields that are sparse.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">SPARSE_FIELDS</span><span class="p">)][:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">main_rep_idxs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The indices of the atoms included from the full topology in the default &#39;positions&#39; trajectory &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">MAIN_REP_IDXS</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">MAIN_REP_IDXS</span><span class="p">)][:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">alt_reps_idxs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mapping of the names of the alt reps to the indices of the atoms</span>
<span class="sd">        from the topology that they include in their datasets.&quot;&quot;&quot;</span>

        <span class="n">idxs_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">ALT_REPS_IDXS</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">name</span> <span class="p">:</span> <span class="n">ds</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">idxs_grp</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">alt_reps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Names of the alt reps.&quot;&quot;&quot;</span>

        <span class="n">idxs_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">ALT_REPS_IDXS</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">idxs_grp</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">field_feature_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mapping of the names of the trajectory fields to their feature</span>
<span class="sd">        vector shapes.&quot;&quot;&quot;</span>

        <span class="n">shapes_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">FIELD_FEATURE_SHAPES_STR</span><span class="p">)]</span>

        <span class="n">field_paths</span> <span class="o">=</span> <span class="n">_iter_field_paths</span><span class="p">(</span><span class="n">shapes_grp</span><span class="p">)</span>

        <span class="n">shapes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="n">field_paths</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">shapes_grp</span><span class="p">[</span><span class="n">field_path</span><span class="p">][()]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">shapes</span><span class="p">[</span><span class="n">field_path</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shapes</span><span class="p">[</span><span class="n">field_path</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span>

        <span class="k">return</span> <span class="n">shapes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">field_feature_dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mapping of the names of the trajectory fields to their feature</span>
<span class="sd">        vector numpy dtypes.&quot;&quot;&quot;</span>

        <span class="n">dtypes_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">FIELD_FEATURE_DTYPES_STR</span><span class="p">)]</span>

        <span class="n">field_paths</span> <span class="o">=</span> <span class="n">_iter_field_paths</span><span class="p">(</span><span class="n">dtypes_grp</span><span class="p">)</span>

        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="n">field_paths</span><span class="p">:</span>
            <span class="n">dtype_str</span> <span class="o">=</span> <span class="n">dtypes_grp</span><span class="p">[</span><span class="n">field_path</span><span class="p">][()]</span>
            <span class="c1"># if there is &#39;None&#39; flag for the dtype then return None</span>
            <span class="k">if</span> <span class="n">dtype_str</span> <span class="o">==</span> <span class="n">NONE_STR</span><span class="p">:</span>
                <span class="n">dtypes</span><span class="p">[</span><span class="n">field_path</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dtype_obj</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">dtype_str</span><span class="p">)</span>
                <span class="n">dtype_obj</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dtype_obj</span><span class="p">]</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype_obj</span><span class="p">)</span>
                <span class="n">dtypes</span><span class="p">[</span><span class="n">field_path</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype</span>

        <span class="k">return</span> <span class="n">dtypes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">continuations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The continuation relationships in this file.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings_grp</span><span class="p">[</span><span class="n">CONTINUATIONS</span><span class="p">][:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;File metadata (h5py.attrs).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

<div class="viewcode-block" id="WepyHDF5.decision_enum"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.decision_enum">[docs]</a>    <span class="k">def</span> <span class="nf">decision_enum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mapping of decision enumerated names to their integer representations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        decision_enum : dict of str : int</span>
<span class="sd">            Mapping of the decision ID string to the integer representation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        WepyHDF5.decision_value_names : for the reverse mapping</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">enum_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decision_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>
        <span class="n">enum</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">decision_name</span><span class="p">,</span> <span class="n">dset</span> <span class="ow">in</span> <span class="n">enum_grp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">enum</span><span class="p">[</span><span class="n">decision_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[()]</span>

        <span class="k">return</span> <span class="n">enum</span></div>

<div class="viewcode-block" id="WepyHDF5.decision_value_names"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.decision_value_names">[docs]</a>    <span class="k">def</span> <span class="nf">decision_value_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mapping of the integer values for decisions to the decision ID strings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        decision_enum : dict of int : str</span>
<span class="sd">            Mapping of the decision integer to the decision ID string representation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        WepyHDF5.decision_enum : for the reverse mapping</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">enum_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decision_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>
        <span class="n">rev_enum</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">decision_name</span><span class="p">,</span> <span class="n">dset</span> <span class="ow">in</span> <span class="n">enum_grp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[()]</span>
            <span class="n">rev_enum</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">decision_name</span>

        <span class="k">return</span> <span class="n">rev_enum</span></div>

    <span class="c1">### Topology</span>

<div class="viewcode-block" id="WepyHDF5.get_topology"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.get_topology">[docs]</a>    <span class="k">def</span> <span class="nf">get_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alt_rep</span><span class="o">=</span><span class="n">POSITIONS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the JSON topology for a particular represenation of the positions.</span>

<span class="sd">        By default gives the topology for the main &#39;positions&#39; field</span>
<span class="sd">        (when alt_rep &#39;positions&#39;). To get the full topology the file</span>
<span class="sd">        was initialized with set `alt_rep` to `None`. Topologies for</span>
<span class="sd">        alternative representations (subfields of &#39;alt_reps&#39;) can be</span>
<span class="sd">        obtained by passing in the key for that alt_rep. For example,</span>
<span class="sd">        &#39;all_atoms&#39; for the field in alt_reps called &#39;all_atoms&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alt_rep : str</span>
<span class="sd">            The base name of the alternate representation, or &#39;positions&#39;, or None.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology : str</span>
<span class="sd">            The JSON topology string for the representation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span>

        <span class="c1"># if no alternative representation is given we just return the</span>
        <span class="c1"># full topology</span>
        <span class="k">if</span> <span class="n">alt_rep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># otherwise we either give the main representation topology</span>
        <span class="c1"># subset</span>
        <span class="k">elif</span> <span class="n">alt_rep</span> <span class="o">==</span> <span class="n">POSITIONS</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">json_top_subset</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_rep_idxs</span><span class="p">)</span>

        <span class="c1"># or choose one of the alternative representations</span>
        <span class="k">elif</span> <span class="n">alt_rep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt_reps_idxs</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">json_top_subset</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt_reps_idxs</span><span class="p">[</span><span class="n">alt_rep</span><span class="p">])</span>

        <span class="c1"># and raise an error if the given alternative representation</span>
        <span class="c1"># is not given</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alt_rep </span><span class="si">{}</span><span class="s2"> not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alt_rep</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">top</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">topology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The topology for the full simulated system.</span>

<span class="sd">        May not be the main representation in the POSITIONS field; for</span>
<span class="sd">        that use the `get_topology` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology : str</span>
<span class="sd">            The JSON topology string for the full representation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="n">TOPOLOGY</span><span class="p">][()]</span>


<div class="viewcode-block" id="WepyHDF5.get_mdtraj_topology"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.get_mdtraj_topology">[docs]</a>    <span class="k">def</span> <span class="nf">get_mdtraj_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alt_rep</span><span class="o">=</span><span class="n">POSITIONS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an mdtraj.Topology object for a system representation.</span>

<span class="sd">        By default gives the topology for the main &#39;positions&#39; field</span>
<span class="sd">        (when alt_rep &#39;positions&#39;). To get the full topology the file</span>
<span class="sd">        was initialized with set `alt_rep` to `None`. Topologies for</span>
<span class="sd">        alternative representations (subfields of &#39;alt_reps&#39;) can be</span>
<span class="sd">        obtained by passing in the key for that alt_rep. For example,</span>
<span class="sd">        &#39;all_atoms&#39; for the field in alt_reps called &#39;all_atoms&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alt_rep : str</span>
<span class="sd">            The base name of the alternate representation, or &#39;positions&#39;, or None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology : str</span>
<span class="sd">            The JSON topology string for the full representation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">json_top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_topology</span><span class="p">(</span><span class="n">alt_rep</span><span class="o">=</span><span class="n">alt_rep</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">json_to_mdtraj_topology</span><span class="p">(</span><span class="n">json_top</span><span class="p">)</span></div>

    <span class="c1">## Initial walkers</span>

<div class="viewcode-block" id="WepyHDF5.initial_walker_fields"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.initial_walker_fields">[docs]</a>    <span class="k">def</span> <span class="nf">initial_walker_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">walker_idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get fields from the initial walkers of the simulation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">            Run to get initial walkers for.</span>

<span class="sd">        fields : list of str</span>
<span class="sd">            Names of the fields you want to retrieve.</span>

<span class="sd">        walker_idxs : None or list of int</span>
<span class="sd">            If None returns all of the walkers fields, otherwise a</span>
<span class="sd">            list of ints that are a selection from those walkers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        walker_fields : dict of str : array of shape</span>
<span class="sd">            Dictionary mapping fields to the values for all</span>
<span class="sd">            walkers. Frames will be either in counting order if no</span>
<span class="sd">            indices were requested or the order of the walker indices</span>
<span class="sd">            as given.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set the walker indices if not specified</span>
        <span class="k">if</span> <span class="n">walker_idxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">walker_idxs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_init_walkers</span><span class="p">(</span><span class="n">run_idx</span><span class="p">))</span>

        <span class="n">init_walker_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span> <span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">}</span>

        <span class="c1"># for each walker go through and add the selected fields</span>
        <span class="k">for</span> <span class="n">walker_idx</span> <span class="ow">in</span> <span class="n">walker_idxs</span><span class="p">:</span>
            <span class="n">init_walker_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_walkers_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)[</span><span class="nb">str</span><span class="p">(</span><span class="n">walker_idx</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                <span class="c1"># we remove the first dimension because we just want</span>
                <span class="c1"># them as a single frame</span>
                <span class="n">init_walker_fields</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">init_walker_grp</span><span class="p">[</span><span class="n">field</span><span class="p">][:][</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># convert the field values to arrays</span>
        <span class="n">init_walker_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">init_walker_fields</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">return</span> <span class="n">init_walker_fields</span></div>

<div class="viewcode-block" id="WepyHDF5.initial_walkers_to_mdtraj"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.initial_walkers_to_mdtraj">[docs]</a>    <span class="k">def</span> <span class="nf">initial_walkers_to_mdtraj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">walker_idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alt_rep</span><span class="o">=</span><span class="n">POSITIONS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate an mdtraj Trajectory from a trace of frames from the runs.</span>

<span class="sd">        Uses the default fields for positions (unless an alternate</span>
<span class="sd">        representation is specified) and box vectors which are assumed</span>
<span class="sd">        to be present in the trajectory fields.</span>

<span class="sd">        The time value for the mdtraj trajectory is set to the cycle</span>
<span class="sd">        indices for each trace frame.</span>

<span class="sd">        This is useful for converting WepyHDF5 data to common</span>
<span class="sd">        molecular dynamics data formats accessible through the mdtraj</span>
<span class="sd">        library.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">            Run to get initial walkers for.</span>

<span class="sd">        fields : list of str</span>
<span class="sd">            Names of the fields you want to retrieve.</span>

<span class="sd">        walker_idxs : None or list of int</span>
<span class="sd">            If None returns all of the walkers fields, otherwise a</span>
<span class="sd">            list of ints that are a selection from those walkers.</span>

<span class="sd">        alt_rep : None or str</span>
<span class="sd">            If None uses default &#39;positions&#39; representation otherwise</span>
<span class="sd">            chooses the representation from the &#39;alt_reps&#39; compound field.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        traj : mdtraj.Trajectory</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rep_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_choose_rep_path</span><span class="p">(</span><span class="n">alt_rep</span><span class="p">)</span>

        <span class="n">init_walker_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_walker_fields</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="p">[</span><span class="n">rep_path</span><span class="p">,</span> <span class="n">BOX_VECTORS</span><span class="p">],</span>
                                                        <span class="n">walker_idxs</span><span class="o">=</span><span class="n">walker_idxs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_fields_to_mdtraj</span><span class="p">(</span><span class="n">init_walker_fields</span><span class="p">,</span> <span class="n">alt_rep</span><span class="o">=</span><span class="n">alt_rep</span><span class="p">)</span></div>


    <span class="c1">### Counts and Indexing</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of atoms in the full topology representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">N_ATOMS</span><span class="p">)][()]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of spatial dimensions in the positions and alt_reps trajectory fields.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SETTINGS</span><span class="p">,</span> <span class="n">N_DIMS_STR</span><span class="p">)][()]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_runs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of runs in the file.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="n">RUNS</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_trajs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The total number of trajectories in the entire file.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_traj_idx_tuples</span><span class="p">()))</span>

<div class="viewcode-block" id="WepyHDF5.num_init_walkers"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.num_init_walkers">[docs]</a>    <span class="k">def</span> <span class="nf">num_init_walkers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of initial walkers for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_walkers : int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_walkers_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">))</span></div>

<div class="viewcode-block" id="WepyHDF5.num_walkers"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.num_walkers">[docs]</a>    <span class="k">def</span> <span class="nf">num_walkers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">cycle_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the number of walkers at a given cycle in a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        cycle_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_walkers : int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: currently we do not have a well-defined mechanism for</span>
        <span class="c1"># actually storing variable number of walkers in the</span>
        <span class="c1"># trajectory data so just return the number of trajectories</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_trajs</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.num_run_trajs"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.num_run_trajs">[docs]</a>    <span class="k">def</span> <span class="nf">num_run_trajs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of trajectories in a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_trajs : int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">)])</span></div>

<div class="viewcode-block" id="WepyHDF5.num_run_cycles"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.num_run_cycles">[docs]</a>    <span class="k">def</span> <span class="nf">num_run_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of cycles in a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_cycles : int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_traj_frames</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.num_traj_frames"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.num_traj_frames">[docs]</a>    <span class="k">def</span> <span class="nf">num_traj_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of frames in a given trajectory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_frames : int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)[</span><span class="n">POSITIONS</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">run_idxs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The indices of the runs in the file.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="n">RUNS</span><span class="p">])))</span>

<div class="viewcode-block" id="WepyHDF5.run_traj_idxs"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run_traj_idxs">[docs]</a>    <span class="k">def</span> <span class="nf">run_traj_idxs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The indices of trajectories in a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        traj_idxs : list of int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">)])))</span></div>

<div class="viewcode-block" id="WepyHDF5.run_traj_idx_tuples"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run_traj_idx_tuples">[docs]</a>    <span class="k">def</span> <span class="nf">run_traj_idx_tuples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">runs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get identifier tuples (run_idx, traj_idx) for all trajectories in</span>
<span class="sd">        all runs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        runs : list of int, optional</span>
<span class="sd">            If not None, a list of run indices to restrict to.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        run_traj_tuples : list of tuple of int</span>
<span class="sd">            A listing of all trajectories by their identifying tuple</span>
<span class="sd">            of (run_idx, traj_idx).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">runs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">run_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_idxs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">run_idxs</span> <span class="o">=</span> <span class="n">runs</span>
        <span class="k">for</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="n">run_idxs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">traj_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_traj_idxs</span><span class="p">(</span><span class="n">run_idx</span><span class="p">):</span>
                <span class="n">tups</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">tups</span></div>

<div class="viewcode-block" id="WepyHDF5.get_traj_field_cycle_idxs"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.get_traj_field_cycle_idxs">[docs]</a>    <span class="k">def</span> <span class="nf">get_traj_field_cycle_idxs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the cycle indices for a sparse trajectory field.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>
<span class="sd">        field_path : str</span>
<span class="sd">            Name of the trajectory field</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cycle_idxs : arraylike of int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">traj_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="n">traj_path</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;key for field </span><span class="si">{}</span><span class="s2"> not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field_path</span><span class="p">))</span>

        <span class="c1"># if the field is not sparse just return the cycle indices for</span>
        <span class="c1"># that run</span>
        <span class="k">if</span> <span class="n">field_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_fields</span><span class="p">:</span>
            <span class="n">cycle_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_run_cycles</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cycle_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="n">traj_path</span><span class="p">][</span><span class="n">field_path</span><span class="p">][</span><span class="n">SPARSE_IDXS</span><span class="p">][:]</span>

        <span class="k">return</span> <span class="n">cycle_idxs</span></div>

<div class="viewcode-block" id="WepyHDF5.next_run_idx"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.next_run_idx">[docs]</a>    <span class="k">def</span> <span class="nf">next_run_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The index of the next run if it were to be added.</span>

<span class="sd">        Because runs are named as the integer value of the order they</span>
<span class="sd">        were added this gives the index of the next run that would be</span>
<span class="sd">        added.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        next_run_idx : int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_runs</span></div>

<div class="viewcode-block" id="WepyHDF5.next_run_traj_idx"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.next_run_traj_idx">[docs]</a>    <span class="k">def</span> <span class="nf">next_run_traj_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The index of the next trajectory for this run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        next_traj_idx : int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_trajs</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span></div>

    <span class="c1">### Aggregation</span>

<div class="viewcode-block" id="WepyHDF5.is_run_contig"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.is_run_contig">[docs]</a>    <span class="k">def</span> <span class="nf">is_run_contig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method checks that if a given list of run indices is a valid</span>
<span class="sd">        contig or not.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that would make up the contig in order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_contig : bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">run_idx_continuations</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">run_idxs</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">run_idxs</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span>
                            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="c1">#gets the contigs array</span>
        <span class="n">continuations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings_grp</span><span class="p">[</span><span class="n">CONTINUATIONS</span><span class="p">][:]</span>

        <span class="c1"># checks if sub contigs are in contigs list or not.</span>
        <span class="k">for</span> <span class="n">run_continuous</span> <span class="ow">in</span> <span class="n">run_idx_continuations</span><span class="p">:</span>
            <span class="n">contig</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">continuous</span> <span class="ow">in</span> <span class="n">continuations</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">run_continuous</span><span class="p">,</span> <span class="n">continuous</span><span class="p">):</span>
                    <span class="n">contig</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">contig</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="WepyHDF5.clone"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clone the header information of this file into another file.</span>

<span class="sd">        Clones this WepyHDF5 file without any of the actual runs and run</span>
<span class="sd">        data. This includes the topology, units, sparse_fields,</span>
<span class="sd">        feature shapes and dtypes, alt_reps, and main representation</span>
<span class="sd">        information.</span>

<span class="sd">        This method will flush the buffers for this file.</span>

<span class="sd">        Does not preserve metadata pertaining to inter-run</span>
<span class="sd">        relationships like continuations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            File path to save the new file.</span>
<span class="sd">        mode : str</span>
<span class="sd">            The mode to open the new file with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_file : h5py.File</span>
<span class="sd">            The handle to the new file. It will be closed.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;w-&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="s2">&quot;must be opened in a file creation mode&quot;</span>

        <span class="c1"># we manually construct an HDF5 and copy the groups over</span>
        <span class="n">new_h5</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">libver</span><span class="o">=</span><span class="n">H5PY_LIBVER</span><span class="p">)</span>

        <span class="n">new_h5</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="n">RUNS</span><span class="p">)</span>

        <span class="c1"># flush the datasets buffers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">new_h5</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="c1"># copy the existing datasets to the new one</span>
        <span class="n">h5py</span><span class="o">.</span><span class="n">h5o</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">TOPOLOGY</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">new_h5</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">TOPOLOGY</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="n">h5py</span><span class="o">.</span><span class="n">h5o</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">UNITS</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">new_h5</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">UNITS</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="n">h5py</span><span class="o">.</span><span class="n">h5o</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">SETTINGS</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">new_h5</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">SETTINGS</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

        <span class="c1"># now make a WepyHDF5 object in &quot;expert_mode&quot; which means it</span>
        <span class="c1"># is just empy and we construct it manually, &quot;surgically&quot; as I</span>
        <span class="c1"># like to call it</span>
        <span class="n">new_wepy_h5</span> <span class="o">=</span> <span class="n">WepyHDF5</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">expert_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># perform the surgery:</span>

        <span class="c1"># attach the h5py.File</span>
        <span class="n">new_wepy_h5</span><span class="o">.</span><span class="n">_h5</span> <span class="o">=</span> <span class="n">new_h5</span>
        <span class="c1"># set the wepy mode to read-write since the creation flags</span>
        <span class="c1"># were already used in construction of the h5py.File object</span>
        <span class="n">new_wepy_h5</span><span class="o">.</span><span class="n">_wepy_mode</span> <span class="o">=</span> <span class="s1">&#39;r+&#39;</span>
        <span class="n">new_wepy_h5</span><span class="o">.</span><span class="n">_h5py_mode</span> <span class="o">=</span> <span class="s1">&#39;r+&#39;</span>

        <span class="c1"># for the settings we need to get rid of the data for interun</span>
        <span class="c1"># relationships like the continuations, so we reinitialize the</span>
        <span class="c1"># continuations for the new file</span>
        <span class="n">new_wepy_h5</span><span class="o">.</span><span class="n">_init_continuations</span><span class="p">()</span>

        <span class="c1"># close the h5py.File and set the attribute to closed</span>
        <span class="n">new_wepy_h5</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">new_wepy_h5</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">True</span>


        <span class="c1"># return the runless WepyHDF5 object</span>
        <span class="k">return</span> <span class="n">new_wepy_h5</span></div>


<div class="viewcode-block" id="WepyHDF5.link_run"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.link_run">[docs]</a>    <span class="k">def</span> <span class="nf">link_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">continue_run</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a run from another file to this one as an HDF5 external</span>
<span class="sd">        link.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath : str</span>
<span class="sd">            File path to the HDF5 file that the run is on.</span>
<span class="sd">        run_idx : int</span>
<span class="sd">            The run index from the target file you want to link.</span>
<span class="sd">        continue_run : int, optional</span>
<span class="sd">            The run from the linking WepyHDF5 file you want the target</span>
<span class="sd">            linked run to continue.</span>

<span class="sd">        kwargs : dict</span>
<span class="sd">            Adds metadata (h5py.attrs) to the linked run.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        linked_run_idx : int</span>
<span class="sd">            The index of the linked run in the linking file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># link to the external run</span>
        <span class="n">ext_run_link</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">ExternalLink</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">))</span>

        <span class="c1"># the run index in this file, as determined by the counter</span>
        <span class="n">here_run_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_run_idx</span><span class="p">()</span>

        <span class="c1"># set the local run as the external link to the other run</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">here_run_idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ext_run_link</span>

        <span class="c1"># run the initialization routines for adding a run</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_run_init</span><span class="p">(</span><span class="n">here_run_idx</span><span class="p">,</span> <span class="n">continue_run</span><span class="o">=</span><span class="n">continue_run</span><span class="p">)</span>

        <span class="n">run_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">here_run_idx</span><span class="p">)]</span>

        <span class="c1"># add metadata if given</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">RUN_IDX</span><span class="p">:</span>
                <span class="n">run_grp</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;run_idx metadata is set by wepy and cannot be used&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">here_run_idx</span></div>

<div class="viewcode-block" id="WepyHDF5.link_file_runs"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.link_file_runs">[docs]</a>    <span class="k">def</span> <span class="nf">link_file_runs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wepy_h5_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Link all runs from another WepyHDF5 file.</span>

<span class="sd">        This preserves continuations within that file. This will open</span>
<span class="sd">        the file if not already opened.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wepy_h5_path : str</span>
<span class="sd">            Filepath to the file you want to link runs from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_run_idxs : list of int</span>
<span class="sd">            The new run idxs from the linking file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">wepy_h5</span> <span class="o">=</span> <span class="n">WepyHDF5</span><span class="p">(</span><span class="n">wepy_h5_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">wepy_h5</span><span class="p">:</span>
            <span class="n">ext_run_idxs</span> <span class="o">=</span> <span class="n">wepy_h5</span><span class="o">.</span><span class="n">run_idxs</span>
            <span class="n">continuations</span> <span class="o">=</span> <span class="n">wepy_h5</span><span class="o">.</span><span class="n">continuations</span>

        <span class="c1"># add the runs</span>
        <span class="n">new_run_idxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ext_run_idx</span> <span class="ow">in</span> <span class="n">ext_run_idxs</span><span class="p">:</span>

            <span class="c1"># link the next run, and get its new run index</span>
            <span class="n">new_run_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">link_run</span><span class="p">(</span><span class="n">wepy_h5_path</span><span class="p">,</span> <span class="n">ext_run_idx</span><span class="p">)</span>

            <span class="c1"># save that run idx</span>
            <span class="n">new_run_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_run_idx</span><span class="p">)</span>

        <span class="c1"># copy the continuations over translating the run idxs,</span>
        <span class="c1"># for each continuation in the other files continuations</span>
        <span class="k">for</span> <span class="n">continuation</span> <span class="ow">in</span> <span class="n">continuations</span><span class="p">:</span>

            <span class="c1"># translate each run index from the external file</span>
            <span class="c1"># continuations to the run idxs they were just assigned in</span>
            <span class="c1"># this file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_continuation</span><span class="p">(</span><span class="n">new_run_idxs</span><span class="p">[</span><span class="n">continuation</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                  <span class="n">new_run_idxs</span><span class="p">[</span><span class="n">continuation</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">new_run_idxs</span></div>

<div class="viewcode-block" id="WepyHDF5.extract_run"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.extract_run">[docs]</a>    <span class="k">def</span> <span class="nf">extract_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span>
                 <span class="n">continue_run</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">run_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a run from another file to this one by copying it and</span>
<span class="sd">        truncating it if necessary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath : str</span>
<span class="sd">            File path to the HDF5 file that the run is on.</span>
<span class="sd">        run_idx : int</span>
<span class="sd">            The run index from the target file you want to link.</span>
<span class="sd">        continue_run : int, optional</span>
<span class="sd">            The run from the linking WepyHDF5 file you want the target</span>
<span class="sd">            linked run to continue.</span>
<span class="sd">        run_slice : </span>

<span class="sd">        kwargs : dict</span>
<span class="sd">            Adds metadata (h5py.attrs) to the linked run.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        linked_run_idx : int</span>
<span class="sd">            The index of the linked run in the linking file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># close ourselves if not already done, so we can write using</span>
        <span class="c1"># the lower level API</span>
        <span class="n">was_open</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">was_open</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># do the copying</span>

        <span class="c1"># open the other file and get the runs in it and the</span>
        <span class="c1"># continuations it has</span>
        <span class="n">wepy_h5</span> <span class="o">=</span> <span class="n">WepyHDF5</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>



        <span class="k">with</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># normalize our HDF5s path</span>
            <span class="n">self_path</span> <span class="o">=</span> <span class="n">osp</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="c1"># the run index in this file, as determined by the counter</span>
            <span class="n">here_run_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_run_idx</span><span class="p">()</span>

        <span class="c1"># get the group name for the new run in this HDF5</span>
        <span class="n">target_grp_path</span> <span class="o">=</span> <span class="s2">&quot;/runs/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">here_run_idx</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">wepy_h5</span><span class="p">:</span>
            <span class="c1"># link the next run, and get its new run index</span>
            <span class="n">new_h5</span> <span class="o">=</span> <span class="n">wepy_h5</span><span class="o">.</span><span class="n">copy_run_slice</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">self_path</span><span class="p">,</span>
                                      <span class="n">target_grp_path</span><span class="p">,</span>
                                      <span class="n">run_slice</span><span class="o">=</span><span class="n">run_slice</span><span class="p">,</span>
                                      <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">)</span>

            <span class="c1"># close it since we are done</span>
            <span class="n">new_h5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


        <span class="k">with</span> <span class="bp">self</span><span class="p">:</span>

            <span class="c1"># run the initialization routines for adding a run, just</span>
            <span class="c1"># sets some metadata</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_run_init</span><span class="p">(</span><span class="n">here_run_idx</span><span class="p">,</span> <span class="n">continue_run</span><span class="o">=</span><span class="n">continue_run</span><span class="p">)</span>

            <span class="n">run_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">here_run_idx</span><span class="p">)]</span>

            <span class="c1"># add metadata if given</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">RUN_IDX</span><span class="p">:</span>
                    <span class="n">run_grp</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;run_idx metadata is set by wepy and cannot be used&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">was_open</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">here_run_idx</span></div>


<div class="viewcode-block" id="WepyHDF5.extract_file_runs"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.extract_file_runs">[docs]</a>    <span class="k">def</span> <span class="nf">extract_file_runs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wepy_h5_path</span><span class="p">,</span>
                          <span class="n">run_slices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract (copying and truncating appropriately) all runs from</span>
<span class="sd">        another WepyHDF5 file.</span>

<span class="sd">        This preserves continuations within that file. This will open</span>
<span class="sd">        the file if not already opened.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wepy_h5_path : str</span>
<span class="sd">            Filepath to the file you want to link runs from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_run_idxs : list of int</span>
<span class="sd">            The new run idxs from the linking file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">run_slices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">run_slices</span> <span class="o">=</span> <span class="p">{}</span>


        <span class="c1"># open the other file and get the runs in it and the</span>
        <span class="c1"># continuations it has</span>
        <span class="n">wepy_h5</span> <span class="o">=</span> <span class="n">WepyHDF5</span><span class="p">(</span><span class="n">wepy_h5_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">wepy_h5</span><span class="p">:</span>
            <span class="c1"># the run idx in the external file</span>
            <span class="n">ext_run_idxs</span> <span class="o">=</span> <span class="n">wepy_h5</span><span class="o">.</span><span class="n">run_idxs</span>
            <span class="n">continuations</span> <span class="o">=</span> <span class="n">wepy_h5</span><span class="o">.</span><span class="n">continuations</span>

        <span class="c1"># then for each run in it copy them to this file</span>
        <span class="n">new_run_idxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ext_run_idx</span> <span class="ow">in</span> <span class="n">ext_run_idxs</span><span class="p">:</span>

            <span class="c1"># get the run_slice spec for the run in the other file</span>
            <span class="n">run_slice</span> <span class="o">=</span> <span class="n">run_slices</span><span class="p">[</span><span class="n">ext_run_idx</span><span class="p">]</span>

            <span class="c1"># get the index this run should be when it is added</span>
            <span class="n">new_run_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_run</span><span class="p">(</span><span class="n">wepy_h5_path</span><span class="p">,</span> <span class="n">ext_run_idx</span><span class="p">,</span>
                                           <span class="n">run_slice</span><span class="o">=</span><span class="n">run_slice</span><span class="p">)</span>

            <span class="c1"># save that run idx</span>
            <span class="n">new_run_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_run_idx</span><span class="p">)</span>

        <span class="n">was_closed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
            <span class="n">was_closed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># copy the continuations over translating the run idxs,</span>
        <span class="c1"># for each continuation in the other files continuations</span>
        <span class="k">for</span> <span class="n">continuation</span> <span class="ow">in</span> <span class="n">continuations</span><span class="p">:</span>

            <span class="c1"># translate each run index from the external file</span>
            <span class="c1"># continuations to the run idxs they were just assigned in</span>
            <span class="c1"># this file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_continuation</span><span class="p">(</span><span class="n">new_run_idxs</span><span class="p">[</span><span class="n">continuation</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                  <span class="n">new_run_idxs</span><span class="p">[</span><span class="n">continuation</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="k">if</span> <span class="n">was_closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">new_run_idxs</span></div>


<div class="viewcode-block" id="WepyHDF5.join"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.join">[docs]</a>    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_h5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given another WepyHDF5 file object does a left join on this</span>
<span class="sd">        file, renumbering the runs starting from this file.</span>

<span class="sd">        This function uses the H5O function for copying. Data will be</span>
<span class="sd">        copied not linked.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other_h5 : h5py.File</span>
<span class="sd">            File handle to the file you want to join to this one.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">other_h5</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="n">h5</span><span class="o">.</span><span class="n">run_idxs</span><span class="p">:</span>
                <span class="c1"># the other run group handle</span>
                <span class="n">other_run</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>
                <span class="c1"># copy this run to this file in the next run_idx group</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">other_run</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_run_idx</span><span class="p">()))</span></div>


    <span class="c1">### initialization and data generation</span>

<div class="viewcode-block" id="WepyHDF5.add_metadata"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.add_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">add_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add metadata for the whole file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">        value : h5py value</span>
<span class="sd">            h5py valid metadata value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="WepyHDF5.init_record_fields"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_record_fields">[docs]</a>    <span class="k">def</span> <span class="nf">init_record_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span> <span class="n">record_fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the settings record fields for a record group in the</span>
<span class="sd">        settings group.</span>

<span class="sd">        Save which records are to be considered from a run record group&#39;s</span>
<span class="sd">        datasets to be in the table like representation. This exists</span>
<span class="sd">        to allow there to large and small datasets for records to be</span>
<span class="sd">        stored together but allow for a more compact single table like</span>
<span class="sd">        representation to be produced for serialization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            Name of the record group you want to set this for.</span>
<span class="sd">        record_fields : list of str</span>
<span class="sd">            Names of the fields you want to set as record fields.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">record_fields_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings_grp</span><span class="p">[</span><span class="n">RECORD_FIELDS</span><span class="p">]</span>

        <span class="c1"># make a dataset for the sparse fields allowed.  this requires</span>
        <span class="c1"># a &#39;special&#39; datatype for variable length strings. This is</span>
        <span class="c1"># supported by HDF5 but not numpy.</span>
        <span class="n">vlen_str_dt</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">special_dtype</span><span class="p">(</span><span class="n">vlen</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

        <span class="c1"># create the dataset with the strings of the fields which are records</span>
        <span class="n">record_group_fields_ds</span> <span class="o">=</span> <span class="n">record_fields_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">run_record_key</span><span class="p">,</span>
                                                             <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">record_fields</span><span class="p">),),</span>
                                                                  <span class="n">dtype</span><span class="o">=</span><span class="n">vlen_str_dt</span><span class="p">,</span>
                                                                  <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,))</span>

        <span class="c1"># set the flags</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">record_field</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">record_fields</span><span class="p">):</span>
            <span class="n">record_group_fields_ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_field</span></div>

<div class="viewcode-block" id="WepyHDF5.init_resampling_record_fields"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_resampling_record_fields">[docs]</a>    <span class="k">def</span> <span class="nf">init_resampling_record_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resampler</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the record fields for this record group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resampler : object implementing the Resampler interface</span>
<span class="sd">            The resampler which contains the data for which record fields to set.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_record_fields</span><span class="p">(</span><span class="n">RESAMPLING</span><span class="p">,</span> <span class="n">resampler</span><span class="o">.</span><span class="n">resampling_record_field_names</span><span class="p">())</span></div>

<div class="viewcode-block" id="WepyHDF5.init_resampler_record_fields"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_resampler_record_fields">[docs]</a>    <span class="k">def</span> <span class="nf">init_resampler_record_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resampler</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the record fields for this record group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resampler : object implementing the Resampler interface</span>
<span class="sd">            The resampler which contains the data for which record fields to set.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_record_fields</span><span class="p">(</span><span class="n">RESAMPLER</span><span class="p">,</span> <span class="n">resampler</span><span class="o">.</span><span class="n">resampler_record_field_names</span><span class="p">())</span></div>

<div class="viewcode-block" id="WepyHDF5.init_bc_record_fields"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_bc_record_fields">[docs]</a>    <span class="k">def</span> <span class="nf">init_bc_record_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the record fields for this record group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bc : object implementing the BoundaryConditions interface</span>
<span class="sd">            The boundary conditions object which contains the data for which record fields to set.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_record_fields</span><span class="p">(</span><span class="n">BC</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">bc_record_field_names</span><span class="p">())</span></div>

<div class="viewcode-block" id="WepyHDF5.init_warping_record_fields"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_warping_record_fields">[docs]</a>    <span class="k">def</span> <span class="nf">init_warping_record_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the record fields for this record group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bc : object implementing the BoundaryConditions interface</span>
<span class="sd">            The boundary conditions object which contains the data for which record fields to set.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_record_fields</span><span class="p">(</span><span class="n">WARPING</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">warping_record_field_names</span><span class="p">())</span></div>

<div class="viewcode-block" id="WepyHDF5.init_progress_record_fields"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_progress_record_fields">[docs]</a>    <span class="k">def</span> <span class="nf">init_progress_record_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the record fields for this record group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bc : object implementing the BoundaryConditions interface</span>
<span class="sd">            The boundary conditions object which contains the data for which record fields to set.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_record_fields</span><span class="p">(</span><span class="n">PROGRESS</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">progress_record_field_names</span><span class="p">())</span></div>

<div class="viewcode-block" id="WepyHDF5.add_continuation"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.add_continuation">[docs]</a>    <span class="k">def</span> <span class="nf">add_continuation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">continuation_run</span><span class="p">,</span> <span class="n">base_run</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a continuation between runs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        continuation_run : int</span>
<span class="sd">            The run index of the run that will be continuing another</span>
<span class="sd">        base_run : int</span>
<span class="sd">            The run that is being continued.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">continuations_dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings_grp</span><span class="p">[</span><span class="n">CONTINUATIONS</span><span class="p">]</span>
        <span class="n">continuations_dset</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">continuations_dset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">continuations_dset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],))</span>
        <span class="n">continuations_dset</span><span class="p">[</span><span class="n">continuations_dset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">continuation_run</span><span class="p">,</span> <span class="n">base_run</span><span class="p">])</span></div>

<div class="viewcode-block" id="WepyHDF5.new_run"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.new_run">[docs]</a>    <span class="k">def</span> <span class="nf">new_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_walkers</span><span class="p">,</span> <span class="n">continue_run</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        init_walkers : list of objects implementing the Walker interface</span>
<span class="sd">            The walkers that will be the start of this run.</span>
<span class="sd">        continue_run : int, optional</span>
<span class="sd">            If this run is a continuation of another set which one it is continuing.</span>

<span class="sd">        kwargs : dict</span>
<span class="sd">            Metadata to set for the run.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        run_grp : h5py.Group</span>
<span class="sd">            The group of the newly created run.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check to see if the continue_run is actually in this file</span>
        <span class="k">if</span> <span class="n">continue_run</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">continue_run</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_idxs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The continue_run idx given, </span><span class="si">{}</span><span class="s2">, is not present in this file&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">continue_run</span><span class="p">))</span>

        <span class="c1"># get the index for this run</span>
        <span class="n">new_run_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_run_idx</span><span class="p">()</span>

        <span class="c1"># create a new group named the next integer in the counter</span>
        <span class="n">run_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">new_run_idx</span><span class="p">))</span>


        <span class="c1"># set the initial walkers group</span>
        <span class="n">init_walkers_grp</span> <span class="o">=</span> <span class="n">run_grp</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">INIT_WALKERS</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_init_walkers</span><span class="p">(</span><span class="n">init_walkers_grp</span><span class="p">,</span> <span class="n">init_walkers</span><span class="p">)</span>

        <span class="c1"># initialize the walkers group</span>
        <span class="n">traj_grp</span> <span class="o">=</span> <span class="n">run_grp</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">TRAJECTORIES</span><span class="p">)</span>


        <span class="c1"># run the initialization routines for adding a run</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_run_init</span><span class="p">(</span><span class="n">new_run_idx</span><span class="p">,</span> <span class="n">continue_run</span><span class="o">=</span><span class="n">continue_run</span><span class="p">)</span>


        <span class="c1"># add metadata if given</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">RUN_IDX</span><span class="p">:</span>
                <span class="n">run_grp</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;run_idx metadata is set by wepy and cannot be used&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">run_grp</span></div>

    <span class="c1"># application level methods for setting the fields for run record</span>
    <span class="c1"># groups given the objects themselves</span>
<div class="viewcode-block" id="WepyHDF5.init_run_resampling"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_run_resampling">[docs]</a>    <span class="k">def</span> <span class="nf">init_run_resampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">resampler</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize data for resampling records.</span>

<span class="sd">        Initialized the run record group as well as settings for the</span>
<span class="sd">        fields.</span>

<span class="sd">        This method also creates the decision group for the run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        resampler : object implementing the Resampler interface</span>
<span class="sd">            The resampler which contains the data for which record fields to set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set the enumeration of the decisions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_run_resampling_decision</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">resampler</span><span class="p">)</span>

        <span class="c1"># set the data fields that can be used for table like records</span>
        <span class="n">resampler</span><span class="o">.</span><span class="n">resampler_record_field_names</span><span class="p">()</span>
        <span class="n">resampler</span><span class="o">.</span><span class="n">resampling_record_field_names</span><span class="p">()</span>

        <span class="c1"># then make the records group</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="n">resampler</span><span class="o">.</span><span class="n">resampling_fields</span><span class="p">()</span>
        <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_run_record_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">RESAMPLING</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grp</span></div>

<div class="viewcode-block" id="WepyHDF5.init_run_resampling_decision"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_run_resampling_decision">[docs]</a>    <span class="k">def</span> <span class="nf">init_run_resampling_decision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">resampler</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the decision group for the run resampling records.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        resampler : object implementing the Resampler interface</span>
<span class="sd">            The resampler which contains the data for which record fields to set.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">init_run_fields_resampling_decision</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">resampler</span><span class="o">.</span><span class="n">DECISION</span><span class="o">.</span><span class="n">enum_dict_by_name</span><span class="p">())</span></div>

<div class="viewcode-block" id="WepyHDF5.init_run_resampler"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_run_resampler">[docs]</a>    <span class="k">def</span> <span class="nf">init_run_resampler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">resampler</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize data for this record group in a run.</span>

<span class="sd">        Initialized the run record group as well as settings for the</span>
<span class="sd">        fields.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        resampler : object implementing the Resampler interface</span>
<span class="sd">            The resampler which contains the data for which record fields to set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="n">resampler</span><span class="o">.</span><span class="n">resampler_fields</span><span class="p">()</span>

        <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_run_record_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">RESAMPLER</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grp</span></div>

<div class="viewcode-block" id="WepyHDF5.init_run_warping"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_run_warping">[docs]</a>    <span class="k">def</span> <span class="nf">init_run_warping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize data for this record group in a run.</span>

<span class="sd">        Initialized the run record group as well as settings for the</span>
<span class="sd">        fields.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        bc : object implementing the BoundaryConditions interface</span>
<span class="sd">            The boundary conditions object which contains the data for which record fields to set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">warping_fields</span><span class="p">()</span>
        <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_run_record_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">WARPING</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grp</span></div>

<div class="viewcode-block" id="WepyHDF5.init_run_progress"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_run_progress">[docs]</a>    <span class="k">def</span> <span class="nf">init_run_progress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize data for this record group in a run.</span>

<span class="sd">        Initialized the run record group as well as settings for the</span>
<span class="sd">        fields.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        bc : object implementing the BoundaryConditions interface</span>
<span class="sd">            The boundary conditions object which contains the data for which record fields to set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">progress_fields</span><span class="p">()</span>

        <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_run_record_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">PROGRESS</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grp</span></div>

<div class="viewcode-block" id="WepyHDF5.init_run_bc"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_run_bc">[docs]</a>    <span class="k">def</span> <span class="nf">init_run_bc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize data for this record group in a run.</span>

<span class="sd">        Initialized the run record group as well as settings for the</span>
<span class="sd">        fields.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        bc : object implementing the BoundaryConditions interface</span>
<span class="sd">            The boundary conditions object which contains the data for which record fields to set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">bc_fields</span><span class="p">()</span>

        <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_run_record_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">BC</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grp</span></div>

    <span class="c1"># application level methods for initializing the run records</span>
    <span class="c1"># groups with just the fields and without the objects</span>
<div class="viewcode-block" id="WepyHDF5.init_run_fields_resampling"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_run_fields_resampling">[docs]</a>    <span class="k">def</span> <span class="nf">init_run_fields_resampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize this record group fields datasets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        fields : list of str</span>
<span class="sd">            Names of the fields to initialize</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_run_record_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">RESAMPLING</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grp</span></div>

<div class="viewcode-block" id="WepyHDF5.init_run_fields_resampling_decision"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_run_fields_resampling_decision">[docs]</a>    <span class="k">def</span> <span class="nf">init_run_fields_resampling_decision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">decision_enum_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the decision group for this run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        decision_enum_dict : dict of str : int</span>
<span class="sd">            Mapping of decision ID strings to integer representation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">decision_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">DECISION</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">decision_enum_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">decision_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="WepyHDF5.init_run_fields_resampler"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_run_fields_resampler">[docs]</a>    <span class="k">def</span> <span class="nf">init_run_fields_resampler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize this record group fields datasets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        fields : list of str</span>
<span class="sd">            Names of the fields to initialize</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_run_record_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">RESAMPLER</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grp</span></div>

<div class="viewcode-block" id="WepyHDF5.init_run_fields_warping"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_run_fields_warping">[docs]</a>    <span class="k">def</span> <span class="nf">init_run_fields_warping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize this record group fields datasets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        fields : list of str</span>
<span class="sd">            Names of the fields to initialize</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_run_record_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">WARPING</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grp</span></div>

<div class="viewcode-block" id="WepyHDF5.init_run_fields_progress"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_run_fields_progress">[docs]</a>    <span class="k">def</span> <span class="nf">init_run_fields_progress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize this record group fields datasets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        fields : list of str</span>
<span class="sd">            Names of the fields to initialize</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_run_record_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">PROGRESS</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grp</span></div>

<div class="viewcode-block" id="WepyHDF5.init_run_fields_bc"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_run_fields_bc">[docs]</a>    <span class="k">def</span> <span class="nf">init_run_fields_bc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize this record group fields datasets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        fields : list of str</span>
<span class="sd">            Names of the fields to initialize</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_run_record_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">BC</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grp</span></div>


<div class="viewcode-block" id="WepyHDF5.init_run_record_grp"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.init_run_record_grp">[docs]</a>    <span class="k">def</span> <span class="nf">init_run_record_grp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a record group for a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            The name of the record group.</span>
<span class="sd">        fields : list of str</span>
<span class="sd">            The names of the fields to set for the record group.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize the record group based on whether it is sporadic</span>
        <span class="c1"># or continual</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sporadic_records</span><span class="p">(</span><span class="n">run_record_key</span><span class="p">):</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_run_sporadic_record_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span>
                                                     <span class="n">fields</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_run_continual_record_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span>
                                                      <span class="n">fields</span><span class="p">)</span></div>


    <span class="c1"># TODO: should&#39;ve been removed already just double checking things are good without it</span>
    <span class="c1"># def traj_n_frames(self, run_idx, traj_idx):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>

    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     run_idx :</span>
            
    <span class="c1">#     traj_idx :</span>
            

    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>

    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     return self.traj(run_idx, traj_idx)[POSITIONS].shape[0]</span>

<div class="viewcode-block" id="WepyHDF5.add_traj"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.add_traj">[docs]</a>    <span class="k">def</span> <span class="nf">add_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a full trajectory to a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        data : dict of str : arraylike</span>
<span class="sd">            Mapping of trajectory fields to the data for them to add.</span>
<span class="sd">        weights : 1-D arraylike of float</span>
<span class="sd">            The weights of each frame. If None defaults all frames to 1.0.</span>

<span class="sd">        sparse_idxs : list of int</span>
<span class="sd">            Cycle indices the data corresponds to.</span>

<span class="sd">        metadata : dict of str : value</span>
<span class="sd">            Metadata for the trajectory.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        traj_grp : h5py.Group</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># convenient alias</span>
        <span class="n">traj_data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="c1"># initialize None kwargs</span>
        <span class="k">if</span> <span class="n">sparse_idxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sparse_idxs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># positions are mandatory</span>
        <span class="k">assert</span> <span class="n">POSITIONS</span> <span class="ow">in</span> <span class="n">traj_data</span><span class="p">,</span> <span class="s2">&quot;positions must be given to create a trajectory&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">traj_data</span><span class="p">[</span><span class="n">POSITIONS</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

        <span class="n">n_frames</span> <span class="o">=</span> <span class="n">traj_data</span><span class="p">[</span><span class="n">POSITIONS</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># if weights are None then we assume they are 1.0</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_frames</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s2">&quot;weights must be a numpy.ndarray&quot;</span>
            <span class="k">assert</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">n_frames</span><span class="p">,</span>\
                <span class="s2">&quot;weights and the number of frames must be the same length&quot;</span>

        <span class="c1"># current traj_idx</span>
        <span class="n">traj_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_run_traj_idx</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>
        <span class="c1"># make a group for this trajectory, with the current traj_idx</span>
        <span class="c1"># for this run</span>
        <span class="n">traj_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span>
                        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">))</span>

        <span class="c1"># add the run_idx as metadata</span>
        <span class="n">traj_grp</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">RUN_IDX</span><span class="p">]</span> <span class="o">=</span> <span class="n">run_idx</span>
        <span class="c1"># add the traj_idx as metadata</span>
        <span class="n">traj_grp</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">TRAJ_IDX</span><span class="p">]</span> <span class="o">=</span> <span class="n">traj_idx</span>


        <span class="c1"># add the rest of the metadata if given</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">metadata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="n">RUN_IDX</span><span class="p">,</span> <span class="n">TRAJ_IDX</span><span class="p">]:</span>
                <span class="n">traj_grp</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;run_idx and traj_idx are used by wepy and cannot be set&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>


        <span class="c1"># check to make sure the positions are the right shape</span>
        <span class="k">assert</span> <span class="n">traj_data</span><span class="p">[</span><span class="n">POSITIONS</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_atoms</span><span class="p">,</span> \
            <span class="s2">&quot;positions given have different number of atoms: </span><span class="si">{}</span><span class="s2">, should be </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">traj_data</span><span class="p">[</span><span class="n">POSITIONS</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_atoms</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">traj_data</span><span class="p">[</span><span class="n">POSITIONS</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dims</span><span class="p">,</span> \
            <span class="s2">&quot;positions given have different number of dims: </span><span class="si">{}</span><span class="s2">, should be </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">traj_data</span><span class="p">[</span><span class="n">POSITIONS</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dims</span><span class="p">)</span>

        <span class="c1"># add datasets to the traj group</span>

        <span class="c1"># weights</span>
        <span class="n">traj_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">WEIGHTS</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">WEIGHT_DTYPE</span><span class="p">,</span>
                                <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">WEIGHT_SHAPE</span><span class="p">))</span>
        <span class="c1"># positions</span>

        <span class="n">positions_shape</span> <span class="o">=</span> <span class="n">traj_data</span><span class="p">[</span><span class="n">POSITIONS</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># add the rest of the traj_data</span>
        <span class="k">for</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">field_data</span> <span class="ow">in</span> <span class="n">traj_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># if there were sparse idxs for this field pass them in</span>
            <span class="k">if</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="n">sparse_idxs</span><span class="p">:</span>
                <span class="n">field_sparse_idxs</span> <span class="o">=</span> <span class="n">sparse_idxs</span><span class="p">[</span><span class="n">field_path</span><span class="p">]</span>
            <span class="c1"># if this is a sparse field and no sparse_idxs were given</span>
            <span class="c1"># we still need to initialize it as a sparse field so it</span>
            <span class="c1"># can be extended properly so we make sparse_idxs to match</span>
            <span class="c1"># the full length of this initial trajectory data</span>
            <span class="k">elif</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_fields</span><span class="p">:</span>
                <span class="n">field_sparse_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">positions_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># otherwise it is not a sparse field so we just pass in None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">field_sparse_idxs</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_add_traj_field_data</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">field_data</span><span class="p">,</span>
                                      <span class="n">sparse_idxs</span><span class="o">=</span><span class="n">field_sparse_idxs</span><span class="p">)</span>

        <span class="c1">## initialize empty sparse fields</span>
        <span class="c1"># get the sparse field datasets that haven&#39;t been initialized</span>
        <span class="n">traj_init_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sparse_idxs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">traj_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">uninit_sparse_fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_fields</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">traj_init_fields</span><span class="p">)</span>
        <span class="c1"># the shapes</span>
        <span class="n">uninit_sparse_shapes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">field_feature_shapes</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">uninit_sparse_fields</span><span class="p">]</span>
        <span class="c1"># the dtypes</span>
        <span class="n">uninit_sparse_dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">field_feature_dtypes</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">uninit_sparse_fields</span><span class="p">]</span>
        <span class="c1"># initialize the sparse fields in the hdf5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_traj_fields</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span>
                               <span class="n">uninit_sparse_fields</span><span class="p">,</span> <span class="n">uninit_sparse_shapes</span><span class="p">,</span> <span class="n">uninit_sparse_dtypes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">traj_grp</span></div>

<div class="viewcode-block" id="WepyHDF5.extend_traj"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.extend_traj">[docs]</a>    <span class="k">def</span> <span class="nf">extend_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extend a trajectory with data for all fields.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>
<span class="sd">        data : dict of str : arraylike</span>
<span class="sd">            The data to add for each field of the trajectory. Must all</span>
<span class="sd">            have the same first dimension.</span>
<span class="sd">        weights : arraylike</span>
<span class="sd">            Weights for the frames of the trajectory. If None defaults all frames to 1.0.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wepy_mode</span> <span class="o">==</span> <span class="s1">&#39;c-&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_flags</span><span class="p">[</span><span class="n">dataset_key</span><span class="p">],</span> <span class="s2">&quot;dataset is not available for appending to&quot;</span>

        <span class="c1"># convenient alias</span>
        <span class="n">traj_data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="c1"># number of frames to add</span>
        <span class="n">n_new_frames</span> <span class="o">=</span> <span class="n">traj_data</span><span class="p">[</span><span class="n">POSITIONS</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">n_frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_traj_frames</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)</span>

        <span class="c1"># calculate the new sparse idxs for sparse fields that may be</span>
        <span class="c1"># being added</span>
        <span class="n">sparse_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">n_frames</span> <span class="o">+</span> <span class="n">n_new_frames</span><span class="p">))</span>

        <span class="c1"># get the trajectory group</span>
        <span class="n">traj_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)]</span>

        <span class="c1">## weights</span>

        <span class="c1"># if weights are None then we assume they are 1.0</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_new_frames</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s2">&quot;weights must be a numpy.ndarray&quot;</span>
            <span class="k">assert</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">n_new_frames</span><span class="p">,</span>\
                <span class="s2">&quot;weights and the number of frames must be the same length&quot;</span>

        <span class="c1"># add the weights</span>
        <span class="n">weights_ds</span> <span class="o">=</span> <span class="n">traj_grp</span><span class="p">[</span><span class="n">WEIGHTS</span><span class="p">]</span>

        <span class="c1"># append to the dataset on the first dimension, keeping the</span>
        <span class="c1"># others the same, if they exist</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">weights_ds</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="n">weights_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_new_frames</span><span class="p">,</span> <span class="o">*</span><span class="n">weights_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights_ds</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="n">weights_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_new_frames</span><span class="p">,</span> <span class="p">)</span> <span class="p">)</span>

        <span class="c1"># add the new data</span>
        <span class="n">weights_ds</span><span class="p">[</span><span class="o">-</span><span class="n">n_new_frames</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span>


        <span class="c1"># add the other fields</span>
        <span class="k">for</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">field_data</span> <span class="ow">in</span> <span class="n">traj_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># if the field hasn&#39;t been initialized yet initialize it,</span>
            <span class="c1"># unless we are in SWMR mode</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="n">traj_grp</span><span class="p">:</span>

                <span class="c1"># if in SWMR mode you cannot create groups so if we</span>
                <span class="c1"># are in SWMR mode raise a warning that the data won&#39;t</span>
                <span class="c1"># be recorded</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">swmr_mode</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;New datasets cannot be created while in SWMR mode.  The field </span><span class="si">{}</span><span class="s2"> will&quot;</span>
                    <span class="s2">&quot;not be saved. If you want to save this it must be&quot;</span>
                         <span class="s2">&quot;previously created&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field_path</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="n">feature_shape</span> <span class="o">=</span> <span class="n">field_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">feature_dtype</span> <span class="o">=</span> <span class="n">field_data</span><span class="o">.</span><span class="n">dtype</span>

                    <span class="c1"># not specified as sparse_field, no settings</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_feature_shapes</span><span class="p">)</span> <span class="ow">and</span> \
                         <span class="p">(</span><span class="ow">not</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_feature_dtypes</span><span class="p">)</span> <span class="ow">and</span> \
                         <span class="ow">not</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_fields</span><span class="p">:</span>
                        <span class="c1"># only save if it is an observable</span>
                        <span class="n">is_observable</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="s1">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">field_path</span><span class="p">:</span>
                            <span class="n">group_name</span> <span class="o">=</span> <span class="n">field_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">group_name</span> <span class="o">==</span> <span class="n">OBSERVABLES</span><span class="p">:</span>
                                <span class="n">is_observable</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="n">is_observable</span><span class="p">:</span>
                              <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;the field &#39;</span><span class="si">{}</span><span class="s2">&#39; was received but not previously specified&quot;</span>
                                   <span class="s2">&quot; but is being added because it is in observables.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field_path</span><span class="p">))</span>
                              <span class="c1"># save sparse_field flag, shape, and dtype</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">_add_sparse_field_flag</span><span class="p">(</span><span class="n">field_path</span><span class="p">)</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">_set_field_feature_shape</span><span class="p">(</span><span class="n">field_path</span><span class="p">,</span> <span class="n">feature_shape</span><span class="p">)</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">_set_field_feature_dtype</span><span class="p">(</span><span class="n">field_path</span><span class="p">,</span> <span class="n">feature_dtype</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the field &#39;</span><span class="si">{}</span><span class="s2">&#39; was received but not previously specified&quot;</span>
                                <span class="s2">&quot;it is being ignored because it is not an observable.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field_path</span><span class="p">))</span>

                    <span class="c1"># specified as sparse_field but no settings given</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_feature_shapes</span><span class="p">[</span><span class="n">field_path</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">field_feature_dtypes</span><span class="p">[</span><span class="n">field_path</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> \
                       <span class="n">field_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_fields</span><span class="p">:</span>
                        <span class="c1"># set the feature shape and dtype since these</span>
                        <span class="c1"># should be 0 in the settings</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_set_field_feature_shape</span><span class="p">(</span><span class="n">field_path</span><span class="p">,</span> <span class="n">feature_shape</span><span class="p">)</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">_set_field_feature_dtype</span><span class="p">(</span><span class="n">field_path</span><span class="p">,</span> <span class="n">feature_dtype</span><span class="p">)</span>

                    <span class="c1"># initialize</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_init_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">feature_shape</span><span class="p">,</span> <span class="n">feature_dtype</span><span class="p">)</span>

            <span class="c1"># extend it either as a sparse field or a contiguous field</span>
            <span class="k">if</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_fields</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extend_sparse_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">field_data</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extend_contiguous_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">field_data</span><span class="p">)</span></div>

    <span class="c1">## application level append methods for run records groups</span>

<div class="viewcode-block" id="WepyHDF5.extend_cycle_warping_records"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.extend_cycle_warping_records">[docs]</a>    <span class="k">def</span> <span class="nf">extend_cycle_warping_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">cycle_idx</span><span class="p">,</span> <span class="n">warping_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add records for each field for this record group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        cycle_idx : int</span>
<span class="sd">            The cycle index these records correspond to.</span>
<span class="sd">        warping_data : dict of str : arraylike</span>
<span class="sd">            Mapping of the record group fields to a collection of</span>
<span class="sd">            values for each field.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend_cycle_run_group_records</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">WARPING</span><span class="p">,</span> <span class="n">cycle_idx</span><span class="p">,</span> <span class="n">warping_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.extend_cycle_bc_records"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.extend_cycle_bc_records">[docs]</a>    <span class="k">def</span> <span class="nf">extend_cycle_bc_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">cycle_idx</span><span class="p">,</span> <span class="n">bc_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add records for each field for this record group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        cycle_idx : int</span>
<span class="sd">            The cycle index these records correspond to.</span>
<span class="sd">        bc_data : dict of str : arraylike</span>
<span class="sd">            Mapping of the record group fields to a collection of</span>
<span class="sd">            values for each field.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extend_cycle_run_group_records</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">BC</span><span class="p">,</span> <span class="n">cycle_idx</span><span class="p">,</span> <span class="n">bc_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.extend_cycle_progress_records"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.extend_cycle_progress_records">[docs]</a>    <span class="k">def</span> <span class="nf">extend_cycle_progress_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">cycle_idx</span><span class="p">,</span> <span class="n">progress_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add records for each field for this record group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        cycle_idx : int</span>
<span class="sd">            The cycle index these records correspond to.</span>
<span class="sd">        progress_data : dict of str : arraylike</span>
<span class="sd">            Mapping of the record group fields to a collection of</span>
<span class="sd">            values for each field.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend_cycle_run_group_records</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">PROGRESS</span><span class="p">,</span> <span class="n">cycle_idx</span><span class="p">,</span> <span class="n">progress_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.extend_cycle_resampling_records"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.extend_cycle_resampling_records">[docs]</a>    <span class="k">def</span> <span class="nf">extend_cycle_resampling_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">cycle_idx</span><span class="p">,</span> <span class="n">resampling_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add records for each field for this record group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        cycle_idx : int</span>
<span class="sd">            The cycle index these records correspond to.</span>
<span class="sd">        resampling_data : dict of str : arraylike</span>
<span class="sd">            Mapping of the record group fields to a collection of</span>
<span class="sd">            values for each field.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extend_cycle_run_group_records</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">RESAMPLING</span><span class="p">,</span> <span class="n">cycle_idx</span><span class="p">,</span> <span class="n">resampling_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.extend_cycle_resampler_records"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.extend_cycle_resampler_records">[docs]</a>    <span class="k">def</span> <span class="nf">extend_cycle_resampler_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">cycle_idx</span><span class="p">,</span> <span class="n">resampler_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add records for each field for this record group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        cycle_idx : int</span>
<span class="sd">            The cycle index these records correspond to.</span>
<span class="sd">        resampler_data : dict of str : arraylike</span>
<span class="sd">            Mapping of the record group fields to a collection of</span>
<span class="sd">            values for each field.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend_cycle_run_group_records</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">RESAMPLER</span><span class="p">,</span> <span class="n">cycle_idx</span><span class="p">,</span> <span class="n">resampler_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.extend_cycle_run_group_records"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.extend_cycle_run_group_records">[docs]</a>    <span class="k">def</span> <span class="nf">extend_cycle_run_group_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span> <span class="n">cycle_idx</span><span class="p">,</span> <span class="n">fields_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extend data for a whole records group.</span>

<span class="sd">        This must have the cycle index for the data it is appending as</span>
<span class="sd">        this is done for sporadic and continual datasets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            Name of the record group.</span>
<span class="sd">        cycle_idx : int</span>
<span class="sd">            The cycle index these records correspond to.</span>
<span class="sd">        fields_data : dict of str : arraylike</span>
<span class="sd">            Mapping of the field name to the values for the records being added.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">record_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">records_grp</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">)</span>

        <span class="c1"># if it is sporadic add the cycle idx</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sporadic_records</span><span class="p">(</span><span class="n">run_record_key</span><span class="p">):</span>

            <span class="c1"># get the cycle idxs dataset</span>
            <span class="n">record_cycle_idxs_ds</span> <span class="o">=</span> <span class="n">record_grp</span><span class="p">[</span><span class="n">CYCLE_IDXS</span><span class="p">]</span>

            <span class="c1"># number of old and new records</span>
            <span class="n">n_new_records</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields_data</span><span class="p">)</span>
            <span class="n">n_existing_records</span> <span class="o">=</span> <span class="n">record_cycle_idxs_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># make a new chunk for the new records</span>
            <span class="n">record_cycle_idxs_ds</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span> <span class="p">(</span><span class="n">n_existing_records</span> <span class="o">+</span> <span class="n">n_new_records</span><span class="p">,)</span> <span class="p">)</span>

            <span class="c1"># add an array of the cycle idx for each record</span>
            <span class="n">record_cycle_idxs_ds</span><span class="p">[</span><span class="n">n_existing_records</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_new_records</span><span class="p">,),</span> <span class="n">cycle_idx</span><span class="p">)</span>

        <span class="c1"># then add all the data for the field</span>
        <span class="k">for</span> <span class="n">record_dict</span> <span class="ow">in</span> <span class="n">fields_data</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_data</span> <span class="ow">in</span> <span class="n">record_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extend_run_record_data_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">,</span>
                                                   <span class="n">field_name</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">field_data</span><span class="p">]))</span></div>

    <span class="c1">### Analysis Routines</span>

    <span class="c1">## Record Getters</span>

<div class="viewcode-block" id="WepyHDF5.run_records"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run_records">[docs]</a>    <span class="k">def</span> <span class="nf">run_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records for a record group for a single run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            The name of the record group.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records : list of namedtuple objects</span>
<span class="sd">            The list of records for the run&#39;s record group.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># wrap this in a list since the underlying functions accept a</span>
        <span class="c1"># list of records</span>
        <span class="n">run_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">run_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_contig_records</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.run_contig_records"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run_contig_records">[docs]</a>    <span class="k">def</span> <span class="nf">run_contig_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records for a record group for the contig that is formed by</span>
<span class="sd">        the run indices.</span>

<span class="sd">        This alters the cycle indices for the records so that they</span>
<span class="sd">        appear to have come from a single run. That is they are the</span>
<span class="sd">        cycle indices of the contig.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that form a contig. (i.e. element 1</span>
<span class="sd">            continues element 0)</span>

<span class="sd">        run_record_key : str</span>
<span class="sd">            Name of the record group.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records : list of namedtuple objects</span>
<span class="sd">            The list of records for the contig&#39;s record group.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if there are no fields return an empty list</span>
        <span class="n">record_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_fields</span><span class="p">[</span><span class="n">run_record_key</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">record_fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># get the iterator for the record idxs, if the group is</span>
        <span class="c1"># sporadic then we just use the cycle idxs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sporadic_records</span><span class="p">(</span><span class="n">run_record_key</span><span class="p">):</span>
            <span class="n">records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_records_sporadic</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_records_continual</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">records</span></div>

<div class="viewcode-block" id="WepyHDF5.run_records_dataframe"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run_records_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">run_records_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records for a record group for a single run in the form of</span>
<span class="sd">        a pandas DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            Name of record group.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record_df : pandas.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_records</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">records</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.run_contig_records_dataframe"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run_contig_records_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">run_contig_records_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records for a record group for a contig of runs in the form</span>
<span class="sd">	of a pandas DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that form a contig. (i.e. element 1</span>
<span class="sd">            continues element 0)</span>
<span class="sd">        run_record_key : str</span>
<span class="sd">            The name of the record group.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records_df : pandas.DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_contig_records</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">,</span> <span class="n">run_record_key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">records</span><span class="p">)</span></div>

    <span class="c1"># application level specific methods for each main group</span>

    <span class="c1"># resampling</span>
<div class="viewcode-block" id="WepyHDF5.resampling_records"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.resampling_records">[docs]</a>    <span class="k">def</span> <span class="nf">resampling_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records this record group for the contig that is formed by</span>
<span class="sd">        the run indices.</span>

<span class="sd">        This alters the cycle indices for the records so that they</span>
<span class="sd">        appear to have come from a single run. That is they are the</span>
<span class="sd">        cycle indices of the contig.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that form a contig. (i.e. element 1</span>
<span class="sd">            continues element 0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records : list of namedtuple objects</span>
<span class="sd">            The list of records for the contig&#39;s record group.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_contig_records</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">,</span> <span class="n">RESAMPLING</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.resampling_records_dataframe"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.resampling_records_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">resampling_records_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records for this record group for a contig of runs in the</span>
<span class="sd">	form of a pandas DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that form a contig. (i.e. element 1</span>
<span class="sd">            continues element 0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records_df : pandas.DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resampling_records</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">))</span></div>

    <span class="c1"># resampler records</span>
<div class="viewcode-block" id="WepyHDF5.resampler_records"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.resampler_records">[docs]</a>    <span class="k">def</span> <span class="nf">resampler_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records this record group for the contig that is formed by</span>
<span class="sd">        the run indices.</span>

<span class="sd">        This alters the cycle indices for the records so that they</span>
<span class="sd">        appear to have come from a single run. That is they are the</span>
<span class="sd">        cycle indices of the contig.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that form a contig. (i.e. element 1</span>
<span class="sd">            continues element 0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records : list of namedtuple objects</span>
<span class="sd">            The list of records for the contig&#39;s record group.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_contig_records</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">,</span> <span class="n">RESAMPLER</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.resampler_records_dataframe"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.resampler_records_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">resampler_records_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records for this record group for a contig of runs in the</span>
<span class="sd">	form of a pandas DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that form a contig. (i.e. element 1</span>
<span class="sd">            continues element 0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records_df : pandas.DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resampler_records</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">))</span></div>

    <span class="c1"># warping</span>
<div class="viewcode-block" id="WepyHDF5.warping_records"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.warping_records">[docs]</a>    <span class="k">def</span> <span class="nf">warping_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records this record group for the contig that is formed by</span>
<span class="sd">        the run indices.</span>

<span class="sd">        This alters the cycle indices for the records so that they</span>
<span class="sd">        appear to have come from a single run. That is they are the</span>
<span class="sd">        cycle indices of the contig.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that form a contig. (i.e. element 1</span>
<span class="sd">            continues element 0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records : list of namedtuple objects</span>
<span class="sd">            The list of records for the contig&#39;s record group.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_contig_records</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">,</span> <span class="n">WARPING</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.warping_records_dataframe"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.warping_records_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">warping_records_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records for this record group for a contig of runs in the</span>
<span class="sd">	form of a pandas DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that form a contig. (i.e. element 1</span>
<span class="sd">            continues element 0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records_df : pandas.DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">warping_records</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">))</span></div>

    <span class="c1"># boundary conditions</span>
<div class="viewcode-block" id="WepyHDF5.bc_records"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.bc_records">[docs]</a>    <span class="k">def</span> <span class="nf">bc_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records this record group for the contig that is formed by</span>
<span class="sd">        the run indices.</span>

<span class="sd">        This alters the cycle indices for the records so that they</span>
<span class="sd">        appear to have come from a single run. That is they are the</span>
<span class="sd">        cycle indices of the contig.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that form a contig. (i.e. element 1</span>
<span class="sd">            continues element 0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records : list of namedtuple objects</span>
<span class="sd">            The list of records for the contig&#39;s record group.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_contig_records</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">,</span> <span class="n">BC</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.bc_records_dataframe"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.bc_records_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">bc_records_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records for this record group for a contig of runs in the</span>
<span class="sd">	form of a pandas DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that form a contig. (i.e. element 1</span>
<span class="sd">            continues element 0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records_df : pandas.DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc_records</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">))</span></div>

    <span class="c1"># progress</span>
<div class="viewcode-block" id="WepyHDF5.progress_records"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.progress_records">[docs]</a>    <span class="k">def</span> <span class="nf">progress_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records this record group for the contig that is formed by</span>
<span class="sd">        the run indices.</span>

<span class="sd">        This alters the cycle indices for the records so that they</span>
<span class="sd">        appear to have come from a single run. That is they are the</span>
<span class="sd">        cycle indices of the contig.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that form a contig. (i.e. element 1</span>
<span class="sd">            continues element 0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records : list of namedtuple objects</span>
<span class="sd">            The list of records for the contig&#39;s record group.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_contig_records</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">,</span> <span class="n">PROGRESS</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.progress_records_dataframe"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.progress_records_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">progress_records_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the records for this record group for a contig of runs in the</span>
<span class="sd">	form of a pandas DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that form a contig. (i.e. element 1</span>
<span class="sd">            continues element 0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        records_df : pandas.DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">progress_records</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">))</span></div>


<div class="viewcode-block" id="WepyHDF5.run_resampling_panel"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run_resampling_panel">[docs]</a>    <span class="k">def</span> <span class="nf">run_resampling_panel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a resampling panel from the resampling records of a run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        resampling_panel : list of list of list of namedtuple records</span>
<span class="sd">            The panel (list of tables) of resampling records in order</span>
<span class="sd">            (cycle, step, walker)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_contig_resampling_panel</span><span class="p">([</span><span class="n">run_idx</span><span class="p">])</span></div>

<div class="viewcode-block" id="WepyHDF5.run_contig_resampling_panel"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run_contig_resampling_panel">[docs]</a>    <span class="k">def</span> <span class="nf">run_contig_resampling_panel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idxs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a resampling panel from the resampling records of a</span>
<span class="sd">        contig, which is a series of runs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idxs : list of int</span>
<span class="sd">            The run indices that form a contig. (i.e. element 1</span>
<span class="sd">            continues element 0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        resampling_panel : list of list of list of namedtuple records</span>
<span class="sd">            The panel (list of tables) of resampling records in order</span>
<span class="sd">            (cycle, step, walker)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check the contig to make sure it is a valid contig</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_run_contig</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The run_idxs provided are not a valid contig, </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">run_idxs</span><span class="p">))</span>

        <span class="c1"># make the resampling panel from the resampling records for the contig</span>
        <span class="n">contig_resampling_panel</span> <span class="o">=</span> <span class="n">resampling_panel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resampling_records</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">),</span>
                                                   <span class="n">is_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">contig_resampling_panel</span></div>


    <span class="c1"># Trajectory Field Setters</span>

<div class="viewcode-block" id="WepyHDF5.add_run_observable"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.add_run_observable">[docs]</a>    <span class="k">def</span> <span class="nf">add_run_observable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">observable_name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a trajectory sub-field in the compound field &quot;observables&quot; for</span>
<span class="sd">        a single run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        observable_name : str</span>
<span class="sd">            What to name the observable subfield.</span>
<span class="sd">        data : arraylike of shape (n_trajs, feature_vector_shape[0], ...)</span>
<span class="sd">            The data for all of the trajectories that will be set to</span>
<span class="sd">            this observable field.</span>
<span class="sd">        sparse_idxs : list of int, optional</span>
<span class="sd">            If not None, specifies the cycle indices this data corresponds to.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obs_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">OBSERVABLES</span><span class="p">,</span> <span class="n">observable_name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_run_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">obs_path</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="o">=</span><span class="n">sparse_idxs</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.add_traj_observable"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.add_traj_observable">[docs]</a>    <span class="k">def</span> <span class="nf">add_traj_observable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">observable_name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a trajectory sub-field in the compound field &quot;observables&quot; for</span>
<span class="sd">        an entire file, on a trajectory basis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        observable_name : str</span>
<span class="sd">            What to name the observable subfield.</span>

<span class="sd">        data : list of arraylike</span>
<span class="sd">            The data for each run are the elements of this</span>
<span class="sd">            argument. Each element is an arraylike of shape</span>
<span class="sd">            (n_traj_frames, feature_vector_shape[0],...) where the</span>
<span class="sd">            n_run_frames is the number of frames in trajectory.</span>

<span class="sd">        sparse_idxs : list of list of int, optional</span>
<span class="sd">            If not None, specifies the cycle indices this data</span>
<span class="sd">            corresponds to. First by run, then by trajectory.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obs_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">OBSERVABLES</span><span class="p">,</span> <span class="n">observable_name</span><span class="p">)</span>

        <span class="n">run_results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_runs</span><span class="p">):</span>

            <span class="n">run_num_trajs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_trajs</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>
            <span class="n">run_results</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

            <span class="k">for</span> <span class="n">traj_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">run_num_trajs</span><span class="p">):</span>
                <span class="n">run_results</span><span class="p">[</span><span class="n">run_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[(</span><span class="n">run_idx</span> <span class="o">*</span> <span class="n">run_num_trajs</span><span class="p">)</span> <span class="o">+</span> <span class="n">traj_idx</span><span class="p">])</span>

        <span class="n">run_sparse_idxs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">sparse_idxs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">run_sparse_idxs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_runs</span><span class="p">):</span>

                <span class="n">run_num_trajs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_trajs</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>
                <span class="n">run_sparse_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                <span class="k">for</span> <span class="n">traj_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">run_num_trajs</span><span class="p">):</span>
                    <span class="n">run_sparse_idxs</span><span class="p">[</span><span class="n">run_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sparse_idxs</span><span class="p">[(</span><span class="n">run_idx</span> <span class="o">*</span> <span class="n">run_num_trajs</span><span class="p">)</span> <span class="o">+</span> <span class="n">traj_idx</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_observable</span><span class="p">(</span><span class="n">observable_name</span><span class="p">,</span> <span class="n">run_results</span><span class="p">,</span>
                            <span class="n">sparse_idxs</span><span class="o">=</span><span class="n">run_sparse_idxs</span><span class="p">)</span></div>



<div class="viewcode-block" id="WepyHDF5.add_observable"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.add_observable">[docs]</a>    <span class="k">def</span> <span class="nf">add_observable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">observable_name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a trajectory sub-field in the compound field &quot;observables&quot; for</span>
<span class="sd">        an entire file, on a compound run and trajectory basis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        observable_name : str</span>
<span class="sd">            What to name the observable subfield.</span>

<span class="sd">        data : list of list of arraylike</span>

<span class="sd">            The data for each run are the elements of this</span>
<span class="sd">            argument. Each element is a list of the trajectory</span>
<span class="sd">            observable arraylikes of shape (n_traj_frames,</span>
<span class="sd">            feature_vector_shape[0],...).</span>

<span class="sd">        sparse_idxs : list of list of int, optional</span>
<span class="sd">            If not None, specifies the cycle indices this data</span>
<span class="sd">            corresponds to. First by run, then by trajectory.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obs_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">OBSERVABLES</span><span class="p">,</span> <span class="n">observable_name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_field</span><span class="p">(</span><span class="n">obs_path</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="o">=</span><span class="n">sparse_idxs</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.compute_observable"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.compute_observable">[docs]</a>    <span class="k">def</span> <span class="nf">compute_observable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span>
                           <span class="n">map_func</span><span class="o">=</span><span class="nb">map</span><span class="p">,</span>
                           <span class="n">traj_sel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">save_to_hdf5</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_results</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute an observable on the trajectory data according to a</span>
<span class="sd">        function. Optionally save that data in the observables data group for</span>
<span class="sd">        the trajectory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            The function to apply to the trajectory fields (by</span>
<span class="sd">            cycle). Must accept a dictionary mapping string trajectory</span>
<span class="sd">            field names to a feature vector for that cycle and return</span>
<span class="sd">            an arraylike. May accept other positional arguments as well.</span>

<span class="sd">        fields : list of str</span>
<span class="sd">            A list of trajectory field names to pass to the mapped function.</span>

<span class="sd">        args : None or or tuple</span>
<span class="sd">            A single tuple of arguments which will be expanded and</span>
<span class="sd">            passed to the mapped function for every evaluation.</span>

<span class="sd">        map_func : callable</span>
<span class="sd">            The mapping function. The implementation of how to map the</span>
<span class="sd">            computation function over the data. Default is the python</span>
<span class="sd">            builtin `map` function. Can be a parallel implementation</span>
<span class="sd">            for example.</span>

<span class="sd">        traj_sel : list of tuple, optional</span>
<span class="sd">            If not None, a list of trajectory identifier tuple</span>
<span class="sd">            (run_idx, traj_idx) to restrict the computation to.</span>

<span class="sd">        save_to_hdf5 : None or string, optional</span>
<span class="sd">            If not None, a string that specifies the name of the</span>
<span class="sd">            observables sub-field that the computed values will be saved to.</span>

<span class="sd">        idxs : bool</span>
<span class="sd">            If True will return the trajectory identifier tuple</span>
<span class="sd">            (run_idx, traj_idx) along with other return values.</span>

<span class="sd">        return_results : bool</span>
<span class="sd">            If True will return the results of the mapping. If not</span>
<span class="sd">            using the &#39;save_to_hdf5&#39; option, be sure to use this or</span>
<span class="sd">            results will be lost.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        traj_id_tuples : list of tuple of int, if &#39;idxs&#39; option is True</span>
<span class="sd">            A list of the tuple identifiers for each trajectory result.</span>

<span class="sd">        results : list of arraylike, if &#39;return_results&#39; option is True</span>
<span class="sd">            A list of arraylike feature vectors for each trajectory.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">save_to_hdf5</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;w-&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;c-&#39;</span><span class="p">],</span>\
                <span class="s2">&quot;File must be in a write mode&quot;</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">save_to_hdf5</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span>\
                <span class="s2">&quot;`save_to_hdf5` should be the field name to save the data in the `observables`&quot;</span>\
                <span class="s2">&quot; group in each trajectory&quot;</span>

            <span class="c1"># the field name comes from this kwarg if it satisfies the</span>
            <span class="c1"># string condition above</span>
            <span class="n">field_name</span> <span class="o">=</span> <span class="n">save_to_hdf5</span>

        <span class="c1"># calculate the results and accumulate them here</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># and the indices of the results</span>
        <span class="n">result_idxs</span> <span class="o">=</span> <span class="p">[]</span>


        <span class="c1"># map over the trajectories and apply the function and save</span>
        <span class="c1"># the results</span>
        <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_fields_map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span>
                                           <span class="n">map_func</span><span class="o">=</span><span class="n">map_func</span><span class="p">,</span> <span class="n">traj_sel</span><span class="o">=</span><span class="n">traj_sel</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

            <span class="n">idx_tup</span><span class="p">,</span> <span class="n">obs_features</span> <span class="o">=</span> <span class="n">result</span>

            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs_features</span><span class="p">)</span>
            <span class="n">result_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_tup</span><span class="p">)</span>

        <span class="c1"># we want to separate writing and computation so we can do it</span>
        <span class="c1"># in parallel without having multiple writers. So if we are</span>
        <span class="c1"># writing directly to the HDF5 we add the results to it.</span>

        <span class="c1"># if we are saving this to the trajectories observables add it as a dataset</span>
        <span class="k">if</span> <span class="n">save_to_hdf5</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">idx_tup</span><span class="p">,</span> <span class="n">traj_results</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">result_idxs</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>

                <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span> <span class="o">=</span> <span class="n">idx_tup</span>

                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Saving run </span><span class="si">{}</span><span class="s2"> traj </span><span class="si">{}</span><span class="s2"> observables/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_name</span><span class="p">))</span>

                <span class="c1"># try to get the observables group or make it if it doesn&#39;t exist</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">obs_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)[</span><span class="n">OBSERVABLES</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>

                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Group uninitialized. Initializing.&quot;</span><span class="p">)</span>

                    <span class="n">obs_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">OBSERVABLES</span><span class="p">)</span>

                <span class="c1"># try to create the dataset</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">obs_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">obs_features</span><span class="p">)</span>
                <span class="c1"># if it fails we either overwrite or raise an error</span>
                <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                    <span class="c1"># if we are in a permissive write mode we delete the</span>
                    <span class="c1"># old dataset and add the new one, overwriting old data</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;w-&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">]:</span>

                        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Dataset already present. Overwriting.&quot;</span><span class="p">)</span>

                        <span class="k">del</span> <span class="n">obs_grp</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>
                        <span class="n">obs_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">obs_features</span><span class="p">)</span>
                    <span class="c1"># this will happen in &#39;c&#39; and &#39;c-&#39; modes</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                            <span class="s2">&quot;Dataset already exists and file is in concatenate mode (&#39;c&#39; or &#39;c-&#39;)&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">return_results</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idxs</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result_idxs</span><span class="p">,</span> <span class="n">results</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">results</span></div>
    <span class="c1">## Trajectory Getters</span>

<div class="viewcode-block" id="WepyHDF5.get_traj_field"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.get_traj_field">[docs]</a>    <span class="k">def</span> <span class="nf">get_traj_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">masked</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a numpy array for the given trajectory field.</span>

<span class="sd">        You can control how sparse fields are returned using the</span>
<span class="sd">        `masked` option. When True (default) a masked numpy array will</span>
<span class="sd">        be returned such that you can get which cycles it is from,</span>
<span class="sd">        when False an unmasked array of the data will be returned</span>
<span class="sd">        which has no cycle information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>
<span class="sd">        field_path : str</span>
<span class="sd">            Name of the trajectory field to get</span>

<span class="sd">        frames : None or list of int</span>
<span class="sd">            If not None, a list of the frame indices of the trajectory</span>
<span class="sd">            to return values for.</span>

<span class="sd">        masked : bool</span>
<span class="sd">            If true will return sparse field values as masked arrays,</span>
<span class="sd">            otherwise just returns the compacted data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        field_data : arraylike</span>
<span class="sd">            The data for the trajectory field.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">traj_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">RUNS</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)</span>

        <span class="c1"># if the field doesn&#39;t exist return None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5</span><span class="p">[</span><span class="n">traj_path</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;key for field </span><span class="si">{}</span><span class="s2"> not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field_path</span><span class="p">))</span>
            <span class="c1"># return None</span>

        <span class="c1"># get the field depending on whether it is sparse or not</span>
        <span class="k">if</span> <span class="n">field_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_fields</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sparse_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span>
                                               <span class="n">frames</span><span class="o">=</span><span class="n">frames</span><span class="p">,</span> <span class="n">masked</span><span class="o">=</span><span class="n">masked</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_contiguous_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_path</span><span class="p">,</span>
                                                   <span class="n">frames</span><span class="o">=</span><span class="n">frames</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.get_trace_fields"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.get_trace_fields">[docs]</a>    <span class="k">def</span> <span class="nf">get_trace_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame_tups</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get trajectory field data for the frames specified by the trace.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frame_tups : list of tuple of int</span>
<span class="sd">            The trace values. Each tuple is of the form</span>
<span class="sd">            (run_idx, traj_idx, frame_idx).</span>

<span class="sd">        fields : list of str</span>
<span class="sd">            The names of the fields to get for each frame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trace_fields : dict of str : arraylike</span>
<span class="sd">            Mapping of the field names to the array of feature vectors</span>
<span class="sd">            for the trace.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frame_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span> <span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">cycle_idx</span> <span class="ow">in</span> <span class="n">frame_tups</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                <span class="n">frame_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="p">[</span><span class="n">cycle_idx</span><span class="p">])</span>
                <span class="c1"># the first dimension doesn&#39;t matter here since we</span>
                <span class="c1"># only get one frame at a time.</span>
                <span class="n">frame_fields</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_field</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># combine all the parts of each field into single arrays</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="n">frame_fields</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frame_fields</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">frame_fields</span></div>

<div class="viewcode-block" id="WepyHDF5.get_run_trace_fields"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.get_run_trace_fields">[docs]</a>    <span class="k">def</span> <span class="nf">get_run_trace_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">frame_tups</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get trajectory field data for the frames specified by the trace</span>
<span class="sd">        within a single run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>

<span class="sd">        frame_tups : list of tuple of int</span>
<span class="sd">            The trace values. Each tuple is of the form</span>
<span class="sd">            (traj_idx, frame_idx).</span>

<span class="sd">        fields : list of str</span>
<span class="sd">            The names of the fields to get for each frame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trace_fields : dict of str : arraylike</span>
<span class="sd">            Mapping of the field names to the array of feature vectors</span>
<span class="sd">            for the trace.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frame_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span> <span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">cycle_idx</span> <span class="ow">in</span> <span class="n">frame_tups</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>




                <span class="n">frame_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="p">[</span><span class="n">cycle_idx</span><span class="p">])</span>
                <span class="c1"># the first dimension doesn&#39;t matter here since we</span>
                <span class="c1"># only get one frame at a time.</span>
                <span class="n">frame_fields</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_field</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># combine all the parts of each field into single arrays</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="n">frame_fields</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frame_fields</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">frame_fields</span></div>


<div class="viewcode-block" id="WepyHDF5.get_contig_trace_fields"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.get_contig_trace_fields">[docs]</a>    <span class="k">def</span> <span class="nf">get_contig_trace_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contig_trace</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get field data for all trajectories of a contig for the frames</span>
<span class="sd">        specified by the contig trace.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        contig_trace : list of tuple of int</span>
<span class="sd">            The trace values. Each tuple is of the form</span>
<span class="sd">            (run_idx, frame_idx).</span>

<span class="sd">        fields : list of str</span>
<span class="sd">            The names of the fields to get for each cycle.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        contig_fields : dict of str : arraylike</span>
<span class="sd">                             of shape (n_cycles, n_trajs, field_feature_shape[0],...)</span>
<span class="sd">            Mapping of the field names to the array of feature vectors</span>
<span class="sd">            for contig trace.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># to be efficient we want to group our grabbing of fields by run</span>

        <span class="c1"># so we group them by run</span>
        <span class="n">runs_frames</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="c1"># and we get the runs in the order to fetch them</span>
        <span class="n">run_idxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">cycle_idx</span> <span class="ow">in</span> <span class="n">contig_trace</span><span class="p">:</span>
            <span class="n">runs_frames</span><span class="p">[</span><span class="n">run_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle_idx</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="n">run_idxs</span><span class="p">:</span>
                <span class="n">run_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>


        <span class="c1"># (there must be the same number of trajectories in each run)</span>
        <span class="n">n_trajs_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_trajs</span><span class="p">(</span><span class="n">run_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="kc">True</span> <span class="k">if</span> <span class="n">n_trajs_test</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_trajs</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="n">run_idxs</span><span class="p">])</span>

        <span class="c1"># then using this we go run by run and get all the</span>
        <span class="c1"># trajectories</span>
        <span class="n">field_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>

            <span class="c1"># we gather trajectories in &quot;bundles&quot; (think sticks</span>
            <span class="c1"># strapped together) and each bundle represents a run, we</span>
            <span class="c1"># will concatenate the ends of the bundles together to get</span>
            <span class="c1"># the full array at the end</span>
            <span class="n">bundles</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="n">run_idxs</span><span class="p">:</span>

                <span class="n">run_bundle</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">traj_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_traj_idxs</span><span class="p">(</span><span class="n">run_idx</span><span class="p">):</span>

                    <span class="c1"># get the values for this (field, run, trajectory)</span>
                    <span class="n">traj_field_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span>
                                                          <span class="n">frames</span><span class="o">=</span><span class="n">runs_frames</span><span class="p">[</span><span class="n">run_idx</span><span class="p">],</span>
                                                          <span class="n">masked</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="n">run_bundle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traj_field_vals</span><span class="p">)</span>

                <span class="c1"># convert this &quot;bundle&quot; of trajectory values (think</span>
                <span class="c1"># sticks side by side) into an array</span>
                <span class="n">run_bundle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">run_bundle</span><span class="p">)</span>
                <span class="n">bundles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">run_bundle</span><span class="p">)</span>

            <span class="c1"># stick the bundles together end to end to make the value</span>
            <span class="c1"># for this field , the first dimension currently is the</span>
            <span class="c1"># trajectory_index, but we want to make the cycles the</span>
            <span class="c1"># first dimension. So we stack them along that axis then</span>
            <span class="c1"># transpose the first two axes (not the rest of them which</span>
            <span class="c1"># should stay the same). Pardon the log terminology, but I</span>
            <span class="c1"># don&#39;t know a name for a bunch of bundles taped together.</span>
            <span class="n">field_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">bundles</span><span class="p">))</span>
            <span class="n">field_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">field_log</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">field_values</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_log</span>


        <span class="k">return</span> <span class="n">field_values</span></div>

<div class="viewcode-block" id="WepyHDF5.iter_trajs_fields"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.iter_trajs_fields">[docs]</a>    <span class="k">def</span> <span class="nf">iter_trajs_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">traj_sel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator for iterating over fields trajectories in a file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fields : list of str</span>
<span class="sd">            Names of the trajectory fields you want to yield.</span>

<span class="sd">        idxs : bool</span>
<span class="sd">            If True will also return the tuple identifier of the</span>
<span class="sd">            trajectory the field data is from.</span>

<span class="sd">        traj_sel : list of tuple of int</span>
<span class="sd">            If not None, a list of trajectory identifiers to restrict</span>
<span class="sd">            iteration over.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        traj_identifier : tuple of int if &#39;idxs&#39; option is True</span>
<span class="sd">            Tuple identifying the trajectory the data belongs to</span>
<span class="sd">            (run_idx, traj_idx).</span>

<span class="sd">        fields_data : dict of str : arraylike</span>
<span class="sd">            Mapping of the field name to the array of feature vectors</span>
<span class="sd">            of that field for this trajectory.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">idx_tup</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_trajs</span><span class="p">(</span><span class="n">idxs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">traj_sel</span><span class="o">=</span><span class="n">traj_sel</span><span class="p">):</span>
            <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span> <span class="o">=</span> <span class="n">idx_tup</span>

            <span class="n">dsets</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># DEBUG if we ask for debug prints send in the run and</span>
            <span class="c1"># traj index so the function can print this out TESTING if</span>
            <span class="c1"># this causes no problems (it doesn&#39;t seem like it would</span>
            <span class="c1"># from the code this will be removed permanently)</span>

            <span class="c1"># dsets[&#39;run_idx&#39;] = run_idx</span>
            <span class="c1"># dsets[TRAJ_IDX] = traj_idx</span>

            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dset</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="n">field</span><span class="p">][:]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;field </span><span class="se">\&quot;</span><span class="si">{}</span><span class="se">\&quot;</span><span class="s2"> not found in </span><span class="se">\&quot;</span><span class="si">{}</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">traj</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
                    <span class="n">dset</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="n">dsets</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">dset</span>

            <span class="k">if</span> <span class="n">idxs</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">),</span> <span class="n">dsets</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">dsets</span></div>

<div class="viewcode-block" id="WepyHDF5.traj_fields_map"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.traj_fields_map">[docs]</a>    <span class="k">def</span> <span class="nf">traj_fields_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span>
                        <span class="n">map_func</span><span class="o">=</span><span class="nb">map</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">traj_sel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function for mapping work onto field of trajectories.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            The function to apply to the trajectory fields (by</span>
<span class="sd">            cycle). Must accept a dictionary mapping string trajectory</span>
<span class="sd">            field names to a feature vector for that cycle and return</span>
<span class="sd">            an arraylike. May accept other positional arguments as well.</span>

<span class="sd">        fields : list of str</span>
<span class="sd">            A list of trajectory field names to pass to the mapped function.</span>

<span class="sd">        args : None or or tuple</span>
<span class="sd">            A single tuple of arguments which will be</span>
<span class="sd">            passed to the mapped function for every evaluation.</span>

<span class="sd">        map_func : callable</span>
<span class="sd">            The mapping function. The implementation of how to map the</span>
<span class="sd">            computation function over the data. Default is the python</span>
<span class="sd">            builtin `map` function. Can be a parallel implementation</span>
<span class="sd">            for example.</span>

<span class="sd">        traj_sel : list of tuple, optional</span>
<span class="sd">            If not None, a list of trajectory identifier tuple</span>
<span class="sd">            (run_idx, traj_idx) to restrict the computation to.</span>

<span class="sd">        idxs : bool</span>
<span class="sd">            If True will return the trajectory identifier tuple</span>
<span class="sd">            (run_idx, traj_idx) along with other return values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        traj_id_tuples : list of tuple of int, if &#39;idxs&#39; option is True</span>
<span class="sd">            A list of the tuple identifiers for each trajectory result.</span>

<span class="sd">        results : list of arraylike</span>
<span class="sd">            A list of arraylike feature vectors for each trajectory.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check the args and kwargs to see if they need expanded for</span>
        <span class="c1"># mapping inputs</span>
        <span class="c1">#first go through each run and get the number of cycles</span>
        <span class="n">n_cycles</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_idxs</span><span class="p">:</span>
            <span class="n">n_cycles</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_run_cycles</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>

        <span class="n">mapped_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="c1"># make a generator out of it to map as inputs</span>
            <span class="n">mapped_arg</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cycles</span><span class="p">))</span>
            <span class="n">mapped_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapped_arg</span><span class="p">)</span>

        <span class="c1"># make a generator for the arguments to pass to the function</span>
        <span class="c1"># from the mapper, for the extra arguments we just have an</span>
        <span class="c1"># endless generator</span>
        <span class="n">map_args</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_trajs_fields</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">traj_sel</span><span class="o">=</span><span class="n">traj_sel</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="o">*</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">))</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">map_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">map_args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">idxs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">traj_sel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">traj_sel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_traj_idx_tuples</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="n">traj_sel</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="WepyHDF5.to_mdtraj"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.to_mdtraj">[docs]</a>    <span class="k">def</span> <span class="nf">to_mdtraj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alt_rep</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a trajectory to an mdtraj Trajectory object.</span>

<span class="sd">        Works if the right trajectory fields are defined. Minimally</span>
<span class="sd">        this is a representation, including the &#39;positions&#39; field or</span>
<span class="sd">        an &#39;alt_rep&#39; subfield.</span>

<span class="sd">        Will also set the unitcell lengths and angle if the</span>
<span class="sd">        &#39;box_vectors&#39; field is present.</span>

<span class="sd">        Will also set the time for the frames if the &#39;time&#39; field is</span>
<span class="sd">        present, although this is likely not useful since walker</span>
<span class="sd">        segments have the time reset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">        traj_idx : int</span>

<span class="sd">        frames : None or list of int</span>
<span class="sd">            If not None, a list of the frames to include.</span>

<span class="sd">        alt_rep : str</span>
<span class="sd">            If not None, an &#39;alt_reps&#39; subfield name to use for</span>
<span class="sd">            positions instead of the &#39;positions&#39; field.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        traj : mdtraj.Trajectory</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">traj_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)</span>

        <span class="c1"># the default for alt_rep is the main rep</span>
        <span class="k">if</span> <span class="n">alt_rep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rep_key</span> <span class="o">=</span> <span class="n">POSITIONS</span>
            <span class="n">rep_path</span> <span class="o">=</span> <span class="n">rep_key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rep_key</span> <span class="o">=</span> <span class="n">alt_rep</span>
            <span class="n">rep_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ALT_REPS</span><span class="p">,</span> <span class="n">alt_rep</span><span class="p">)</span>

        <span class="n">topology</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mdtraj_topology</span><span class="p">(</span><span class="n">alt_rep</span><span class="o">=</span><span class="n">rep_key</span><span class="p">)</span>


        <span class="c1"># get the frames if they are not given</span>
        <span class="k">if</span> <span class="n">frames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_traj_field_cycle_idxs</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">rep_path</span><span class="p">)</span>


        <span class="c1"># get the data for all or for the frames specified</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">rep_path</span><span class="p">,</span>
                                        <span class="n">frames</span><span class="o">=</span><span class="n">frames</span><span class="p">,</span> <span class="n">masked</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">TIME</span><span class="p">,</span>
                                       <span class="n">frames</span><span class="o">=</span><span class="n">frames</span><span class="p">,</span> <span class="n">masked</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;time not in this trajectory, ignoring&quot;</span><span class="p">)</span>
            <span class="n">time</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">box_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">BOX_VECTORS</span><span class="p">,</span>
                                              <span class="n">frames</span><span class="o">=</span><span class="n">frames</span><span class="p">,</span> <span class="n">masked</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;box_vectors not in this trajectory, ignoring&quot;</span><span class="p">)</span>
            <span class="n">box_vectors</span> <span class="o">=</span> <span class="kc">None</span>


        <span class="k">if</span> <span class="n">box_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unitcell_lengths</span><span class="p">,</span> <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="n">traj_box_vectors_to_lengths_angles</span><span class="p">(</span><span class="n">box_vectors</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">box_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">mdj</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">topology</span><span class="p">,</span>
                           <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                           <span class="n">unitcell_lengths</span><span class="o">=</span><span class="n">unitcell_lengths</span><span class="p">,</span> <span class="n">unitcell_angles</span><span class="o">=</span><span class="n">unitcell_angles</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">box_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">mdj</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">topology</span><span class="p">,</span>
                           <span class="n">unitcell_lengths</span><span class="o">=</span><span class="n">unitcell_lengths</span><span class="p">,</span> <span class="n">unitcell_angles</span><span class="o">=</span><span class="n">unitcell_angles</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">mdj</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">topology</span><span class="p">,</span>
                           <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">mdj</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">traj</span></div>

<div class="viewcode-block" id="WepyHDF5.trace_to_mdtraj"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.trace_to_mdtraj">[docs]</a>    <span class="k">def</span> <span class="nf">trace_to_mdtraj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">alt_rep</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate an mdtraj Trajectory from a trace of frames from the runs.</span>

<span class="sd">        Uses the default fields for positions (unless an alternate</span>
<span class="sd">        representation is specified) and box vectors which are assumed</span>
<span class="sd">        to be present in the trajectory fields.</span>

<span class="sd">        The time value for the mdtraj trajectory is set to the cycle</span>
<span class="sd">        indices for each trace frame.</span>

<span class="sd">        This is useful for converting WepyHDF5 data to common</span>
<span class="sd">        molecular dynamics data formats accessible through the mdtraj</span>
<span class="sd">        library.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trace : list of tuple of int</span>
<span class="sd">            The trace values. Each tuple is of the form</span>
<span class="sd">            (run_idx, traj_idx, frame_idx).</span>

<span class="sd">        alt_rep : None or str</span>
<span class="sd">            If None uses default &#39;positions&#39; representation otherwise</span>
<span class="sd">            chooses the representation from the &#39;alt_reps&#39; compound field.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        traj : mdtraj.Trajectory</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rep_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_choose_rep_path</span><span class="p">(</span><span class="n">alt_rep</span><span class="p">)</span>

        <span class="n">trace_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_trace_fields</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="p">[</span><span class="n">rep_path</span><span class="p">,</span> <span class="n">BOX_VECTORS</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_fields_to_mdtraj</span><span class="p">(</span><span class="n">trace_fields</span><span class="p">,</span> <span class="n">alt_rep</span><span class="o">=</span><span class="n">alt_rep</span><span class="p">)</span></div>

<div class="viewcode-block" id="WepyHDF5.run_trace_to_mdtraj"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.run_trace_to_mdtraj">[docs]</a>    <span class="k">def</span> <span class="nf">run_trace_to_mdtraj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">alt_rep</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate an mdtraj Trajectory from a trace of frames from the runs.</span>

<span class="sd">        Uses the default fields for positions (unless an alternate</span>
<span class="sd">        representation is specified) and box vectors which are assumed</span>
<span class="sd">        to be present in the trajectory fields.</span>

<span class="sd">        The time value for the mdtraj trajectory is set to the cycle</span>
<span class="sd">        indices for each trace frame.</span>

<span class="sd">        This is useful for converting WepyHDF5 data to common</span>
<span class="sd">        molecular dynamics data formats accessible through the mdtraj</span>
<span class="sd">        library.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_idx : int</span>
<span class="sd">            The run the trace is over.</span>

<span class="sd">        run_trace : list of tuple of int</span>
<span class="sd">            The trace values. Each tuple is of the form</span>
<span class="sd">            (traj_idx, frame_idx).</span>

<span class="sd">        alt_rep : None or str</span>
<span class="sd">            If None uses default &#39;positions&#39; representation otherwise</span>
<span class="sd">            chooses the representation from the &#39;alt_reps&#39; compound field.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        traj : mdtraj.Trajectory</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rep_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_choose_rep_path</span><span class="p">(</span><span class="n">alt_rep</span><span class="p">)</span>

        <span class="n">trace_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_run_trace_fields</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="p">[</span><span class="n">rep_path</span><span class="p">,</span> <span class="n">BOX_VECTORS</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_fields_to_mdtraj</span><span class="p">(</span><span class="n">trace_fields</span><span class="p">,</span> <span class="n">alt_rep</span><span class="o">=</span><span class="n">alt_rep</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_choose_rep_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alt_rep</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a positions specification string, gets the field name/path</span>
<span class="sd">        for it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        alt_rep : str</span>
<span class="sd">            The short name (non relative path) for a representation of</span>
<span class="sd">            the positions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        rep_path : str</span>
<span class="sd">            The relative field path to that representation.</span>

<span class="sd">        E.g.:</span>

<span class="sd">        If you give it &#39;positions&#39; or None it will simply return</span>
<span class="sd">        &#39;positions&#39;, however if you ask for &#39;all_atoms&#39; it will return</span>
<span class="sd">        &#39;alt_reps/all_atoms&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># the default for alt_rep is the main rep</span>
        <span class="k">if</span> <span class="n">alt_rep</span> <span class="o">==</span> <span class="n">POSITIONS</span><span class="p">:</span>
            <span class="n">rep_path</span> <span class="o">=</span> <span class="n">POSITIONS</span>
        <span class="k">elif</span> <span class="n">alt_rep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rep_key</span> <span class="o">=</span> <span class="n">POSITIONS</span>
            <span class="n">rep_path</span> <span class="o">=</span> <span class="n">rep_key</span>
        <span class="c1"># if it is already a path we don&#39;t add more to it and just</span>
        <span class="c1"># return it.</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_rep</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_rep</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unrecognized alt_rep spec&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">alt_rep</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ALT_REPS</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unrecognized alt_rep spec&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rep_path</span> <span class="o">=</span> <span class="n">alt_rep</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rep_key</span> <span class="o">=</span> <span class="n">alt_rep</span>
            <span class="n">rep_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ALT_REPS</span><span class="p">,</span> <span class="n">alt_rep</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rep_path</span>


<div class="viewcode-block" id="WepyHDF5.traj_fields_to_mdtraj"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.traj_fields_to_mdtraj">[docs]</a>    <span class="k">def</span> <span class="nf">traj_fields_to_mdtraj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traj_fields</span><span class="p">,</span> <span class="n">alt_rep</span><span class="o">=</span><span class="n">POSITIONS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an mdtraj.Trajectory from a traj_fields dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        traj_fields : dict of str : arraylike</span>
<span class="sd">            Dictionary of the traj fields to their values</span>

<span class="sd">        alt_reps : str</span>
<span class="sd">            The base alt rep name for the positions representation to</span>
<span class="sd">            use for the topology, should have the corresponding</span>
<span class="sd">            alt_rep field in the traj_fields</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        traj : mdtraj.Trajectory object</span>

<span class="sd">        This is mainly a convenience function to retrieve the correct</span>
<span class="sd">        topology for the positions which will be passed to the generic</span>
<span class="sd">        `traj_fields_to_mdtraj` function.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rep_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_choose_rep_path</span><span class="p">(</span><span class="n">alt_rep</span><span class="p">)</span>

        <span class="n">json_topology</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_topology</span><span class="p">(</span><span class="n">alt_rep</span><span class="o">=</span><span class="n">rep_path</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">traj_fields_to_mdtraj</span><span class="p">(</span><span class="n">traj_fields</span><span class="p">,</span> <span class="n">json_topology</span><span class="p">,</span> <span class="n">rep_key</span><span class="o">=</span><span class="n">rep_path</span><span class="p">)</span></div>



<div class="viewcode-block" id="WepyHDF5.copy_run_slice"><a class="viewcode-back" href="../../api/wepy.hdf5.html#wepy.hdf5.WepyHDF5.copy_run_slice">[docs]</a>    <span class="k">def</span> <span class="nf">copy_run_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">,</span> <span class="n">target_file_path</span><span class="p">,</span> <span class="n">target_grp_path</span><span class="p">,</span>
                       <span class="n">run_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy this run to another HDF5 file (target_file_path) at the group</span>
<span class="sd">        (target_grp_path)&quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;w-&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">],</span> <span class="s2">&quot;must be opened in write mode&quot;</span>

        <span class="k">if</span> <span class="n">run_slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">run_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">run_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Must be a contiguous slice&quot;</span>

            <span class="c1"># get a list of the frames to use</span>
            <span class="n">slice_frames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">run_slice</span><span class="p">))</span>


        <span class="c1"># we manually construct an HDF5 wrapper and copy the groups over</span>
        <span class="n">new_h5</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">target_file_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">libver</span><span class="o">=</span><span class="n">H5PY_LIBVER</span><span class="p">)</span>

        <span class="c1"># flush the datasets buffers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">new_h5</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="c1"># get the run group we are interested in</span>
        <span class="n">run_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_idx</span><span class="p">)</span>

        <span class="c1"># slice the datasets in the run and set them in the new file</span>
        <span class="k">if</span> <span class="n">run_slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># initialize the group for the run</span>
            <span class="n">new_run_grp</span> <span class="o">=</span> <span class="n">new_h5</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="n">target_grp_path</span><span class="p">)</span>


            <span class="c1"># copy the init walkers group</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">run_grp</span><span class="p">[</span><span class="n">INIT_WALKERS</span><span class="p">],</span> <span class="n">new_run_grp</span><span class="p">,</span>
                         <span class="n">name</span><span class="o">=</span><span class="n">INIT_WALKERS</span><span class="p">)</span>

            <span class="c1"># copy the decision group</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">run_grp</span><span class="p">[</span><span class="n">DECISION</span><span class="p">],</span> <span class="n">new_run_grp</span><span class="p">,</span>
                         <span class="n">name</span><span class="o">=</span><span class="n">DECISION</span><span class="p">)</span>


            <span class="c1"># create the trajectories group</span>
            <span class="n">new_trajs_grp</span> <span class="o">=</span> <span class="n">new_run_grp</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="n">TRAJECTORIES</span><span class="p">)</span>

            <span class="c1"># slice the trajectories and copy them</span>
            <span class="k">for</span> <span class="n">traj_idx</span> <span class="ow">in</span> <span class="n">run_grp</span><span class="p">[</span><span class="n">TRAJECTORIES</span><span class="p">]:</span>

                <span class="n">traj_grp</span> <span class="o">=</span> <span class="n">run_grp</span><span class="p">[</span><span class="n">TRAJECTORIES</span><span class="p">][</span><span class="n">traj_idx</span><span class="p">]</span>

                <span class="n">traj_id</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">TRAJECTORIES</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)</span>

                <span class="n">new_traj_grp</span> <span class="o">=</span> <span class="n">new_trajs_grp</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">traj_idx</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">_iter_field_paths</span><span class="p">(</span><span class="n">run_grp</span><span class="p">[</span><span class="n">traj_id</span><span class="p">]):</span>
                    <span class="n">field_path</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">traj_id</span><span class="p">,</span> <span class="n">field_name</span><span class="p">)</span>

                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_traj_field</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span>
                                               <span class="n">frames</span><span class="o">=</span><span class="n">slice_frames</span><span class="p">)</span>

                    <span class="c1"># if it is a sparse field we need to create the</span>
                    <span class="c1"># dataset differently</span>
                    <span class="k">if</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_fields</span><span class="p">:</span>

                        <span class="c1"># create a group for the field</span>
                        <span class="n">new_field_grp</span> <span class="o">=</span> <span class="n">new_traj_grp</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>

                        <span class="c1"># slice the _sparse_idxs from the original</span>
                        <span class="c1"># dataset that are between the slice</span>
                        <span class="n">cycle_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">(</span><span class="n">run_idx</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)[</span><span class="n">field_name</span><span class="p">][</span><span class="s1">&#39;_sparse_idxs&#39;</span><span class="p">][:]</span>

                        <span class="n">sparse_idx_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                            <span class="n">cycle_idxs</span><span class="p">[:]</span> <span class="o">&gt;=</span> <span class="n">run_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cycle_idxs</span><span class="p">[:]</span> <span class="o">&lt;</span> <span class="n">run_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

                        <span class="c1"># the cycle idxs there is data for</span>
                        <span class="n">sliced_cycle_idxs</span> <span class="o">=</span> <span class="n">cycle_idxs</span><span class="p">[</span><span class="n">sparse_idx_idxs</span><span class="p">]</span>

                        <span class="c1"># get the data for these cycles</span>
                        <span class="n">field_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">sliced_cycle_idxs</span><span class="p">]</span>

                        <span class="c1"># get the information on compression,</span>
                        <span class="c1"># chunking, and filters and use it when we set</span>
                        <span class="c1"># the new data</span>
                        <span class="n">field_data_dset</span> <span class="o">=</span> <span class="n">traj_grp</span><span class="p">[</span><span class="n">field_name</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
                        <span class="n">data_dset_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s1">&#39;chunks&#39;</span> <span class="p">:</span> <span class="n">field_data_dset</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span>
                            <span class="s1">&#39;compression&#39;</span> <span class="p">:</span> <span class="n">field_data_dset</span><span class="o">.</span><span class="n">compression</span><span class="p">,</span>
                            <span class="s1">&#39;compression_opts&#39;</span> <span class="p">:</span> <span class="n">field_data_dset</span><span class="o">.</span><span class="n">compression_opts</span><span class="p">,</span>
                            <span class="s1">&#39;shuffle&#39;</span> <span class="p">:</span> <span class="n">field_data_dset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">,</span>
                            <span class="s1">&#39;fletcher32&#39;</span> <span class="p">:</span> <span class="n">field_data_dset</span><span class="o">.</span><span class="n">fletcher32</span><span class="p">,</span>
                        <span class="p">}</span>

                        <span class="c1"># and for the sparse idxs although it is probably overkill</span>
                        <span class="n">field_idxs_dset</span> <span class="o">=</span> <span class="n">traj_grp</span><span class="p">[</span><span class="n">field_name</span><span class="p">][</span><span class="s1">&#39;_sparse_idxs&#39;</span><span class="p">]</span>
                        <span class="n">idxs_dset_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s1">&#39;chunks&#39;</span> <span class="p">:</span> <span class="n">field_idxs_dset</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span>
                            <span class="s1">&#39;compression&#39;</span> <span class="p">:</span> <span class="n">field_idxs_dset</span><span class="o">.</span><span class="n">compression</span><span class="p">,</span>
                            <span class="s1">&#39;compression_opts&#39;</span> <span class="p">:</span> <span class="n">field_idxs_dset</span><span class="o">.</span><span class="n">compression_opts</span><span class="p">,</span>
                            <span class="s1">&#39;shuffle&#39;</span> <span class="p">:</span> <span class="n">field_idxs_dset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">,</span>
                            <span class="s1">&#39;fletcher32&#39;</span> <span class="p">:</span> <span class="n">field_idxs_dset</span><span class="o">.</span><span class="n">fletcher32</span><span class="p">,</span>
                        <span class="p">}</span>

                        <span class="c1"># then create the datasets</span>
                        <span class="n">new_field_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;_sparse_idxs&#39;</span><span class="p">,</span>
                                                     <span class="n">data</span><span class="o">=</span><span class="n">sliced_cycle_idxs</span><span class="p">,</span>
                                                     <span class="o">**</span><span class="n">idxs_dset_kwargs</span><span class="p">)</span>
                        <span class="n">new_field_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span>
                                                     <span class="n">data</span><span class="o">=</span><span class="n">field_data</span><span class="p">,</span>
                                                     <span class="o">**</span><span class="n">data_dset_kwargs</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>

                        <span class="c1"># get the information on compression,</span>
                        <span class="c1"># chunking, and filters and use it when we set</span>
                        <span class="c1"># the new data</span>
                        <span class="n">field_dset</span> <span class="o">=</span> <span class="n">traj_grp</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>

                        <span class="n">dset_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s1">&#39;chunks&#39;</span> <span class="p">:</span> <span class="n">field_dset</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span>
                            <span class="s1">&#39;compression&#39;</span> <span class="p">:</span> <span class="n">field_dset</span><span class="o">.</span><span class="n">compression</span><span class="p">,</span>
                            <span class="s1">&#39;compression_opts&#39;</span> <span class="p">:</span> <span class="n">field_dset</span><span class="o">.</span><span class="n">compression_opts</span><span class="p">,</span>
                            <span class="s1">&#39;shuffle&#39;</span> <span class="p">:</span> <span class="n">field_dset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">,</span>
                            <span class="s1">&#39;fletcher32&#39;</span> <span class="p">:</span> <span class="n">field_dset</span><span class="o">.</span><span class="n">fletcher32</span><span class="p">,</span>
                        <span class="p">}</span>

                        <span class="c1"># require the dataset first to automatically build</span>
                        <span class="c1"># subpaths for compound fields if necessary</span>
                        <span class="n">dset</span> <span class="o">=</span> <span class="n">new_traj_grp</span><span class="o">.</span><span class="n">require_dataset</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span>
                                                            <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">dset_kwargs</span><span class="p">)</span>

                        <span class="c1"># then set the data depending on whether it is</span>
                        <span class="c1"># sparse or not</span>
                        <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span>

            <span class="c1"># then do it for the records</span>
            <span class="k">for</span> <span class="n">rec_grp_name</span><span class="p">,</span> <span class="n">rec_fields</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="n">rec_grp</span> <span class="o">=</span> <span class="n">run_grp</span><span class="p">[</span><span class="n">rec_grp_name</span><span class="p">]</span>

                <span class="c1"># if this is a contiguous record we can skip the cycle</span>
                <span class="c1"># indices to record indices conversion that is</span>
                <span class="c1"># necessary for sporadic records</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sporadic_records</span><span class="p">(</span><span class="n">rec_grp_name</span><span class="p">):</span>

                    <span class="n">cycle_idxs</span> <span class="o">=</span> <span class="n">rec_grp</span><span class="p">[</span><span class="n">CYCLE_IDXS</span><span class="p">][:]</span>

                    <span class="c1"># get dataset info</span>
                    <span class="n">cycle_idxs_dset</span> <span class="o">=</span> <span class="n">rec_grp</span><span class="p">[</span><span class="n">CYCLE_IDXS</span><span class="p">]</span>

                    <span class="c1"># we use autochunk, because I can&#39;t figure out how</span>
                    <span class="c1"># the chunks are set and I can&#39;t reuse them</span>
                    <span class="n">idxs_dset_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;chunks&#39;</span> <span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="c1"># &#39;chunks&#39; : cycle_idxs_dset.chunks,</span>
                        <span class="s1">&#39;compression&#39;</span> <span class="p">:</span> <span class="n">cycle_idxs_dset</span><span class="o">.</span><span class="n">compression</span><span class="p">,</span>
                        <span class="s1">&#39;compression_opts&#39;</span> <span class="p">:</span> <span class="n">cycle_idxs_dset</span><span class="o">.</span><span class="n">compression_opts</span><span class="p">,</span>
                        <span class="s1">&#39;shuffle&#39;</span> <span class="p">:</span> <span class="n">cycle_idxs_dset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">,</span>
                        <span class="s1">&#39;fletcher32&#39;</span> <span class="p">:</span> <span class="n">cycle_idxs_dset</span><span class="o">.</span><span class="n">fletcher32</span><span class="p">,</span>
                    <span class="p">}</span>

                    <span class="c1"># get the indices of the records we are interested in</span>
                    <span class="n">record_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                        <span class="n">cycle_idxs</span> <span class="o">&gt;=</span> <span class="n">run_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cycle_idxs</span> <span class="o">&lt;</span> <span class="n">run_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

                    <span class="c1"># set the cycle indices in the new run group</span>
                    <span class="n">new_recgrp_cycle_idxs_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/_cycle_idxs&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_grp_path</span><span class="p">,</span>
                                                                            <span class="n">rec_grp_name</span><span class="p">)</span>
                    <span class="n">cycle_data</span> <span class="o">=</span> <span class="n">cycle_idxs</span><span class="p">[</span><span class="n">record_idxs</span><span class="p">]</span>

                    <span class="n">cycle_dset</span> <span class="o">=</span> <span class="n">new_h5</span><span class="o">.</span><span class="n">require_dataset</span><span class="p">(</span><span class="n">new_recgrp_cycle_idxs_path</span><span class="p">,</span>
                                                        <span class="n">cycle_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">cycle_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                                        <span class="o">**</span><span class="n">idxs_dset_kwargs</span><span class="p">)</span>
                    <span class="n">cycle_dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">cycle_data</span>

                <span class="c1"># if contiguous just set the record indices as the</span>
                <span class="c1"># range between the slice</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">record_idxs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">run_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">run_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

                <span class="c1"># then for each rec_field slice those and set them in the new file</span>
                <span class="k">for</span> <span class="n">rec_field</span> <span class="ow">in</span> <span class="n">rec_fields</span><span class="p">:</span>

                    <span class="n">field_dset</span> <span class="o">=</span> <span class="n">rec_grp</span><span class="p">[</span><span class="n">rec_field</span><span class="p">]</span>

                    <span class="c1"># get dataset info</span>
                    <span class="n">field_dset_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;chunks&#39;</span> <span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="c1"># &#39;chunks&#39; : field_dset.chunks,</span>
                        <span class="s1">&#39;compression&#39;</span> <span class="p">:</span> <span class="n">field_dset</span><span class="o">.</span><span class="n">compression</span><span class="p">,</span>
                        <span class="s1">&#39;compression_opts&#39;</span> <span class="p">:</span> <span class="n">field_dset</span><span class="o">.</span><span class="n">compression_opts</span><span class="p">,</span>
                        <span class="s1">&#39;shuffle&#39;</span> <span class="p">:</span> <span class="n">field_dset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">,</span>
                        <span class="s1">&#39;fletcher32&#39;</span> <span class="p">:</span> <span class="n">field_dset</span><span class="o">.</span><span class="n">fletcher32</span><span class="p">,</span>
                    <span class="p">}</span>


                    <span class="n">rec_field_path</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rec_grp_name</span><span class="p">,</span> <span class="n">rec_field</span><span class="p">)</span>
                    <span class="n">new_recfield_grp_path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_grp_path</span><span class="p">,</span> <span class="n">rec_field_path</span><span class="p">)</span>

                    <span class="c1"># if it is a variable length dtype make the dtype</span>
                    <span class="c1"># that for the dataset and we also slice the</span>
                    <span class="c1"># dataset differently</span>
                    <span class="n">vlen_type</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">check_dtype</span><span class="p">(</span><span class="n">vlen</span><span class="o">=</span><span class="n">field_dset</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">vlen_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">special_dtype</span><span class="p">(</span><span class="n">vlen</span><span class="o">=</span><span class="n">vlen_type</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">field_dset</span><span class="o">.</span><span class="n">dtype</span>



                    <span class="c1"># if there are no records don&#39;t attempt to add them</span>
                    <span class="c1"># get the shape</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">record_idxs</span><span class="p">),</span> <span class="o">*</span><span class="n">field_dset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                    <span class="n">new_field_dset</span> <span class="o">=</span> <span class="n">new_h5</span><span class="o">.</span><span class="n">require_dataset</span><span class="p">(</span><span class="n">new_recfield_grp_path</span><span class="p">,</span>
                                                            <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">field_dset_kwargs</span><span class="p">)</span>

                    <span class="c1"># if there aren&#39;t records just don&#39;t do anything,</span>
                    <span class="c1"># and if there are get them and add them</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">record_idxs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">rec_data</span> <span class="o">=</span> <span class="n">field_dset</span><span class="p">[</span><span class="n">record_idxs</span><span class="p">]</span>

                        <span class="c1"># if it is a variable length data type we have</span>
                        <span class="c1"># to do it 1 by 1</span>
                        <span class="k">if</span> <span class="n">vlen_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vlen_rec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rec_data</span><span class="p">):</span>
                                <span class="n">new_field_dset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rec_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="c1"># otherwise just set it all at once</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_field_dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">rec_data</span>

        <span class="c1"># just copy the whole thing over, since this will probably be</span>
        <span class="c1"># more efficient</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># split off the last bit of the target path, for copying we</span>
            <span class="c1"># need it&#39;s parent group but not it to exist</span>
            <span class="n">target_grp_path_basename</span> <span class="o">=</span> <span class="n">target_grp_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">target_grp_path_prefix</span> <span class="o">=</span> <span class="n">target_grp_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">new_run_prefix_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="n">target_grp_path_prefix</span><span class="p">)</span>

            <span class="c1"># copy the whole thing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">run_grp</span><span class="p">,</span> <span class="n">new_run_prefix_grp</span><span class="p">,</span>
                         <span class="n">name</span><span class="o">=</span><span class="n">target_grp_path_basename</span><span class="p">)</span>

        <span class="c1"># flush the datasets buffers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h5</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">new_h5</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">new_h5</span></div></div>
</pre></div>

          </div>
            
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">wepy  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="../../_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2018, Samuel D. Lotz. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>