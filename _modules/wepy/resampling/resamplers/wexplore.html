
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="../../../../_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="../../../../_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="../../../../_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="../../../../_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>wepy.resampling.resamplers.wexplore &#8212; wepy  documentation</title>
    <link rel="stylesheet" href="../../../../_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">wepy  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="../../../../search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="../../../../index.html">Docs</a></li>
              
                <li><a href="../../../index.html">Module code</a></li>
              
              <li>wepy.resampling.resamplers.wexplore</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <h1>Source code for wepy.resampling.resamplers.wexplore</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span> <span class="k">as</span> <span class="nn">rand</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="kn">from</span> <span class="nn">wepy.resampling.resamplers.resampler</span>  <span class="k">import</span> <span class="n">ResamplerError</span>
<span class="kn">from</span> <span class="nn">wepy.resampling.resamplers.clone_merge</span>  <span class="k">import</span> <span class="n">CloneMergeResampler</span>
<span class="kn">from</span> <span class="nn">wepy.resampling.decisions.clone_merge</span> <span class="k">import</span> <span class="n">MultiCloneMergeDecision</span>

<div class="viewcode-block" id="RegionTreeError"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.RegionTreeError">[docs]</a><span class="k">class</span> <span class="nc">RegionTreeError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Errors related to violations of constraints in RegionTree algorithms.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">## Merge methods</span>

<span class="c1"># algorithms for finding the number of mergeable walkers in a group</span>
<div class="viewcode-block" id="calc_squashable_walkers_single_method"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.calc_squashable_walkers_single_method">[docs]</a><span class="k">def</span> <span class="nf">calc_squashable_walkers_single_method</span><span class="p">(</span><span class="n">walker_weights</span><span class="p">,</span> <span class="n">max_weight</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the maximum number of squashable walkers in collection of</span>
<span class="sd">    walkers, that still satisfies the max weight constraint.</span>

<span class="sd">    We don&#39;t guarantee or know if this is a completely optimal solver</span>
<span class="sd">    for this problem but it is assumed to be good enough in practice</span>
<span class="sd">    and no harm comes from underestimating it only a reduced potential</span>
<span class="sd">    performance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    walker_weights : list of float</span>
<span class="sd">        The weights of the walkers</span>

<span class="sd">    max_weight : float</span>
<span class="sd">        The maximum weight a walker can have.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    n_squashable : int</span>
<span class="sd">        The maximum number of squashable walkers.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c1"># to get an estimate of the number of squashable walkers we start</span>
    <span class="c1"># summing the weights starting from the smallest walker. When the</span>
    <span class="c1"># addition of the next highest weight walker would make the total</span>
    <span class="c1"># greater than max_weight then we quit and say that the number of</span>
    <span class="c1"># squashable walkers is the number of them summed up, minus one</span>
    <span class="c1"># for the fact that one of them won&#39;t be squashed if a merge of</span>
    <span class="c1"># all of them was to occur</span>
    <span class="n">n_squashable</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># there must be at least 2 walkers in order to be able to do a</span>
    <span class="c1"># merge, so if there are not enough the number of squashable</span>
    <span class="c1"># walkers is 0</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">walker_weights</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n_squashable</span>


    <span class="c1"># sort the weights smallest to biggest</span>
    <span class="n">walker_weights</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sum_weights</span> <span class="o">=</span> <span class="n">walker_weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">merge_size</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">sum_weights</span> <span class="o">&lt;=</span> <span class="n">max_weight</span><span class="p">:</span>

        <span class="c1"># if the next index would be out of bounds break out of the</span>
        <span class="c1"># loop</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">walker_weights</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># add this walker to the sum weights</span>
        <span class="n">sum_weights</span> <span class="o">+=</span> <span class="n">walker_weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># add one to the merge size (since we only will make our</span>
        <span class="c1"># estimate based on the single largest possible merge)</span>
        <span class="n">merge_size</span> <span class="o">+=</span> <span class="mi">1</span>


    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># the loop condition failed so we remove the last count of</span>
        <span class="c1"># merge size from the merge group. This won&#39;t run if we break</span>
        <span class="c1"># out of the loop because of we are out of walkers to include</span>
        <span class="n">merge_size</span> <span class="o">-=</span> <span class="mi">1</span>


    <span class="c1"># then we also take one less than that as the number of</span>
    <span class="c1"># squashable walkers</span>
    <span class="n">n_squashable</span> <span class="o">=</span> <span class="n">merge_size</span> <span class="o">-</span> <span class="mi">1</span>


    <span class="k">return</span> <span class="n">n_squashable</span></div>


<span class="c1"># algorithms for actually generating the merge groups</span>
<div class="viewcode-block" id="decide_merge_groups_single_method"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.decide_merge_groups_single_method">[docs]</a><span class="k">def</span> <span class="nf">decide_merge_groups_single_method</span><span class="p">(</span><span class="n">walker_weights</span><span class="p">,</span> <span class="n">balance</span><span class="p">,</span> <span class="n">max_weight</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Use the &#39;single&#39; method for determining the merge groups.</span>

<span class="sd">    Determine a solution to the backpack-like problem of assigning</span>
<span class="sd">    squashed walkers to KEEP_MERGE walkers.</span>

<span class="sd">    The single method just assigns all squashed walkers in the</span>
<span class="sd">    collection to a single walker, thus there is a single merge_group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    walker_weights : list of float</span>
<span class="sd">        The weights of the walkers.</span>

<span class="sd">    balance : int</span>
<span class="sd">        The net change in the number of walkers we desire.</span>

<span class="sd">    max_weight : float</span>
<span class="sd">        The maximum weight a single walker can be.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    merge_groups : list of list of int</span>
<span class="sd">        The merge group solution.</span>

<span class="sd">    result : bool</span>
<span class="sd">        Whether the merge group exceeds the max weight.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">balance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;target balance must be negative&quot;</span>

    <span class="c1"># the number of walkers we need to choose in order to be</span>
    <span class="c1"># able to do the required amount of merges</span>
    <span class="n">num_merge_walkers</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">balance</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># select the lowest weight walkers to use for merging, these</span>
    <span class="c1"># are idxs on the mergeable walkers and not the walker_idxs</span>
    <span class="n">chosen_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">walker_weights</span><span class="p">)[:</span><span class="n">num_merge_walkers</span><span class="p">]</span>

    <span class="c1"># check that this is not greater than the max weight</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">walker_weights</span><span class="p">[</span><span class="n">chosen_idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">chosen_idx</span> <span class="ow">in</span> <span class="n">chosen_idxs</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">max_weight</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># return the chosen idxs as the sole full merge group</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">chosen_idxs</span><span class="p">],</span> <span class="n">result</span></div>

<span class="c1">## Clone methods</span>
<div class="viewcode-block" id="calc_max_num_clones"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.calc_max_num_clones">[docs]</a><span class="k">def</span> <span class="nf">calc_max_num_clones</span><span class="p">(</span><span class="n">walker_weight</span><span class="p">,</span> <span class="n">min_weight</span><span class="p">,</span> <span class="n">max_num_walkers</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    walker_weight :</span>
<span class="sd">        </span>
<span class="sd">    min_weight :</span>
<span class="sd">        </span>
<span class="sd">    max_num_walkers :</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># initialize it to no more clones</span>
    <span class="n">max_n_clones</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># start with a two splitting</span>
    <span class="n">n_splits</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1"># then increase it every time it passes or until we get to the</span>
    <span class="c1"># max number of walkers</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">walker_weight</span> <span class="o">/</span> <span class="n">n_splits</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_weight</span><span class="p">)</span> <span class="ow">and</span> \
          <span class="p">(</span><span class="n">n_splits</span> <span class="o">&lt;=</span> <span class="n">max_num_walkers</span><span class="p">):</span>

        <span class="n">n_splits</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># the last step failed so the number of splits is one less</span>
    <span class="c1"># then we counted</span>
    <span class="n">n_splits</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># we want the number of clones so we subtract one from the</span>
    <span class="c1"># number of splits to get that, and we save this for this</span>
    <span class="c1"># walker</span>
    <span class="n">max_n_clones</span> <span class="o">=</span> <span class="n">n_splits</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">max_n_clones</span></div>


<div class="viewcode-block" id="RegionTree"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.RegionTree">[docs]</a><span class="k">class</span> <span class="nc">RegionTree</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used internally in the WExploreResampler module. Not really</span>
<span class="sd">    intended to be used outside this module.&quot;&quot;&quot;</span>

    <span class="c1"># the strings for choosing a method of solving how deciding how</span>
    <span class="c1"># many walkers can be merged together given a group of walkers and</span>
    <span class="c1"># the associated algorithm for actually choosing them</span>
    <span class="n">MERGE_METHODS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;single&#39;</span><span class="p">,)</span>

    <span class="c1"># Description of the methods</span>

    <span class="c1"># &#39;single&#39; : this method simplifies the problem (likely giving</span>
    <span class="c1"># very suboptimal solutions especially early in sampling when</span>
    <span class="c1"># walkers are of similar large weights) by enforcing that within a</span>
    <span class="c1"># group of walkers (i.e. in a leaf region node) only one merge</span>
    <span class="c1"># will take place. To decide how large a given merge group can be</span>
    <span class="c1"># then is simply found by consecutively summing the weights of the</span>
    <span class="c1"># smallest walkers until the inclusion of the next highest</span>
    <span class="c1"># violates the maximum weight. Thus the algorithm for actually</span>
    <span class="c1"># finding the walkers that shall be merged is as simple as taking</span>
    <span class="c1"># the K lowest walkers given by the first algorithm. This is then</span>
    <span class="c1"># guaranteed to satisfy the potential.</span>

    <span class="c1"># as further methods are mathematically proven and algorithms</span>
    <span class="c1"># designed this will be the chosen method.</span>

    <span class="n">ROOT_NODE</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_state</span><span class="p">,</span>
                 <span class="n">max_n_regions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">max_region_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">merge_method</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">max_n_regions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="n">max_region_sizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="n">distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="n">pmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="n">pmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All parameters must be defined, 1 or more are missing.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_max_n_regions</span> <span class="o">=</span> <span class="n">max_n_regions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_n_regions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_region_sizes</span> <span class="o">=</span> <span class="n">max_region_sizes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pmin</span> <span class="o">=</span> <span class="n">pmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pmax</span> <span class="o">=</span> <span class="n">pmax</span>

        <span class="c1"># initialize the max and min number of walkers, this is a</span>
        <span class="c1"># dynamic thing and is manually set by the WExploreResampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_num_walkers</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_num_walkers</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">assert</span> <span class="n">merge_method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">MERGE_METHODS</span><span class="p">,</span> \
            <span class="s2">&quot;the merge method given, &#39;</span><span class="si">{}</span><span class="s2">&#39;, must be one of the methods available </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">merge_method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MERGE_METHODS</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_method</span> <span class="o">=</span> <span class="n">merge_method</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_walker_weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_walker_assignments</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">image_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># get the image using the distance object</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="n">init_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">image</span><span class="p">]</span>

        <span class="n">parent_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROOT_NODE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">parent_id</span><span class="p">,</span> <span class="n">image_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                      <span class="n">n_walkers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                      <span class="n">n_squashable</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                      <span class="n">n_possible_clones</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                      <span class="n">balance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                      <span class="n">walker_idxs</span><span class="o">=</span><span class="p">[])</span>

        <span class="c1"># make the first branch</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">max_n_regions</span><span class="p">)):</span>
            <span class="n">child_id</span> <span class="o">=</span> <span class="n">parent_id</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">child_id</span><span class="p">,</span> <span class="n">image_idx</span><span class="o">=</span><span class="n">image_idx</span><span class="p">,</span>
                          <span class="n">n_walkers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">n_squashable</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">n_possible_clones</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">balance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">walker_idxs</span><span class="o">=</span><span class="p">[])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">parent_id</span><span class="p">,</span> <span class="n">child_id</span><span class="p">)</span>
            <span class="n">parent_id</span> <span class="o">=</span> <span class="n">child_id</span>

        <span class="c1"># add the region for this branch to the regions list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_regions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_levels</span><span class="p">)])]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">merge_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_method</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">images</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_images</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_n_regions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_n_regions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_levels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_region_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_region_sizes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pmin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pmin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pmax</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">walker_assignments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_walker_assignments</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">walker_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_walker_weights</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">regions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regions</span>

<div class="viewcode-block" id="RegionTree.add_child"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.RegionTree.add_child">[docs]</a>    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_id</span><span class="p">,</span> <span class="n">image_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent_id :</span>
<span class="sd">            </span>
<span class="sd">        image_idx :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make a new child id which will be the next index of the</span>
        <span class="c1"># child with the parent id</span>
        <span class="n">child_id</span> <span class="o">=</span> <span class="n">parent_id</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">parent_id</span><span class="p">)),</span> <span class="p">)</span>

        <span class="c1"># create the node with the image_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">child_id</span><span class="p">,</span>
                      <span class="n">image_idx</span><span class="o">=</span><span class="n">image_idx</span><span class="p">,</span>
                      <span class="n">n_walkers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                      <span class="n">n_squashable</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                      <span class="n">n_possible_clones</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                      <span class="n">balance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                      <span class="n">walker_idxs</span><span class="o">=</span><span class="p">[])</span>

        <span class="c1"># make the edge to the child</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">parent_id</span><span class="p">,</span> <span class="n">child_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">child_id</span></div>

<div class="viewcode-block" id="RegionTree.children"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.RegionTree.children">[docs]</a>    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent_id :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">children_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">parent_id</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># sort them</span>
        <span class="n">children_ids</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">children_ids</span></div>

<div class="viewcode-block" id="RegionTree.level_nodes"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.RegionTree.level_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">level_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the nodes/regions at the specified level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_levels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;level is greater than the number of levels for this tree&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">node_id</span> <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">level</span><span class="p">]</span></div>

<div class="viewcode-block" id="RegionTree.leaf_nodes"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.RegionTree.leaf_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">leaf_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">level_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_levels</span><span class="p">)</span></div>

<div class="viewcode-block" id="RegionTree.branch_tree"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.RegionTree.branch_tree">[docs]</a>    <span class="k">def</span> <span class="nf">branch_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_id</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent_id :</span>
<span class="sd">            </span>
<span class="sd">        image :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add the new image to the image index</span>
        <span class="n">image_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_images</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="n">branch_level</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent_id</span><span class="p">)</span>
        <span class="c1"># go down from there and create children</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">branch_level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_levels</span><span class="p">):</span>
            <span class="n">child_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">parent_id</span><span class="p">,</span> <span class="n">image_idx</span><span class="p">)</span>
            <span class="n">parent_id</span> <span class="o">=</span> <span class="n">child_id</span>

        <span class="c1">#add new assignment  to the image assignments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_regions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child_id</span><span class="p">)</span>
        <span class="c1"># return the leaf node id of the new branch</span>
        <span class="k">return</span> <span class="n">child_id</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_num_walkers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_num_walkers</span>

    <span class="nd">@max_num_walkers</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">max_num_walkers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_num_walkers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This must be an integer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_num_walkers :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_max_num_walkers</span> <span class="o">=</span> <span class="n">max_num_walkers</span>

    <span class="nd">@max_num_walkers</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">max_num_walkers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_num_walkers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This must be an integer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_num_walkers :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_max_num_walkers</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_num_walkers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_num_walkers</span>

    <span class="nd">@min_num_walkers</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">min_num_walkers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_num_walkers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This must be an integer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_num_walkers :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_min_num_walkers</span> <span class="o">=</span> <span class="n">min_num_walkers</span>

    <span class="nd">@min_num_walkers</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">min_num_walkers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_num_walkers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This must be an integer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_num_walkers :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_min_num_walkers</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="RegionTree.assign"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.RegionTree.assign">[docs]</a>    <span class="k">def</span> <span class="nf">assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">assignment</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># a cache for the distance calculations so they need not be</span>
        <span class="c1"># performed more than once</span>
        <span class="n">dist_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># perform a n-ary search through the hierarchy of regions by</span>
        <span class="c1"># performing a distance calculation to the images at each</span>
        <span class="c1"># level starting at the top</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROOT_NODE</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_levels</span><span class="p">):</span>
            <span class="n">level_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="c1"># perform a distance calculation to all nodes at this</span>
            <span class="c1"># level</span>
            <span class="n">image_dists</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">level_node</span> <span class="ow">in</span> <span class="n">level_nodes</span><span class="p">:</span>

                <span class="c1"># get the image</span>
                <span class="n">image_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">level_node</span><span class="p">][</span><span class="s1">&#39;image_idx&#39;</span><span class="p">]</span>
                <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="n">image_idx</span><span class="p">]</span>

                <span class="c1"># if this distance is already calculated don&#39;t</span>
                <span class="c1"># calculate it again and just get it from the cache</span>
                <span class="k">if</span> <span class="n">image_idx</span> <span class="ow">in</span> <span class="n">dist_cache</span><span class="p">:</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">dist_cache</span><span class="p">[</span><span class="n">image_idx</span><span class="p">]</span>
                <span class="c1"># otherwise calculate it and save it in the cache</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># image of the state</span>
                    <span class="n">state_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

                    <span class="c1"># there is the possibility of</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">image_distance</span><span class="p">(</span><span class="n">state_image</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;state: &quot;</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">())</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;state_image: &quot;</span><span class="p">,</span> <span class="n">state_image</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;image: &quot;</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If you have triggered this error you have&quot;</span>
                                         <span class="s2">&quot; encountered a rare bug. Please attempt to&quot;</span>
                                         <span class="s2">&quot; report this using the printed outputs.&quot;</span><span class="p">)</span>

                    <span class="c1"># save in the dist_cache</span>
                    <span class="n">dist_cache</span><span class="p">[</span><span class="n">image_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span>

                <span class="c1"># add it to the dists for this state</span>
                <span class="n">image_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

            <span class="c1"># get the index of the image that is closest</span>
            <span class="n">level_closest_child_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">image_dists</span><span class="p">)</span>
            <span class="c1"># get the distance for the closest image</span>
            <span class="n">level_closest_image_dist</span> <span class="o">=</span> <span class="n">image_dists</span><span class="p">[</span><span class="n">level_closest_child_idx</span><span class="p">]</span>

            <span class="c1"># save for return</span>
            <span class="n">assignment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">level_closest_child_idx</span><span class="p">)</span>
            <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">level_closest_image_dist</span><span class="p">)</span>

            <span class="c1"># set this node as the next node</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">level_nodes</span><span class="p">[</span><span class="n">level_closest_child_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">assignment</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span></div>

<div class="viewcode-block" id="RegionTree.clear_walkers"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.RegionTree.clear_walkers">[docs]</a>    <span class="k">def</span> <span class="nf">clear_walkers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all walkers from the regions.&quot;&quot;&quot;</span>

        <span class="c1"># reset the walker assignments to an empty list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_walker_assignments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_walker_weights</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># set all the node attributes to their defaults</span>
        <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;n_walkers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;walker_idxs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;n_squashable&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;n_possible_clones&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;balance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="RegionTree.place_walkers"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.RegionTree.place_walkers">[docs]</a>    <span class="k">def</span> <span class="nf">place_walkers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walkers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        walkers :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># clear all the walkers and reset node attributes to defaults</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_walkers</span><span class="p">()</span>

        <span class="c1"># keep track of new branches made</span>
        <span class="n">new_branches</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># place each walker</span>
        <span class="k">for</span> <span class="n">walker_idx</span><span class="p">,</span> <span class="n">walker</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">walkers</span><span class="p">):</span>

            <span class="c1"># assign the state of the walker to the tree and get the</span>
            <span class="c1"># distances to the images at each level</span>
            <span class="n">assignment</span><span class="p">,</span> <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">walker</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>

            <span class="c1"># check the distances going down the levels to see if a</span>
            <span class="c1"># branching (region creation) is necessary</span>
            <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distances</span><span class="p">):</span>

                <span class="c1"># if we are over the max region distance and we are</span>
                <span class="c1"># not above max number of regions we have found a new</span>
                <span class="c1"># region so we branch the region_tree at that level</span>
                <span class="k">if</span> <span class="n">distance</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_region_sizes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="ow">and</span> \
                   <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">assignment</span><span class="p">[:</span><span class="n">level</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_n_regions</span><span class="p">[</span><span class="n">level</span><span class="p">]:</span>

                    <span class="c1"># make an image for the region</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="n">walker</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
                    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">assignment</span><span class="p">[:</span><span class="n">level</span><span class="p">]</span>

                    <span class="c1"># make the new branch</span>
                    <span class="n">assignment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_tree</span><span class="p">(</span><span class="n">parent_id</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

                    <span class="c1"># save it to keep track of new branches as they occur</span>
                    <span class="n">new_branches</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;distance&#39;</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">distance</span><span class="p">]),</span>
                                         <span class="s1">&#39;branching_level&#39;</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">level</span><span class="p">]),</span>
                                         <span class="s1">&#39;new_leaf_id&#39;</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">assignment</span><span class="p">),</span>
                                         <span class="s1">&#39;image&#39;</span> <span class="p">:</span> <span class="n">image</span><span class="p">,})</span>

                    <span class="c1"># we have made a new branch so we don&#39;t need to</span>
                    <span class="c1"># continue this loop</span>
                    <span class="k">break</span>

            <span class="c1"># save the walker assignment</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_walker_assignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assignment</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_walker_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">walker</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>

            <span class="c1"># go back through the nodes in this walker&#39;s branch</span>
            <span class="c1"># increase the n_walkers for each node, and save the</span>
            <span class="c1"># walkers (index in self.walker_assignments) it has, and</span>
            <span class="c1"># save increase the number above pmin if valid</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">assignment</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">node_id</span> <span class="o">=</span> <span class="n">assignment</span><span class="p">[:</span><span class="n">level</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;n_walkers&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;walker_idxs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">walker_idx</span><span class="p">)</span>

        <span class="c1"># We also want to find out some details about the ability of</span>
        <span class="c1"># the leaf nodes to clone and merge walkers. This is useful</span>
        <span class="c1"># for being able to balance the tree. Once this has been</span>
        <span class="c1"># figured out for the leaf nodes we want to aggregate these</span>
        <span class="c1"># numbers for the higher level regions</span>
        <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">():</span>

            <span class="n">leaf_walker_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;walker_idxs&#39;</span><span class="p">]</span>
            <span class="n">leaf_weights</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">walker_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">leaf_walker_idxs</span><span class="p">]</span>

            <span class="c1"># first figure out how many walkers are squashable (AKA</span>
            <span class="c1"># reducible)</span>
            <span class="n">n_squashable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_squashable_walkers</span><span class="p">(</span><span class="n">leaf_weights</span><span class="p">)</span>

            <span class="c1"># get the max number of clones for each walker and sum</span>
            <span class="c1"># them up to get the total number of cloneable walkers</span>
            <span class="n">walker_max_n_clones</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_calc_max_num_clones</span><span class="p">(</span><span class="n">walker_weight</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">walker_weight</span> <span class="ow">in</span> <span class="n">leaf_weights</span><span class="p">]</span>
            <span class="n">n_possible_clones</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">walker_max_n_clones</span><span class="p">)</span>

            <span class="c1"># actually set them as attributes for the node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;n_squashable&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_squashable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;n_possible_clones&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_possible_clones</span>

            <span class="c1"># also add this amount to all of the nodes above it</span>

            <span class="c1"># n_squashable</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_levels</span><span class="p">)):</span>
                <span class="n">branch_node_id</span> <span class="o">=</span> <span class="n">node_id</span><span class="p">[:</span><span class="n">level</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">branch_node_id</span><span class="p">][</span><span class="s1">&#39;n_squashable&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n_squashable</span>

            <span class="c1"># n_posssible_clones</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_levels</span><span class="p">)):</span>
                <span class="n">branch_node_id</span> <span class="o">=</span> <span class="n">node_id</span><span class="p">[:</span><span class="n">level</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">branch_node_id</span><span class="p">][</span><span class="s1">&#39;n_possible_clones&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n_possible_clones</span>

        <span class="k">return</span> <span class="n">new_branches</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_max_n_merges</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">pmax</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pmax :</span>
<span class="sd">            </span>
<span class="sd">        root :</span>
<span class="sd">            </span>
<span class="sd">        weights :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># indices of the weights</span>
        <span class="n">walker_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">weights</span><span class="p">)]</span>

        <span class="c1"># remove the root from the weights</span>
        <span class="n">unused_walker_idxs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">walker_idxs</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

        <span class="c1"># initialize the number of merges identified by the length of</span>
        <span class="c1"># the current root</span>
        <span class="n">max_n_merges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>


        <span class="c1"># then combine the root with the unused weights</span>
        <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">merge_candidate</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="n">root</span><span class="p">],</span> <span class="n">unused_walker_idxs</span><span class="p">):</span>

            <span class="c1"># get the weights for this combo</span>
            <span class="n">combo_weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">root</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">weights</span><span class="p">[</span><span class="n">merge_candidate</span><span class="p">]]</span>

            <span class="c1"># sum them</span>
            <span class="n">sum_weight</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">combo_weights</span><span class="p">)</span>

            <span class="c1"># if the sum of the weights is less than or equal than the</span>
            <span class="c1"># pmax then this combination beats the current record of</span>
            <span class="c1"># the root</span>
            <span class="k">if</span> <span class="n">sum_weight</span> <span class="o">&lt;=</span> <span class="n">pmax</span><span class="p">:</span>

                <span class="c1"># then we know that the number of merges is at least</span>
                <span class="c1"># one more than the root</span>
                <span class="n">max_n_merges</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># if we still haven&#39;t reached the pmax continue making</span>
                <span class="c1"># merges to see if we can beat this record</span>
                <span class="k">if</span> <span class="n">sum_weight</span> <span class="o">&lt;</span> <span class="n">pmax</span><span class="p">:</span>

                    <span class="c1"># make a new root for this combo and recursively call</span>
                    <span class="c1"># this method</span>
                    <span class="n">new_combo</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">merge_candidate</span><span class="p">,)</span>

                    <span class="c1"># this will return the maximum number of merges from</span>
                    <span class="c1"># this subset of the walkers</span>
                    <span class="n">n_merges</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_max_n_merges</span><span class="p">(</span><span class="n">pmax</span><span class="p">,</span> <span class="n">new_combo</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

                    <span class="c1"># if this is greater than the current record</span>
                    <span class="c1"># overwrite it</span>
                    <span class="k">if</span> <span class="n">n_merges</span> <span class="o">&gt;</span> <span class="n">max_n_merges</span><span class="p">:</span>
                        <span class="n">max_n_merges</span> <span class="o">=</span> <span class="n">n_merges</span>

                <span class="c1"># if it is exactly pmax then no more merges can be</span>
                <span class="c1"># done so we can just end here and return this record</span>
                <span class="k">elif</span> <span class="n">sum_weight</span> <span class="o">==</span> <span class="n">pmax</span><span class="p">:</span>
                    <span class="k">break</span>


        <span class="c1"># if no combination of this root and other candidates can make</span>
        <span class="c1"># any more merges than we just return the roots number of merges</span>

        <span class="k">return</span> <span class="n">max_n_merges</span>

    <span class="k">def</span> <span class="nf">_calc_squashable_walkers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walker_weights</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        walker_weights :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_method</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
            <span class="n">n_squashable</span> <span class="o">=</span> <span class="n">calc_squashable_walkers_single_method</span><span class="p">(</span><span class="n">walker_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;merge method </span><span class="si">{}</span><span class="s2"> not recognized&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merge_method</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">n_squashable</span>

    <span class="k">def</span> <span class="nf">_calc_max_num_clones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walker_weight</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        walker_weight :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">calc_max_num_clones</span><span class="p">(</span><span class="n">walker_weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_walkers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_propagate_and_balance_shares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parental_balance</span><span class="p">,</span> <span class="n">children_node_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parental_balance :</span>
<span class="sd">            </span>
<span class="sd">        children_node_ids :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># talk about &quot;shares&quot; which basically are the number of</span>
        <span class="c1"># slots/replicas that will be allocated to this region for</span>
        <span class="c1"># running sampling on</span>

        <span class="c1"># we get the current number of shares for each child</span>
        <span class="n">orig_children_shares</span> <span class="o">=</span> <span class="p">{</span><span class="n">child_id</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">child_id</span><span class="p">][</span><span class="s1">&#39;walker_idxs&#39;</span><span class="p">])</span>
                           <span class="k">for</span> <span class="n">child_id</span> <span class="ow">in</span> <span class="n">children_node_ids</span><span class="p">}</span>

        <span class="c1"># the copy to use as a tally of the shares</span>
        <span class="n">children_shares</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">orig_children_shares</span><span class="p">)</span>

        <span class="c1"># the donatable (squashable) walkers to start with</span>
        <span class="n">children_donatable_shares</span> <span class="o">=</span> <span class="p">{</span><span class="n">child_id</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">child_id</span><span class="p">][</span><span class="s1">&#39;n_squashable&#39;</span><span class="p">]</span>
                                     <span class="k">for</span> <span class="n">child_id</span> <span class="ow">in</span> <span class="n">children_node_ids</span><span class="p">}</span>

        <span class="c1"># the donatable (squashable) walkers to start with</span>
        <span class="n">children_receivable_shares</span> <span class="o">=</span> <span class="p">{</span><span class="n">child_id</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">child_id</span><span class="p">][</span><span class="s1">&#39;n_possible_clones&#39;</span><span class="p">]</span>
                                     <span class="k">for</span> <span class="n">child_id</span> <span class="ow">in</span> <span class="n">children_node_ids</span><span class="p">}</span>

        <span class="c1"># Our first goal in this subroutine is to dispense a parental</span>
        <span class="c1"># balance to it&#39;s children in a simply valid manner</span>
        <span class="n">children_dispensations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispense_parental_shares</span><span class="p">(</span>
                                           <span class="n">parental_balance</span><span class="p">,</span> <span class="n">children_shares</span><span class="p">,</span>
                                           <span class="n">children_donatable_shares</span><span class="p">,</span>
                                           <span class="n">children_receivable_shares</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child_id</span><span class="p">,</span> <span class="n">dispensation</span> <span class="ow">in</span> <span class="n">children_dispensations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># update the shares, donatables, and receivables which we</span>
            <span class="c1"># will then balance between regions</span>
            <span class="n">children_shares</span><span class="p">[</span><span class="n">child_id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dispensation</span>


            <span class="c1"># add the dispensation to the number of the donatable</span>
            <span class="c1"># shares</span>
            <span class="n">children_donatable_shares</span><span class="p">[</span><span class="n">child_id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dispensation</span>

            <span class="c1"># subtract the dispensation from the number of receivable</span>
            <span class="c1"># shares</span>
            <span class="n">children_receivable_shares</span><span class="p">[</span><span class="n">child_id</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dispensation</span>

        <span class="c1"># Now that we have dispensed the shares to the children in a</span>
        <span class="c1"># valid way we use an algorithm to now distribute the shares</span>
        <span class="c1"># between the regions as evenly as possible</span>
        <span class="n">children_shares</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_balance_children_shares</span><span class="p">(</span><span class="n">children_shares</span><span class="p">,</span>
                                                        <span class="n">children_donatable_shares</span><span class="p">,</span>
                                                        <span class="n">children_receivable_shares</span><span class="p">)</span>


        <span class="c1"># calculate the net change in the balances for each region</span>
        <span class="n">net_balances</span> <span class="o">=</span> <span class="p">{</span><span class="n">child_id</span> <span class="p">:</span> <span class="n">children_shares</span><span class="p">[</span><span class="n">child_id</span><span class="p">]</span> <span class="o">-</span> <span class="n">orig_children_shares</span><span class="p">[</span><span class="n">child_id</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">child_id</span> <span class="ow">in</span> <span class="n">children_shares</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

        <span class="n">children_balances</span> <span class="o">=</span> <span class="p">[</span><span class="n">balance</span> <span class="k">for</span> <span class="n">balance</span> <span class="ow">in</span> <span class="n">net_balances</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">children_balances</span><span class="p">)</span> <span class="o">!=</span> <span class="n">parental_balance</span><span class="p">:</span>

            <span class="k">raise</span> <span class="n">RegionTreeError</span><span class="p">(</span>
                <span class="s2">&quot;The balances of the child nodes (</span><span class="si">{}</span><span class="s2">) do not balance to the parental balance (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">children_balances</span><span class="p">,</span> <span class="n">parental_balance</span><span class="p">))</span>

        <span class="c1"># no state changes to the object have been made up until this</span>
        <span class="c1"># point, but now that the net change in the balances for the</span>
        <span class="c1"># children have been generated we set them into their nodes</span>
        <span class="k">for</span> <span class="n">child_node_id</span><span class="p">,</span> <span class="n">child_net_balance</span> <span class="ow">in</span> <span class="n">net_balances</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">child_node_id</span><span class="p">][</span><span class="s1">&#39;balance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">child_net_balance</span>


    <span class="k">def</span> <span class="nf">_dispense_parental_shares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parental_balance</span><span class="p">,</span> <span class="n">children_shares</span><span class="p">,</span>
                                  <span class="n">children_donatable_shares</span><span class="p">,</span>
                                  <span class="n">children_receivable_shares</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a parental balance and a set of children nodes, we dispense</span>
<span class="sd">        the shares indicated by the balance to the children nodes in a</span>
<span class="sd">        VALID but not necessarily optimal or desirable way. This</span>
<span class="sd">        merely checks for the hard constraints on the number of shares</span>
<span class="sd">        a region can either give or receive based on their capacity to</span>
<span class="sd">        clone and merge walkers.</span>
<span class="sd">        </span>
<span class="sd">        An additional balancing step can be performed to redistribute them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parental_balance :</span>
<span class="sd">            </span>
<span class="sd">        children_shares :</span>
<span class="sd">            </span>
<span class="sd">        children_donatable_shares :</span>
<span class="sd">            </span>
<span class="sd">        children_receivable_shares :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># this will be the totaled up dispensations for each child</span>
        <span class="c1"># region</span>
        <span class="n">children_dispensations</span> <span class="o">=</span> <span class="p">{</span><span class="n">child_id</span> <span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">child_id</span> <span class="ow">in</span> <span class="n">children_shares</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

        <span class="c1"># if there is only one child it just inherits all of the</span>
        <span class="c1"># balance no matter what</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children_shares</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">child_node_id</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">children_shares</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># we put the shares for this only child in a dictionary</span>
            <span class="c1"># like the other methods would produce</span>
            <span class="n">children_dispensations</span><span class="p">[</span><span class="n">child_node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">parental_balance</span>

        <span class="c1"># there are more than one child so we accredit balances</span>
        <span class="c1"># between them</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">children_shares</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="c1"># if the parent has a non-zero balance we either</span>
            <span class="c1"># increase (clone) or decrease (merge) the balance</span>

            <span class="c1"># these poor children are inheriting a debt and must</span>
            <span class="c1"># decrease the total number of their shares :(</span>
            <span class="k">if</span> <span class="n">parental_balance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="n">children_dispensations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispense_debit_shares</span><span class="p">(</span><span class="n">parental_balance</span><span class="p">,</span>
                                                                     <span class="n">children_shares</span><span class="p">,</span>
                                                                     <span class="n">children_donatable_shares</span><span class="p">)</span>

            <span class="c1"># these lucky children are inheriting a positive number of</span>
            <span class="c1"># shares!! :)</span>
            <span class="k">elif</span> <span class="n">parental_balance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="n">children_dispensations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispense_credit_shares</span><span class="p">(</span><span class="n">parental_balance</span><span class="p">,</span>
                                                                      <span class="n">children_shares</span><span class="p">,</span>
                                                                      <span class="n">children_receivable_shares</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RegionTreeError</span><span class="p">(</span><span class="s2">&quot;no children nodes to give parental balance&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">children_dispensations</span>

    <span class="k">def</span> <span class="nf">_dispense_debit_shares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parental_balance</span><span class="p">,</span> <span class="n">children_shares</span><span class="p">,</span>
                               <span class="n">children_donatable_shares</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For a negative parental balance we dispense it to the children</span>
<span class="sd">        nodes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parental_balance :</span>
<span class="sd">            </span>
<span class="sd">        children_shares :</span>
<span class="sd">            </span>
<span class="sd">        children_donatable_shares :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">children_donatable_shares</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">children_donatable_shares</span><span class="p">)</span>

        <span class="n">children_dispensations</span> <span class="o">=</span> <span class="p">{</span><span class="n">child_id</span> <span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">child_id</span> <span class="ow">in</span> <span class="n">children_shares</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

        <span class="c1"># list of the keys so we can iterate through them</span>
        <span class="n">children_node_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">children_shares</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># dispense the negative shares as quickly as possible,</span>
        <span class="c1"># they will be balanced later</span>
        <span class="n">child_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">children_node_ids</span><span class="p">)</span>
        <span class="n">remaining_balance</span> <span class="o">=</span> <span class="n">parental_balance</span>
        <span class="k">while</span> <span class="n">remaining_balance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># get the node id</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">child_node_id</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">child_iter</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="c1"># if the parental balance is still not zero and there</span>
                <span class="c1"># are no more children then the children cannot</span>
                <span class="c1"># balance it given their constraints and there is an</span>
                <span class="c1"># error</span>
                <span class="k">raise</span> <span class="n">RegionTreeError</span><span class="p">(</span><span class="s2">&quot;Children cannot pay their parent&#39;s debt&quot;</span><span class="p">)</span>

            <span class="n">n_donatable</span> <span class="o">=</span> <span class="n">children_donatable_shares</span><span class="p">[</span><span class="n">child_node_id</span><span class="p">]</span>

            <span class="c1"># if this child has any squashable walkers</span>
            <span class="k">if</span> <span class="n">n_donatable</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># we use those for paying the parent&#39;s debt</span>

                <span class="c1"># the amount of the parental debt that can be</span>
                <span class="c1"># paid (the payment) for this child region is</span>
                <span class="c1"># either the number of squashable walkers or</span>
                <span class="c1"># the absolute value of the parental balance</span>
                <span class="c1"># (since it is negative for debts), whichever</span>
                <span class="c1"># is smaller</span>
                <span class="n">payment</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_donatable</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">remaining_balance</span><span class="p">))</span>

                <span class="c1"># take this from the remaining balance</span>
                <span class="n">remaining_balance</span> <span class="o">+=</span> <span class="n">payment</span>

                <span class="c1"># and take it away from the childs due balance and shares</span>
                <span class="n">children_dispensations</span><span class="p">[</span><span class="n">child_node_id</span><span class="p">]</span> <span class="o">-=</span> <span class="n">payment</span>

                <span class="c1"># also account for that in its donatable shares</span>
                <span class="n">children_donatable_shares</span><span class="p">[</span><span class="n">child_node_id</span><span class="p">]</span> <span class="o">-=</span> <span class="n">payment</span>

        <span class="c1"># double check the balance is precisely 0, we want to</span>
        <span class="c1"># dispense all the shares as well as not accidentally</span>
        <span class="c1"># overdispensing</span>
        <span class="k">assert</span> <span class="n">remaining_balance</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;balance is not 0&quot;</span>


        <span class="k">return</span> <span class="n">children_dispensations</span>

    <span class="k">def</span> <span class="nf">_dispense_credit_shares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parental_balance</span><span class="p">,</span> <span class="n">children_shares</span><span class="p">,</span>
                                <span class="n">children_receivable_shares</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parental_balance :</span>
<span class="sd">            </span>
<span class="sd">        children_shares :</span>
<span class="sd">            </span>
<span class="sd">        children_receivable_shares :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">children_receivable_shares</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">children_receivable_shares</span><span class="p">)</span>

        <span class="n">children_dispensations</span> <span class="o">=</span> <span class="p">{</span><span class="n">child_id</span> <span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">child_id</span> <span class="ow">in</span> <span class="n">children_shares</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

        <span class="c1"># list of the keys so we can iterate through them</span>
        <span class="n">children_node_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">children_shares</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># dispense the shares to the able children as quickly</span>
        <span class="c1"># as possible, they will be redistributed in the next</span>
        <span class="c1"># step</span>
        <span class="n">child_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">children_node_ids</span><span class="p">)</span>
        <span class="n">remaining_balance</span> <span class="o">=</span> <span class="n">parental_balance</span>
        <span class="k">while</span> <span class="n">remaining_balance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># get the node id</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">child_node_id</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">child_iter</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="c1"># if the parental balance is still not zero and there</span>
                <span class="c1"># are no more children then the children cannot</span>
                <span class="c1"># balance it given their constraints and there is an</span>
                <span class="c1"># error</span>
                <span class="k">raise</span> <span class="n">RegionTreeError</span><span class="p">(</span><span class="s2">&quot;Children cannot accept their parent&#39;s credit&quot;</span><span class="p">)</span>

            <span class="c1"># give as much of the parental balance as we can</span>
            <span class="c1"># to the walkers. In the next step all this</span>
            <span class="c1"># balance will be shared among the children so all</span>
            <span class="c1"># we need to do is dispense all the shares without</span>
            <span class="c1"># care as to who gets them, as long as they can</span>
            <span class="c1"># keep it</span>
            <span class="n">n_receivable</span> <span class="o">=</span> <span class="n">children_receivable_shares</span><span class="p">[</span><span class="n">child_node_id</span><span class="p">]</span>

            <span class="c1"># the amount to be disbursed to this region is</span>
            <span class="c1"># either the number of possible clones (the</span>
            <span class="c1"># maximum it can receive) or the full parental</span>
            <span class="c1"># balance, whichever is smaller</span>
            <span class="n">disbursement</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_receivable</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">remaining_balance</span><span class="p">))</span>

            <span class="c1"># give this disbursement by taking away from the</span>
            <span class="c1"># positive balance</span>
            <span class="n">remaining_balance</span> <span class="o">-=</span> <span class="n">disbursement</span>

            <span class="c1"># add these shares to the net balances and share</span>
            <span class="c1"># totals</span>
            <span class="n">children_dispensations</span><span class="p">[</span><span class="n">child_node_id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">disbursement</span>

            <span class="c1"># also subtract this from the number of receivable shares</span>
            <span class="c1"># for the child</span>
            <span class="n">children_receivable_shares</span><span class="p">[</span><span class="n">child_node_id</span><span class="p">]</span> <span class="o">-=</span> <span class="n">disbursement</span>

        <span class="c1"># double check the balance is precisely 0, we want to</span>
        <span class="c1"># dispense all the shares as well as not accidentally</span>
        <span class="c1"># overdispensing</span>
        <span class="k">assert</span> <span class="n">remaining_balance</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;balance is not 0&quot;</span>

        <span class="k">return</span> <span class="n">children_dispensations</span>

    <span class="k">def</span> <span class="nf">_balance_children_shares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children_shares</span><span class="p">,</span>
                                 <span class="n">children_donatable_shares</span><span class="p">,</span>
                                 <span class="n">children_receivable_shares</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a dictionary mapping the child node_ids to the total number</span>
<span class="sd">        of shares they currently hold we balance between them in order</span>
<span class="sd">        to get an even distribution of the shares as possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        children_shares :</span>
<span class="sd">            </span>
<span class="sd">        children_donatable_shares :</span>
<span class="sd">            </span>
<span class="sd">        children_receivable_shares :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">children_shares</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">children_shares</span><span class="p">)</span>

        <span class="c1"># generate the actual donation pair and the amount that should</span>
        <span class="c1"># be donated for the best outcome</span>
        <span class="n">donor_node_id</span><span class="p">,</span> <span class="n">acceptor_node_id</span><span class="p">,</span> <span class="n">donation_amount</span> <span class="o">=</span> \
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_gen_best_donation</span><span class="p">(</span><span class="n">children_shares</span><span class="p">,</span>
                                                            <span class="n">children_donatable_shares</span><span class="p">,</span>
                                                            <span class="n">children_receivable_shares</span><span class="p">)</span>

        <span class="c1"># if the donation amount is zero we make no donation</span>
        <span class="k">if</span> <span class="n">donation_amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># account for this donation in the shares</span>
            <span class="n">children_shares</span><span class="p">[</span><span class="n">donor_node_id</span><span class="p">]</span> <span class="o">-=</span> <span class="n">donation_amount</span>
            <span class="n">children_shares</span><span class="p">[</span><span class="n">acceptor_node_id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">donation_amount</span>

            <span class="c1"># subtract the donation donatable_shares from the donor</span>
            <span class="c1"># and add the donation to the donatable_shares of the</span>
            <span class="c1"># acceptor</span>
            <span class="n">children_donatable_shares</span><span class="p">[</span><span class="n">donor_node_id</span><span class="p">]</span> <span class="o">-=</span> <span class="n">donation_amount</span>
            <span class="n">children_donatable_shares</span><span class="p">[</span><span class="n">acceptor_node_id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">donation_amount</span>

            <span class="c1"># do the opposite to the receivable shares</span>
            <span class="n">children_receivable_shares</span><span class="p">[</span><span class="n">donor_node_id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">donation_amount</span>
            <span class="n">children_receivable_shares</span><span class="p">[</span><span class="n">acceptor_node_id</span><span class="p">]</span> <span class="o">-=</span> <span class="n">donation_amount</span>

        <span class="c1"># we have decided the first donation, however more will be</span>
        <span class="c1"># performed as long as the amount of the donation is either 0</span>
        <span class="c1"># or that two donations of only 1 share occur twice in a</span>
        <span class="c1"># row. The former occurs in scenarios when there is an even</span>
        <span class="c1"># balance and the latter in an odd scenario and the last odd</span>
        <span class="c1"># share would get passed back and forth</span>

        <span class="c1"># we keep track of the previous donation, and initialize it to</span>
        <span class="c1"># None for now</span>
        <span class="n">previous_donation_amount</span> <span class="o">=</span> <span class="n">donation_amount</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">donation_amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> \
              <span class="ow">not</span> <span class="p">(</span><span class="n">previous_donation_amount</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">donation_amount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>

            <span class="c1"># update the previous donation amount</span>
            <span class="n">previous_donation_amount</span> <span class="o">=</span> <span class="n">donation_amount</span>

            <span class="c1"># get the next best donation</span>
            <span class="n">donor_node_id</span><span class="p">,</span> <span class="n">acceptor_node_id</span><span class="p">,</span> <span class="n">donation_amount</span> <span class="o">=</span> \
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_gen_best_donation</span><span class="p">(</span><span class="n">children_shares</span><span class="p">,</span>
                                                                    <span class="n">children_donatable_shares</span><span class="p">,</span>
                                                                    <span class="n">children_receivable_shares</span><span class="p">)</span>

            <span class="c1"># if there is a donation to be made make it</span>
            <span class="k">if</span> <span class="n">donation_amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># account for this donation in the shares</span>
                <span class="n">children_shares</span><span class="p">[</span><span class="n">donor_node_id</span><span class="p">]</span> <span class="o">-=</span> <span class="n">donation_amount</span>
                <span class="n">children_shares</span><span class="p">[</span><span class="n">acceptor_node_id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">donation_amount</span>

                <span class="c1"># subtract the donation donatable_shares from the donor</span>
                <span class="c1"># and add the donation to the donatable_shares of the</span>
                <span class="c1"># acceptor</span>
                <span class="n">children_donatable_shares</span><span class="p">[</span><span class="n">donor_node_id</span><span class="p">]</span> <span class="o">-=</span> <span class="n">donation_amount</span>
                <span class="n">children_donatable_shares</span><span class="p">[</span><span class="n">acceptor_node_id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">donation_amount</span>

                <span class="c1"># do the opposite to the receivable shares</span>
                <span class="n">children_receivable_shares</span><span class="p">[</span><span class="n">donor_node_id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">donation_amount</span>
                <span class="n">children_receivable_shares</span><span class="p">[</span><span class="n">acceptor_node_id</span><span class="p">]</span> <span class="o">-=</span> <span class="n">donation_amount</span>



        <span class="k">return</span> <span class="n">children_shares</span>


    <span class="k">def</span> <span class="nf">_gen_best_donation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children_shares</span><span class="p">,</span>
                                 <span class="n">children_donatable_shares</span><span class="p">,</span>
                                 <span class="n">children_receivable_shares</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a the children shares generate the best donation. Returns the</span>
<span class="sd">        donor_node_id the acceptor_node_id and the donation that</span>
<span class="sd">        should be done between them and that will be guaranteed to be</span>
<span class="sd">        valid. (this is done by checking the attributes of the regions</span>
<span class="sd">        node however, no changes to node state are performed)</span>
<span class="sd">        </span>
<span class="sd">        returns donor_node_id, acceptor_node_id, donation_amount</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        children_shares :</span>
<span class="sd">            </span>
<span class="sd">        children_donatable_shares :</span>
<span class="sd">            </span>
<span class="sd">        children_receivable_shares :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># to find the best possible donation we would like to give</span>
        <span class="c1"># shares from the region with the most to the region with the</span>
        <span class="c1"># least and give as many as possible that will equalize them,</span>
        <span class="c1"># however the size of a donation is dependent not only on the</span>
        <span class="c1"># amount of shares each region has but also the number of</span>
        <span class="c1"># squashable walkers and the number of possible clones that</span>
        <span class="c1"># satisfy the maximum and minimum walker weight</span>
        <span class="c1"># constraints. These are given by the</span>
        <span class="c1"># children_donatable_shares and children_receivable_shares. We</span>
        <span class="c1"># use arguments instead of accessing the attributes of the</span>
        <span class="c1"># object because so this can be done in an iterative manner</span>
        <span class="c1"># before modifying the node attributes.</span>

        <span class="c1"># default values for the results</span>
        <span class="n">best_pair</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">best_donation_amount</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># if there are not enough children regions to acutally make</span>
        <span class="c1"># pairings between then we just return the default negative</span>
        <span class="c1"># result</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children_shares</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">donor_node_id</span><span class="p">,</span> <span class="n">acceptor_node_id</span> <span class="o">=</span> <span class="n">best_pair</span>
            <span class="k">return</span> <span class="n">donor_node_id</span><span class="p">,</span> <span class="n">acceptor_node_id</span><span class="p">,</span> <span class="n">best_donation_amount</span>


        <span class="c1"># we want to get the list of pairings where each pairing is</span>
        <span class="c1"># (donor, acceptor)</span>
        <span class="n">pairings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">children_shares</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="mi">2</span><span class="p">):</span>


            <span class="c1"># find the largest difference comparing (a,b) and (b,a),</span>
            <span class="c1"># this will give the donor, acceptor pair</span>
            <span class="n">permutations</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">)]</span>
            <span class="n">perm_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">children_shares</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">children_shares</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                               <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">])</span>

            <span class="n">donor_acceptor_pair</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">[</span><span class="n">perm_idx</span><span class="p">]</span>

            <span class="n">pairings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">donor_acceptor_pair</span><span class="p">)</span>

        <span class="c1"># to find the best match we first calculate the differences in</span>
        <span class="c1"># the number of shares for each possible pairing between</span>
        <span class="c1"># children shares</span>
        <span class="n">pairings_differences</span> <span class="o">=</span> <span class="p">[</span><span class="n">children_shares</span><span class="p">[</span><span class="n">donor_id</span><span class="p">]</span> <span class="o">-</span> <span class="n">children_shares</span><span class="p">[</span><span class="n">acceptor_id</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">donor_id</span><span class="p">,</span> <span class="n">acceptor_id</span> <span class="ow">in</span> <span class="n">pairings</span><span class="p">]</span>

        <span class="n">pairings_donations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># then we find all the non-zero pairings</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">difference</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairings_differences</span><span class="p">):</span>

            <span class="c1"># if there is a positive difference then we calculate what</span>
            <span class="c1"># the largest donation would be</span>
            <span class="k">if</span> <span class="n">difference</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="n">donor_node_id</span><span class="p">,</span> <span class="n">acceptor_node_id</span> <span class="o">=</span> <span class="n">pairings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="c1"># get the total numbers of shares for each</span>
                <span class="n">donor_n_shares</span> <span class="o">=</span> <span class="n">children_shares</span><span class="p">[</span><span class="n">donor_node_id</span><span class="p">]</span>
                <span class="n">acceptor_n_shares</span> <span class="o">=</span> <span class="n">children_shares</span><span class="p">[</span><span class="n">acceptor_node_id</span><span class="p">]</span>

                <span class="c1"># as well as the donatable and receivable shares</span>
                <span class="n">donor_donatable_shares</span> <span class="o">=</span> <span class="n">children_donatable_shares</span><span class="p">[</span><span class="n">donor_node_id</span><span class="p">]</span>
                <span class="n">acceptor_receivable_shares</span> <span class="o">=</span> <span class="n">children_receivable_shares</span><span class="p">[</span><span class="n">acceptor_node_id</span><span class="p">]</span>

                <span class="c1"># actually calculate the maximum donation</span>
                <span class="n">donation_amount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_share_donation</span><span class="p">(</span><span class="n">donor_n_shares</span><span class="p">,</span> <span class="n">acceptor_n_shares</span><span class="p">,</span>
                                                            <span class="n">donor_donatable_shares</span><span class="p">,</span>
                                                            <span class="n">acceptor_receivable_shares</span><span class="p">)</span>

                <span class="n">pairings_donations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">donation_amount</span><span class="p">)</span>

            <span class="c1"># if there is no difference then the donation amount will also be zero</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pairings_donations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># now we can zip them all together and then sort them such</span>
        <span class="c1"># that we first sort on the size of the number of shares and</span>
        <span class="c1"># then on the size of the donation</span>
        <span class="n">pair_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">pairings_differences</span><span class="p">,</span> <span class="n">pairings_donations</span><span class="p">,</span> <span class="n">pairings</span><span class="p">))</span>
        <span class="n">pair_values</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c1"># largest to smallest</span>
        <span class="n">pair_values</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="c1"># now we take the pairing that has the highest difference and</span>
        <span class="c1"># has a nonzero donation size. Note there may be other</span>
        <span class="c1"># pairings with the same numbers that will just be ignored.</span>
        <span class="n">pair_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">pair_values</span><span class="p">)</span>


        <span class="c1"># loop through until the first best donation is found.</span>
        <span class="c1"># get the first pairing</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">diff</span><span class="p">,</span> <span class="n">donation</span><span class="p">,</span> <span class="n">pairing</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">pair_iter</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RegionTreeError</span><span class="p">(</span><span class="s2">&quot;No pairings to make donations between&quot;</span><span class="p">)</span>

        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>

            <span class="c1"># since the pair_values are sorted first by the total diff</span>
            <span class="c1"># and then the donation size, the first one that has a</span>
            <span class="c1"># positive donation is the best donation</span>
            <span class="k">if</span> <span class="n">donation</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">best_pair</span> <span class="o">=</span> <span class="n">pairing</span>
                <span class="n">best_donation_amount</span> <span class="o">=</span> <span class="n">donation</span>
                <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># try to get the next pairing if there is one</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">diff</span><span class="p">,</span> <span class="n">donation</span><span class="p">,</span> <span class="n">pairing</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">pair_iter</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="c1"># we are done, use the last pairing we had as the</span>
                <span class="c1"># pair, its just as good as any of the others let the</span>
                <span class="c1"># calling method decide what to do in this situation</span>
                <span class="n">best_pair</span> <span class="o">=</span> <span class="n">pairing</span>
                <span class="k">break</span>


        <span class="c1"># now we have the best donation and the pair is already in the</span>
        <span class="c1"># donor, acceptor order from when we created it</span>
        <span class="n">donor_node_id</span><span class="p">,</span> <span class="n">acceptor_node_id</span> <span class="o">=</span> <span class="n">best_pair</span>

        <span class="k">return</span> <span class="n">donor_node_id</span><span class="p">,</span> <span class="n">acceptor_node_id</span><span class="p">,</span> <span class="n">best_donation_amount</span>


    <span class="k">def</span> <span class="nf">_find_best_donation_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children_donatable_shares</span><span class="p">,</span>
                                       <span class="n">children_receivable_shares</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method just returns which children have the most and least</span>
<span class="sd">        number of &#39;shares&#39; which are the effective number of walker</span>
<span class="sd">        slots it will be granted in the next segment of dynamics in</span>
<span class="sd">        the simulation. This is essentially the amount of sampling</span>
<span class="sd">        effort that will be allocated to this region.</span>
<span class="sd">        </span>
<span class="sd">        This method is give the dictionary of the childrens</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        children_donatable_shares :</span>
<span class="sd">            </span>
<span class="sd">        children_receivable_shares :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># one region will be the donor of shares</span>
        <span class="n">donor_child_node_id</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># the other will accept them</span>
        <span class="n">acceptor_child_node_id</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># record for maximum number of donateable shares</span>
        <span class="n">max_donatable_shares</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># records for the max and min number of shares of the acceptor</span>
        <span class="c1"># and donor regions</span>
        <span class="n">donor_n_shares</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">acceptor_n_shares</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># go through every walker and test it to see if it is either</span>
        <span class="c1"># the highest or lowest, record it if it is</span>
        <span class="k">for</span> <span class="n">child_node_id</span> <span class="ow">in</span> <span class="n">children_donatable_shares</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

            <span class="c1"># the number of donatable shares is equal to the number</span>
            <span class="c1"># of squashable walkers</span>
            <span class="n">n_donatable_shares</span> <span class="o">=</span> <span class="n">children_donatable_shares</span><span class="p">[</span><span class="n">child_node_id</span><span class="p">]</span>

            <span class="c1"># the number of possible shares this node can receive is</span>
            <span class="c1"># equal to the number of possible clones it can make</span>
            <span class="n">n_receivable_shares</span> <span class="o">=</span> <span class="n">children_receivable_shares</span><span class="p">[</span><span class="n">child_node_id</span><span class="p">]</span>

            <span class="c1"># we see if this node region is the max region by testing</span>
            <span class="c1"># if it is the new highest in shares. It must also be able</span>
            <span class="c1"># to donate a share by having at least 1 squashable walker</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">donor_child_node_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n_shares</span> <span class="o">&gt;</span>  <span class="n">donor_n_shares</span><span class="p">))</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="n">n_donatable_shares</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

                <span class="c1"># this is a new record</span>
                <span class="n">max_donatable_shares</span> <span class="o">=</span> <span class="n">n_donatable_shares</span>

                <span class="c1"># save how many shares this region has in total</span>
                <span class="n">donor_n_shares</span> <span class="o">=</span> <span class="n">n_shares</span>
                <span class="n">donor_child_node_id</span> <span class="o">=</span> <span class="n">child_node_id</span>


            <span class="c1"># test if this is the region with the lowest number of</span>
            <span class="c1"># shares that is still able to receive at least one share</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">acceptor_child_node_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n_shares</span> <span class="o">&lt;</span> <span class="n">acceptor_n_shares</span><span class="p">))</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="n">n_receivable_shares</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

                <span class="n">acceptor_n_shares</span> <span class="o">=</span> <span class="n">n_shares</span>
                <span class="n">acceptor_child_node_id</span> <span class="o">=</span> <span class="n">child_node_id</span>

        <span class="c1"># check that both a donor and acceptor were identified and</span>
        <span class="c1"># that values for there shares were given</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="kc">True</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">[</span><span class="n">donor_n_shares</span><span class="p">,</span> <span class="n">acceptor_n_shares</span><span class="p">,</span>
                                <span class="n">donor_child_node_id</span><span class="p">,</span> <span class="n">acceptor_child_node_id</span><span class="p">]]),</span> \
                <span class="s2">&quot;A donor or acceptor was not found&quot;</span>

        <span class="c1"># if the acceptor&#39;s number of shares is not less then the</span>
        <span class="c1"># donor then there is not possible donation</span>
        <span class="k">if</span> <span class="n">acceptor_n_shares</span> <span class="o">&gt;=</span> <span class="n">donor_n_shares</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># if there is a net donation we return the donor and acceptor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">donor_child_node_id</span><span class="p">,</span> <span class="n">acceptor_child_node_id</span>

    <span class="k">def</span> <span class="nf">_calc_share_donation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">donor_n_shares</span><span class="p">,</span> <span class="n">acceptor_n_shares</span><span class="p">,</span>
                                   <span class="n">donor_donatable_shares</span><span class="p">,</span> <span class="n">acceptor_receivable_shares</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        donor_n_shares :</span>
<span class="sd">            </span>
<span class="sd">        acceptor_n_shares :</span>
<span class="sd">            </span>
<span class="sd">        donor_donatable_shares :</span>
<span class="sd">            </span>
<span class="sd">        acceptor_receivable_shares :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># the sibling with the greater number of shares (from both</span>
        <span class="c1"># previous resamplings and inherited from the parent) will</span>
        <span class="c1"># give shares to the sibling with the least.</span>

        <span class="c1"># To decide how many it shall give we first propose a desired</span>
        <span class="c1"># donation that will make them the most similar, rounding down</span>
        <span class="c1"># (i.e. midpoint)</span>
        <span class="n">desired_donation</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">donor_n_shares</span> <span class="o">-</span> <span class="n">acceptor_n_shares</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># however, the donor only has a certain capability of donation</span>
        <span class="c1"># and the acceptor has a certain capacity of receiving. Out of</span>
        <span class="c1"># the three we can only actually donate the smallest amount</span>
        <span class="n">actual_donation</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">desired_donation</span><span class="p">,</span>
                              <span class="n">donor_donatable_shares</span><span class="p">,</span>
                              <span class="n">acceptor_receivable_shares</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">actual_donation</span>

    <span class="k">def</span> <span class="nf">_decide_merge_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">merge_groups</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        leaf :</span>
<span class="sd">            </span>
<span class="sd">        merge_groups :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># this method assumes no cloning has been performed before this</span>

        <span class="c1"># TODO: potentially unneeded</span>
        <span class="c1"># all the walker idxs</span>
        <span class="n">walker_idxs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">merge_groups</span><span class="p">)))</span>

        <span class="c1"># the balance of this leaf</span>
        <span class="n">leaf_balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="s1">&#39;balance&#39;</span><span class="p">]</span>

        <span class="c1"># there should not be any taken walkers in this leaf since a</span>
        <span class="c1"># leaf should only have this method run for it once during</span>
        <span class="c1"># decision making, so the mergeable walkers are just all the</span>
        <span class="c1"># walkers in this leaf</span>
        <span class="n">leaf_walker_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="s1">&#39;walker_idxs&#39;</span><span class="p">]</span>
        <span class="n">leaf_walker_weights</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">walker_weights</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">walker_idx</span> <span class="ow">in</span> <span class="n">leaf_walker_idxs</span><span class="p">]</span>


        <span class="c1"># now that we have the walkers that may potentially be merged</span>
        <span class="c1"># we need to actually find a set of groupings that satisfies</span>
        <span class="c1"># the reduction in balance without any individual walker</span>
        <span class="c1"># exceeding the maximum weight. In general this is a difficult</span>
        <span class="c1"># problem both here and in deciding how balances are</span>
        <span class="c1"># distributed (because the potential merges determine a leafs</span>
        <span class="c1"># ability to pay a portion of a debt from a higher level in</span>
        <span class="c1"># the region tree).</span>

        <span class="c1"># currently we avoid this general problem (potentially of the</span>
        <span class="c1"># backpack kind if you want to help solve this issue) and</span>
        <span class="c1"># simply assume that we will perform a single merge of the</span>
        <span class="c1"># walkers of the lowest weights to achieve our balance</span>
        <span class="c1"># reduction goal. As long as this assumption holds in how the</span>
        <span class="c1"># balances are determined this will succeed, if not this will</span>
        <span class="c1"># fail</span>

        <span class="c1"># to allow for easy improvements later on pending this problem</span>
        <span class="c1"># becoming solved it is functionalized here to make a set of</span>
        <span class="c1"># pairings that satisfy the balance reduction goal, these are</span>
        <span class="c1"># &quot;merge groups&quot; except that at this point we haven&#39;t chosen</span>
        <span class="c1"># one to be the KEEP_MERGE walker and have its state</span>
        <span class="c1"># retained. This will be decided further on. So these &quot;full</span>
        <span class="c1"># merge groups&quot; include all the walkers that will be merged</span>
        <span class="c1"># and the sum of their weights will be the weight of the final</span>
        <span class="c1"># merged walker and should satisfy the maximum weight</span>
        <span class="c1"># requirement, i.e. it will not be checked here.</span>
        <span class="n">full_merge_groups_leaf_walker_idxs</span> <span class="o">=</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">_solve_merge_groupings</span><span class="p">(</span><span class="n">leaf_walker_weights</span><span class="p">,</span> <span class="n">leaf_balance</span><span class="p">)</span>

        <span class="c1"># now we go through each of these &quot;full merge groups&quot; and make</span>
        <span class="c1"># the &quot;merge groups&quot;. Pardon the terminology, but the</span>
        <span class="c1"># distinction is trivial and is only relevant to the</span>
        <span class="c1"># implementation. The &quot;merge groups&quot; are what is returned. To</span>
        <span class="c1"># make them we just choose which walker to keep and which</span>
        <span class="c1"># walkers to squash in each full merge group</span>
        <span class="k">for</span> <span class="n">full_merge_group_leaf_walker_idxs</span> <span class="ow">in</span> <span class="n">full_merge_groups_leaf_walker_idxs</span><span class="p">:</span>

            <span class="c1"># the indices from this are in terms of the list of weights</span>
            <span class="c1"># given to the method so we translate them back to the actual</span>
            <span class="c1"># walker indices</span>
            <span class="n">chosen_walker_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf_walker_idxs</span><span class="p">[</span><span class="n">leaf_walker_idx</span><span class="p">]</span>
                                  <span class="k">for</span> <span class="n">leaf_walker_idx</span> <span class="ow">in</span> <span class="n">full_merge_group_leaf_walker_idxs</span><span class="p">]</span>

            <span class="c1"># get the weights of these chosen_walker_idxs</span>
            <span class="n">chosen_weights</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">walker_weights</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">walker_idx</span> <span class="ow">in</span> <span class="n">chosen_walker_idxs</span><span class="p">]</span>

            <span class="c1"># choose the one to keep the state of (e.g. KEEP_MERGE</span>
            <span class="c1"># in the Decision) based on their weights</span>

            <span class="c1"># normalize weights to the sum of all the chosen weights</span>
            <span class="n">chosen_pdist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chosen_weights</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">chosen_weights</span><span class="p">)</span>

            <span class="c1"># then choose one of the the walker idxs to keep according to</span>
            <span class="c1"># their normalized weights</span>
            <span class="n">keep_walker_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">chosen_walker_idxs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">chosen_pdist</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># pop the keep idx from the walkers so we can use the rest of</span>
            <span class="c1"># them as the squash idxs</span>
            <span class="n">chosen_walker_idxs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">chosen_walker_idxs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">keep_walker_idx</span><span class="p">))</span>

            <span class="c1"># the rest are squash_idxs</span>
            <span class="n">squash_walker_idxs</span> <span class="o">=</span> <span class="n">chosen_walker_idxs</span>

            <span class="c1"># update the merge group based on this decision</span>
            <span class="n">merge_groups</span><span class="p">[</span><span class="n">keep_walker_idx</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">squash_walker_idxs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merge_groups</span>

    <span class="k">def</span> <span class="nf">_solve_merge_groupings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walker_weights</span><span class="p">,</span> <span class="n">balance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        walker_weights :</span>
<span class="sd">            </span>
<span class="sd">        balance :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># this method chooses between the methods for solving the</span>
        <span class="c1"># backpack problem of how to merge walkers together to satisfy</span>
        <span class="c1"># a goal</span>

        <span class="c1"># as a method for easy transition between potential methods (I</span>
        <span class="c1"># expect there are multiple solutions to the problem with</span>
        <span class="c1"># different tradeoffs that will want to be tested) a method</span>
        <span class="c1"># can be chosen when the region tree is created and a constant</span>
        <span class="c1"># string identifier will be set indicating which method is in use</span>

        <span class="c1"># so we use that string to find which method to use</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_method</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>

            <span class="n">full_merge_groups</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">decide_merge_groups_single_method</span><span class="p">(</span>
                <span class="n">walker_weights</span><span class="p">,</span> <span class="n">balance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmax</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;merge method </span><span class="si">{}</span><span class="s2"> not recognized&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merge_method</span><span class="p">))</span>

        <span class="c1"># if the result came out false then a solution could not be</span>
        <span class="c1"># found</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>

            <span class="k">raise</span> <span class="n">RegionTreeError</span><span class="p">(</span>
                <span class="s2">&quot;A solution to the merging problem could not be found given the constraints&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">full_merge_groups</span>

    <span class="k">def</span> <span class="nf">_decide_clone_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">merge_groups</span><span class="p">,</span> <span class="n">walkers_num_clones</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        leaf :</span>
<span class="sd">            </span>
<span class="sd">        merge_groups :</span>
<span class="sd">            </span>
<span class="sd">        walkers_num_clones :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># just follow the instructions in the walkers_num_clones and</span>
        <span class="c1"># find them slots</span>

        <span class="c1"># this assumes that the all squashes have already been</span>
        <span class="c1"># specified in the merge group, this is so that we can use</span>
        <span class="c1"># unused walker slots.</span>

        <span class="c1"># if this leaf node was assigned a debt we need to merge</span>
        <span class="c1"># walkers</span>
        <span class="n">leaf_balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="s1">&#39;balance&#39;</span><span class="p">]</span>
        <span class="n">leaf_walker_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="s1">&#39;walker_idxs&#39;</span><span class="p">]</span>
        <span class="n">leaf_walker_weights</span> <span class="o">=</span> <span class="p">{</span><span class="n">walker_idx</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">walker_weights</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span>
                               <span class="k">for</span> <span class="n">walker_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="s1">&#39;walker_idxs&#39;</span><span class="p">]}</span>

        <span class="c1"># calculate the maximum possible number of clones each free walker</span>
        <span class="c1"># could produce</span>
        <span class="n">walker_n_possible_clones</span> <span class="o">=</span> <span class="p">{</span><span class="n">walker_idx</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_max_num_clones</span><span class="p">(</span><span class="n">leaf_weight</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">walker_idx</span><span class="p">,</span> <span class="n">leaf_weight</span> <span class="ow">in</span> <span class="n">leaf_walker_weights</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># the sum of the possible clones needs to be greater than or</span>
        <span class="c1"># equal to the balance</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">sum</span><span class="p">(</span><span class="n">walker_n_possible_clones</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="n">leaf_balance</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RegionTreeError</span><span class="p">(</span><span class="s2">&quot;there isn&#39;t enough clones possible to pay the balance&quot;</span><span class="p">)</span>

        <span class="c1"># go through the list of free walkers and see which ones have</span>
        <span class="c1"># any possible clones and make a list of them</span>
        <span class="n">cloneable_walker_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">walker_idx</span> <span class="k">for</span> <span class="n">walker_idx</span> <span class="ow">in</span> <span class="n">leaf_walker_idxs</span>
                                 <span class="k">if</span> <span class="n">walker_n_possible_clones</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">cloneable_walker_weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf_walker_weights</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">walker_idx</span> <span class="ow">in</span> <span class="n">cloneable_walker_idxs</span><span class="p">]</span>

        <span class="c1"># if the sum of them is equal to the leaf balance then we</span>
        <span class="c1"># don&#39;t have to optimally distribute them and we just give them out</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">walker_n_possible_clones</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="n">leaf_balance</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">walker_idx</span> <span class="ow">in</span> <span class="n">cloneable_walker_idxs</span><span class="p">:</span>
                <span class="n">walkers_num_clones</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">walker_n_possible_clones</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span>

            <span class="c1"># return this without doing all the prioritization</span>
            <span class="k">return</span> <span class="n">walkers_num_clones</span>

        <span class="c1"># otherwise we want to optimally distribute the clones to the</span>
        <span class="c1"># walkers such that we split the largest walkers first</span>

        <span class="c1"># to distribute the clones we iteratively choose the walker</span>
        <span class="c1"># with the highest weight after a single clone</span>
        <span class="c1"># weight/(n_clones +1) where n_clones is the current number of</span>
        <span class="c1"># clones assigned to it (plus itself), and then add another</span>
        <span class="c1"># clone to it as long as it is within the range of the number</span>
        <span class="c1"># of clones it can make</span>

        <span class="c1"># go until the balance is paid off</span>
        <span class="n">clones_left</span> <span class="o">=</span> <span class="n">leaf_balance</span>
        <span class="k">while</span> <span class="n">clones_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># determine which walkers are still in the running for</span>
            <span class="c1"># receiving clones</span>
            <span class="n">still_cloneable_walker_idxs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">still_cloneable_walker_weights</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">walker_idx</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cloneable_walker_idxs</span><span class="p">,</span> <span class="n">cloneable_walker_weights</span><span class="p">):</span>

                <span class="c1"># if the number of clones is less than its maximum</span>
                <span class="c1"># possible add it to the still applicable ones</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">walkers_num_clones</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">walker_n_possible_clones</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]):</span>

                    <span class="n">still_cloneable_walker_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">walker_idx</span><span class="p">)</span>
                    <span class="n">still_cloneable_walker_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>

            <span class="c1"># if there is only one applicable walker left give it the</span>
            <span class="c1"># rest of the balance and return</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">still_cloneable_walker_idxs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">walkers_num_clones</span><span class="p">[</span><span class="n">still_cloneable_walker_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">clones_left</span>
                <span class="n">clones_left</span> <span class="o">-=</span> <span class="n">clones_left</span>

                <span class="c1"># end this loop iteration, skipping the decision part</span>
                <span class="k">continue</span>

            <span class="c1"># if there are multiple walkers left we decide between them</span>

            <span class="c1"># calculate the weights of the walker&#39;s children given the</span>
            <span class="c1"># current number of clones, if num_clones is 0 then it is</span>
            <span class="c1"># just it&#39;s own weight</span>
            <span class="n">child_weights</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">walker_idx</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">still_cloneable_walker_idxs</span><span class="p">,</span> <span class="n">still_cloneable_walker_weights</span><span class="p">):</span>

                <span class="c1"># the weight of its children given the number of</span>
                <span class="c1"># clones already assigned to it</span>
                <span class="n">child_weight</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="p">(</span><span class="n">walkers_num_clones</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

                <span class="n">child_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child_weight</span><span class="p">)</span>

            <span class="c1"># get the walker_idx with the highest would-be child weight</span>
            <span class="n">chosen_walker_idx</span> <span class="o">=</span> <span class="n">still_cloneable_walker_idxs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">child_weights</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

            <span class="c1"># add a clone to it</span>
            <span class="n">walkers_num_clones</span><span class="p">[</span><span class="n">chosen_walker_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># we are one step closer to satisfying the cloning</span>
            <span class="c1"># requirement</span>
            <span class="n">clones_left</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">walkers_num_clones</span>

    <span class="k">def</span> <span class="nf">_decide_settle_balance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given the balances of all the leaves figure out actually how to</span>
<span class="sd">        settle all the balances. Returns the merge_groups and</span>
<span class="sd">        walkers_num_clones</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize the main data structures for specifying how to</span>
        <span class="c1"># merge and clone a set of walkers. These will be modified for</span>
        <span class="c1"># clones and merges but in the initialized state they will</span>
        <span class="c1"># generate all NOTHING records.</span>

        <span class="c1"># the merge groups, a list of lists where the elements of the</span>
        <span class="c1"># outer list are individual &quot;merge groups&quot; that themselves</span>
        <span class="c1"># contain the elements of the walkers that will be squashed in</span>
        <span class="c1"># a merge and the index of the merge group in the outer list</span>
        <span class="c1"># is the index of the walker that will be kept</span>
        <span class="c1"># (i.e. KEEP_MERGE and have its state persist to the next</span>
        <span class="c1"># step). Indices appearing in any merge group can themselves</span>
        <span class="c1"># not have a merge group</span>
        <span class="n">merge_groups</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">walker_weights</span><span class="p">]</span>

        <span class="c1"># the number of clones to make for each walker. Simply a list</span>
        <span class="c1"># of 0 or positive integers that specify how many EXTRA clones</span>
        <span class="c1"># will be made. E.g. if a cloned walker is to have 3 children</span>
        <span class="c1"># then the number of clones is 2. We consider clones copies</span>
        <span class="c1"># from the original walker which is given by the index in the</span>
        <span class="c1"># list. This number then gives the number of new slots needed</span>
        <span class="c1"># for a cloning event</span>
        <span class="n">walkers_num_clones</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">walker_weights</span><span class="p">]</span>

        <span class="c1"># get all the leaf balances</span>
        <span class="n">leaf_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">()</span>
        <span class="n">leaf_balances</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="s1">&#39;balance&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaf_nodes</span><span class="p">]</span>

        <span class="c1"># get the negative and positive balanced leaves</span>
        <span class="n">neg_leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf_nodes</span><span class="p">[</span><span class="n">leaf_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">leaf_idx</span> <span class="ow">in</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">leaf_balances</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="n">pos_leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf_nodes</span><span class="p">[</span><span class="n">leaf_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">leaf_idx</span> <span class="ow">in</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">leaf_balances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)]</span>

        <span class="c1"># we decide on how the walkers will be cloned and</span>
        <span class="c1"># merged. These steps are purely functional and do not modify</span>
        <span class="c1"># any attributes on the RegionTree. The merge_groups and</span>
        <span class="c1"># walkers_num_clones can be used to commit these changes</span>
        <span class="c1"># elsewhere if desired.</span>

        <span class="c1"># first do all leaves with negative balances, so that after we</span>
        <span class="c1"># have freed up slots we can fill them with clones since in</span>
        <span class="c1"># WEXplore we want to have an economy of slots and not create</span>
        <span class="c1"># them if we don&#39;t have to</span>
        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">neg_leaves</span><span class="p">:</span>
            <span class="n">merge_groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decide_merge_leaf</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">merge_groups</span><span class="p">)</span>

        <span class="c1"># then do all the leaves with positive balances to fill the</span>
        <span class="c1"># slots left from squashing walkers</span>
        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">pos_leaves</span><span class="p">:</span>
            <span class="n">walkers_num_clones</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decide_clone_leaf</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">merge_groups</span><span class="p">,</span> <span class="n">walkers_num_clones</span><span class="p">)</span>


        <span class="k">return</span> <span class="n">merge_groups</span><span class="p">,</span> <span class="n">walkers_num_clones</span>

    <span class="k">def</span> <span class="nf">_check_clone_merge_specs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">merge_groups</span><span class="p">,</span> <span class="n">walkers_num_clones</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This will perform the computations to get the weights of the clones</span>
<span class="sd">        and merges but does not actually assign them to slots. This is</span>
<span class="sd">        mainly for checking that we have not violated any rules.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        merge_groups :</span>
<span class="sd">            </span>
<span class="sd">        walkers_num_clones :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># keep a dictionary of all the walkers that will be parents to</span>
        <span class="c1"># at least one child walker and make a list of the weights</span>
        <span class="c1"># what each of the children will be</span>
        <span class="n">walker_children_weights</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># walkers that will be keep merges</span>
        <span class="n">keep_merge_walker_idxs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># walkers that will parents of clones</span>
        <span class="n">clone_parent_walker_idxs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># walkers that do nothing and keep their state and weight</span>
        <span class="n">nothing_walker_idxs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># if that passes then we can check whether or not the weights make sense</span>
        <span class="n">new_walker_weights</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># get all the squash idxs so we can pass over them</span>
        <span class="n">all_squash_idxs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">merge_groups</span><span class="p">))</span>

        <span class="c1"># go through each walker and see what the results of it would</span>
        <span class="c1"># be without assigning it to anywhere in particular</span>
        <span class="k">for</span> <span class="n">walker_idx</span><span class="p">,</span> <span class="n">num_clones</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">walkers_num_clones</span><span class="p">):</span>

            <span class="c1"># check that clones are not performed on KEEP_MERGE and SQUASH</span>
            <span class="c1"># walkers</span>
            <span class="k">if</span> <span class="n">num_clones</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merge_groups</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ResamplerError</span><span class="p">(</span><span class="s2">&quot;trying to clone a KEEP_MERGE walker&quot;</span><span class="p">)</span>

                <span class="n">squash_idxs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">merge_groups</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">walker_idx</span> <span class="ow">in</span> <span class="n">squash_idxs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ResamplerError</span><span class="p">(</span><span class="s2">&quot;trying to clone a SQUASH walker&quot;</span><span class="p">)</span>

            <span class="n">squash_walker_idxs</span> <span class="o">=</span> <span class="n">merge_groups</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span>

            <span class="c1"># if it is a squashed walker ignore it</span>
            <span class="k">if</span> <span class="n">walker_idx</span> <span class="ow">in</span> <span class="n">all_squash_idxs</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># split the weight up evenly, the numbers in the list is</span>
            <span class="c1"># the extra number of walkers that should exist so that we</span>
            <span class="c1"># should add 1 to get the total number of child walkers</span>
            <span class="c1"># after the split</span>
            <span class="k">elif</span> <span class="n">num_clones</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">squash_walker_idxs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># add this to the list of clone parents</span>
                <span class="n">clone_parent_walker_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">walker_idx</span><span class="p">)</span>

                <span class="c1"># get the weight each of the children will have</span>
                <span class="n">clone_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_walker_weights</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_clones</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># add them to the new_walker_weights and as the</span>
                <span class="c1"># children of this walkers weights</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_clones</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># weights of all walkers</span>
                    <span class="n">new_walker_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clone_weights</span><span class="p">)</span>

                    <span class="c1"># weights of the children</span>
                    <span class="n">walker_children_weights</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clone_weights</span><span class="p">)</span>

            <span class="c1"># if this is a merge group keep idx then we add the</span>
            <span class="c1"># weights of the merge group together</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">squash_walker_idxs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># add this to the list of keep merge parents</span>
                <span class="n">keep_merge_walker_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">walker_idx</span><span class="p">)</span>

                <span class="c1"># add up the weights of the squashed walkers</span>
                <span class="n">squashed_weight</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">walker_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">squash_walker_idxs</span><span class="p">])</span>
                <span class="c1"># add them to the weight for the keep walker</span>
                <span class="n">walker_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_walker_weights</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">squashed_weight</span>

                <span class="n">new_walker_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">walker_weight</span><span class="p">)</span>
                <span class="n">walker_children_weights</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">walker_weight</span><span class="p">)</span>

            <span class="c1"># this is then a nothing instruction so we just add its</span>
            <span class="c1"># weight to the list as is</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nothing_walker_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">walker_idx</span><span class="p">)</span>
                <span class="n">new_walker_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_walker_weights</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">])</span>
                <span class="n">walker_children_weights</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_walker_weights</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">])</span>

        <span class="c1"># check that we have the same number of walkers as when we started</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_walker_weights</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_walker_weights</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ResamplerError</span><span class="p">(</span><span class="s2">&quot;There is not the same number of walkers as before the clone-merges&quot;</span><span class="p">)</span>

        <span class="c1"># then we check that the total weight before and after is the</span>
        <span class="c1"># same or close to the same</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_walker_weights</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">new_walker_weights</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">ResamplerError</span><span class="p">(</span><span class="s2">&quot;There has been a change in total amount of weight&quot;</span><span class="p">)</span>

        <span class="c1"># check that none of the walkers are outside the range of</span>
        <span class="c1"># probabilities</span>
        <span class="n">new_walker_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_walker_weights</span><span class="p">)</span>

        <span class="n">overweight_walker_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">new_walker_weights</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmax</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># check that all of the weights are less than or equal to the pmax</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overweight_walker_idxs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

            <span class="c1"># list of parents that produce overweight children</span>
            <span class="n">overweight_producer_idxs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># figure out which parent created them, this will have</span>
            <span class="c1"># come from a merge so we just go through the parents that</span>
            <span class="c1"># are keep merges</span>
            <span class="k">for</span> <span class="n">keep_merge_walker_idx</span> <span class="ow">in</span> <span class="n">keep_merge_walker_idxs</span><span class="p">:</span>
                <span class="n">child_weight</span> <span class="o">=</span> <span class="n">walker_children_weights</span><span class="p">[</span><span class="n">keep_merge_walker_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">child_weight</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmax</span><span class="p">:</span>
                    <span class="n">overweight_producer_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keep_merge_walker_idx</span><span class="p">)</span>

            <span class="k">raise</span> <span class="n">ResamplerError</span><span class="p">(</span>
                <span class="s2">&quot;Merge specs produce overweight walkers for merge groups </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">overweight_producer_idxs</span><span class="p">]))</span>

        <span class="c1"># check that all of the weights are less than or equal to the pmin</span>
        <span class="n">underweight_walker_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">new_walker_weights</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmin</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">underweight_walker_idxs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

            <span class="c1"># list of clone parents that will produce underweight</span>
            <span class="c1"># walkers</span>
            <span class="n">underweight_producer_idxs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># figure out which parents create underweight walkers,</span>
            <span class="c1"># only clones will do this so we just look through them</span>
            <span class="k">for</span> <span class="n">clone_parent_walker_idx</span> <span class="ow">in</span> <span class="n">clone_parent_walker_idxs</span><span class="p">:</span>
                <span class="c1"># all children will be the same weight so we just get</span>
                <span class="c1"># one of the weights</span>
                <span class="n">child_weight</span> <span class="o">=</span> <span class="n">walker_children_weights</span><span class="p">[</span><span class="n">clone_parent_walker_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">child_weight</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmin</span><span class="p">:</span>
                    <span class="n">underweight_producer_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clone_parent_walker_idx</span><span class="p">)</span>

            <span class="k">raise</span> <span class="n">ResamplerError</span><span class="p">(</span>
                <span class="s2">&quot;Clone specs produce underweight walkers for clone walkers </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">underweight_producer_idxs</span><span class="p">]))</span>

<div class="viewcode-block" id="RegionTree.balance_tree"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.RegionTree.balance_tree">[docs]</a>    <span class="k">def</span> <span class="nf">balance_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_walkers</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do balancing between the branches of the tree. the `delta_walkers`</span>
<span class="sd">        kwarg can be used to increase or decrease the total number of</span>
<span class="sd">        walkers, but defaults to zero which will cause no net change</span>
<span class="sd">        in the number of walkers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        delta_walkers :</span>
<span class="sd">             (Default value = 0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set the delta walkers to the balance of the root node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ROOT_NODE</span><span class="p">][</span><span class="s1">&#39;balance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta_walkers</span>

        <span class="c1"># do a breadth first traversal and balance at each level</span>
        <span class="k">for</span> <span class="n">parent</span><span class="p">,</span> <span class="n">children</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">bfs_successors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROOT_NODE</span><span class="p">):</span>

            <span class="c1"># pass on the balance of this parent to the children from the</span>
            <span class="c1"># parents, distribute walkers between</span>
            <span class="n">parental_balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="s1">&#39;balance&#39;</span><span class="p">]</span>

            <span class="c1"># this will both propagate the balance set for the root</span>
            <span class="c1"># walker down the tree and balance between the children</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_and_balance_shares</span><span class="p">(</span><span class="n">parental_balance</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>

        <span class="c1"># check that the sum of the balances of the leaf nodes</span>
        <span class="c1"># balances to delta_walkers</span>
        <span class="n">leaf_balances</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="s1">&#39;balance&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">leaf_balances</span><span class="p">)</span> <span class="o">!=</span> <span class="n">delta_walkers</span><span class="p">:</span>

            <span class="k">raise</span> <span class="n">RegionTreeError</span><span class="p">(</span>
                <span class="s2">&quot;The balances of the leaf nodes (</span><span class="si">{}</span><span class="s2">) do not balance to delta_walkers (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">leaf_balances</span><span class="p">,</span> <span class="n">delta_walkers</span><span class="p">))</span>

        <span class="c1"># decide on how to settle all the balances between leaves</span>
        <span class="n">merge_groups</span><span class="p">,</span> <span class="n">walkers_num_clones</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decide_settle_balance</span><span class="p">()</span>

        <span class="c1"># count up the number of clones and merges in the merge_groups</span>
        <span class="c1"># and the walkers_num_clones</span>
        <span class="n">num_clones</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">walkers_num_clones</span><span class="p">)</span>
        <span class="n">num_squashed</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">merge_group</span><span class="p">)</span> <span class="k">for</span> <span class="n">merge_group</span> <span class="ow">in</span> <span class="n">merge_groups</span><span class="p">])</span>

        <span class="c1"># check that the number of clones and number of squashed</span>
        <span class="c1"># walkers balance to the delta_walkers amount</span>
        <span class="k">if</span> <span class="n">num_clones</span> <span class="o">-</span> <span class="n">num_squashed</span> <span class="o">!=</span> <span class="n">delta_walkers</span><span class="p">:</span>

            <span class="k">raise</span> <span class="n">RegionTreeError</span><span class="p">(</span><span class="s2">&quot;The number of new clones (</span><span class="si">{}</span><span class="s2">) is not balanced by the number of&quot;</span>
                                  <span class="s2">&quot;squashed walkers (</span><span class="si">{}</span><span class="s2">) to the delta_walkers specified (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                      <span class="n">num_clones</span><span class="p">,</span> <span class="n">num_squashed</span><span class="p">,</span> <span class="n">delta_walkers</span><span class="p">))</span>

        <span class="c1"># DEBUG</span>
        <span class="c1"># check the merge groups and walkers_num_clones to make sure</span>
        <span class="c1"># they are valid</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_clone_merge_specs</span><span class="p">(</span><span class="n">merge_groups</span><span class="p">,</span> <span class="n">walkers_num_clones</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ResamplerError</span> <span class="k">as</span> <span class="n">resampler_err</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">resampler_err</span><span class="p">)</span>
            <span class="kn">import</span> <span class="nn">ipdb</span><span class="p">;</span> <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">merge_groups</span><span class="p">,</span> <span class="n">walkers_num_clones</span></div></div>

<div class="viewcode-block" id="WExploreResampler"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.WExploreResampler">[docs]</a><span class="k">class</span> <span class="nc">WExploreResampler</span><span class="p">(</span><span class="n">CloneMergeResampler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Resampler implementing the WExplore algorithm.</span>

<span class="sd">    See the paper for a full description of the algorithm, but</span>
<span class="sd">    briefly:</span>

<span class="sd">    WExplore defines a hierarchical Voronoi tesselation on a subspace</span>
<span class="sd">    of the full walker state. Regions in a Voronoi cell are defined by</span>
<span class="sd">    a point in this subspace called an &#39;image&#39;, and are scoped by</span>
<span class="sd">    their enclosing region in the hierarchy.</span>

<span class="sd">    The hierarchy is defined initially by:</span>

<span class="sd">    - number of levels of the hierarchy, AKA depth</span>
<span class="sd">    - number of regions allowed at a level of the hierarchy</span>
<span class="sd">    - a cutoff &#39;distance&#39; at each level of the hierarchy</span>

<span class="sd">    All regions have a unique specification (called a leaf_id) which</span>
<span class="sd">    is a k-tuple of region indices, where k is the depth of the</span>
<span class="sd">    hierarchy.</span>

<span class="sd">    At first the hierarchy only has a single region at all levels</span>
<span class="sd">    which is given by the image of the &#39;init_state&#39; constructor</span>
<span class="sd">    argument.</span>

<span class="sd">    For a hierarchy of depth 4 the leaf_id for this first region is</span>
<span class="sd">    (0, 0, 0, 0) which indicates that at level 0 (the highest level)</span>
<span class="sd">    we are selecting the first region (region 0), and at level 1 we</span>
<span class="sd">    select the first region at that level (region 0 again), and so on.</span>

<span class="sd">    For this region all images at each level are identical.</span>

<span class="sd">    During resampling walkers first are binned into the region they</span>
<span class="sd">    fall. This is achieved using a breadth first search where the</span>
<span class="sd">    distance (according to the distance metric) between the walker</span>
<span class="sd">    state and all region images are computed. The image that is</span>
<span class="sd">    closest to the walker is selected and in the next iteration of</span>
<span class="sd">    comparisons we restrict the search to only regions within this</span>
<span class="sd">    super-region.</span>

<span class="sd">    For example for a region tree with the following leaf ids: (0,0,0)</span>
<span class="sd">    and (0,1,0) we skip distance computations at level 0, since there</span>
<span class="sd">    is only one region. At level 1, we compute the distance to images</span>
<span class="sd">    0 and 1 and choose the one that is closest. Since each of these</span>
<span class="sd">    regions only has 1 sub-region we do not need to recalculate the</span>
<span class="sd">    distance and can assign the walker.</span>

<span class="sd">    Indeed every super-region will have exactly one sub-region that</span>
<span class="sd">    has the same image as it, and these distance calculations are</span>
<span class="sd">    never repeated for performance.</span>

<span class="sd">    This resampler adds the additional &#39;region_assignment&#39; field to</span>
<span class="sd">    the resampling records which indicates the region a walker was</span>
<span class="sd">    assigned to during resampling.</span>


<span class="sd">    While walkers can always be assigned uniquely to a region the</span>
<span class="sd">    specification of the cutoff distances at each level indicate when</span>
<span class="sd">    sufficient novelty in a walker motivates creation of a new region.</span>

<span class="sd">    The distances of the walker to each of the closest region images</span>
<span class="sd">    is saved for each level, e.g. (0.1, 0.3, 0.5) for the example</span>
<span class="sd">    above. This is compared to the cutoff distance specification,</span>
<span class="sd">    e.g. (0.2, 0.2, 0.2). The highest level at which a distance</span>
<span class="sd">    exceeds the cutoff will trigger region creation.</span>

<span class="sd">    Following the example above the walker above exceeded the cutoff</span>
<span class="sd">    distance at level 1 and level 2 of the hierarchy, however level 1</span>
<span class="sd">    takes precedence over the lower level.</span>

<span class="sd">    This event of region creation can be thought of as a branching</span>
<span class="sd">    event of the tree, where the branching level is the level at which</span>
<span class="sd">    the branch occurred.</span>

<span class="sd">    All branches of a region tree must extend the full depth and so</span>
<span class="sd">    the specification of the new branch can be given by the leaf_id of</span>
<span class="sd">    the region created, which would be (0, 2, 0) for this example.</span>

<span class="sd">    The new image of this region is the image of the walker that</span>
<span class="sd">    triggered the branching.</span>

<span class="sd">    Note that the &#39;boundaries&#39; of the Voronoi cells are subject to</span>
<span class="sd">    change during branching.</span>

<span class="sd">    The only limitation to this process is the allowed number of</span>
<span class="sd">    sub-regions for a super-region which is given for each level. For</span>
<span class="sd">    example, (5, 10, 10) indicates that regions at the top-most level</span>
<span class="sd">    can have 5 sub-regions, and in turn those sub-regions can have 10</span>
<span class="sd">    sub-regions, and so on.</span>

<span class="sd">    The resampler records give updates on the definitions of new</span>
<span class="sd">    regions and includes:</span>

<span class="sd">    - branching_level : the level of the tree the branching occured</span>
<span class="sd">          at, which relates it to the number of allowed regions and the</span>
<span class="sd">          cutoff distance new regions are made at.</span>

<span class="sd">    - distance : the distance of the walker to the nearest region</span>
<span class="sd">          image that triggered the creation of a new region.</span>

<span class="sd">    - new_leaf_id : the leaf id of the new region, which is a tuple of</span>
<span class="sd">          the index of each region index at each branching level.</span>

<span class="sd">    - image : a datatype that stores the actual value of the newly</span>
<span class="sd">          created region.</span>



<span class="sd">    That covers how regions are initialized, adaptively created, and</span>
<span class="sd">    recorded, but doesn&#39;t explain how these regions are used inform</span>
<span class="sd">    the actual resampling process.</span>

<span class="sd">    Essentially, the hierarchical structure allows for balanced</span>
<span class="sd">    resource trading between regions. The resource in the case of</span>
<span class="sd">    weighted ensemble is the allocation of a walker which will be</span>
<span class="sd">    scheduled for sampling in the next cycle. The more walkers a</span>
<span class="sd">    region has the more sampling of the region will occur.</span>

<span class="sd">    After the sampling step walkers move around in regions and between</span>
<span class="sd">    regions. Some regions will end up collecting more walkers than</span>
<span class="sd">    other regions during this. The goal is to redistribute those</span>
<span class="sd">    walkers to other regions so that each level of the hierarchy is as</span>
<span class="sd">    balanced as possible.</span>

<span class="sd">    So after sampling the number of walkers is added up for each</span>
<span class="sd">    region. At the top of the hierarchy a collection of trades between</span>
<span class="sd">    the super-regions is negotiated based on which regions are able to</span>
<span class="sd">    give up walkers and those that need them such that each region has</span>
<span class="sd">    as close to the same number of walkers as possible.</span>

<span class="sd">    The &#39;payment&#39; of a tax (or donation) is performed by merging</span>
<span class="sd">    walkers and the reception of the donation (or welfare</span>
<span class="sd">    dispensation) is achieved by cloning walkers.</span>

<span class="sd">    Because there are constraints on how many walkers can be merged</span>
<span class="sd">    and cloned due to minimum and maximum walker probabilities and</span>
<span class="sd">    total number of walkers, sometimes a region may have an excess of</span>
<span class="sd">    walkers but none of them are taxable (donatable) because any merge</span>
<span class="sd">    would create a walker above the maximum probability. Conversely, a</span>
<span class="sd">    region may not be able to receive walkers because any clone of a</span>
<span class="sd">    walker would make walkers with weight lower than the minimum.</span>

<span class="sd">    However, super-regions cannot actually &#39;pay&#39; for these trades</span>
<span class="sd">    themselves and simply make a request to their sub-regions to</span>
<span class="sd">    provide the requested walkers (or to find room for accepting</span>
<span class="sd">    them). The trade negotiation process then repeats within each</span>
<span class="sd">    sub-region. When the request for debits and credits finally</span>
<span class="sd">    reaches leaf node regions the process stops and the actual</span>
<span class="sd">    identities of the walkers that will be cloned or merged are</span>
<span class="sd">    determined.</span>

<span class="sd">    Then the cloning and merging of walkers is performed.</span>

<span class="sd">    After this process if we were to recount the number of walkers in</span>
<span class="sd">    all regions then they should be pretty well balanced at each</span>
<span class="sd">    level.</span>

<span class="sd">    Its worth noting that some regions will have no walkers because</span>
<span class="sd">    once a region contains no walkers (all walkers leave the region</span>
<span class="sd">    during sampling) it can no longer receive any walkers at all</span>
<span class="sd">    because it cannot clone. Of course walkers may re-enter the region</span>
<span class="sd">    and repopulate it but until that happens these regions are</span>
<span class="sd">    excluded from negotiations.</span>

<span class="sd">    Only the net clones and merges are recorded in the records.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO refactor step_idx and walker_idx to superclass</span>

    <span class="c1"># fields for resampling data</span>
    <span class="n">RESAMPLING_FIELDS</span> <span class="o">=</span> <span class="n">CloneMergeResampler</span><span class="o">.</span><span class="n">RESAMPLING_FIELDS</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;region_assignment&#39;</span><span class="p">,)</span>
    <span class="n">RESAMPLING_SHAPES</span> <span class="o">=</span> <span class="n">CloneMergeResampler</span><span class="o">.</span><span class="n">RESAMPLING_SHAPES</span> <span class="o">+</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,)</span>
    <span class="n">RESAMPLING_DTYPES</span> <span class="o">=</span> <span class="n">CloneMergeResampler</span><span class="o">.</span><span class="n">RESAMPLING_DTYPES</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,)</span>

    <span class="c1"># fields that can be used for a table like representation</span>
    <span class="n">RESAMPLING_RECORD_FIELDS</span> <span class="o">=</span> <span class="n">CloneMergeResampler</span><span class="o">.</span><span class="n">RESAMPLING_RECORD_FIELDS</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;region_assignment&#39;</span><span class="p">,)</span>

    <span class="c1"># datatype for the state change records of the resampler, here</span>
    <span class="c1"># that is the defnition of a new branch of the region tree, the</span>
    <span class="c1"># value is the level of the tree that is branched. Most of the</span>
    <span class="c1"># useful information will be in the auxiliary data, like the</span>
    <span class="c1"># image, distance the walker was away from the image at that</span>
    <span class="c1"># level, and the id of the leaf node</span>
    <span class="n">RESAMPLER_FIELDS</span> <span class="o">=</span> <span class="n">CloneMergeResampler</span><span class="o">.</span><span class="n">RESAMPLER_FIELDS</span> <span class="o">+</span> \
                       <span class="p">(</span><span class="s1">&#39;branching_level&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="s1">&#39;new_leaf_id&#39;</span><span class="p">,</span> <span class="s1">&#39;image&#39;</span><span class="p">)</span>
    <span class="n">RESAMPLER_SHAPES</span> <span class="o">=</span> <span class="n">CloneMergeResampler</span><span class="o">.</span><span class="n">RESAMPLER_SHAPES</span> <span class="o">+</span> \
                       <span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="bp">Ellipsis</span><span class="p">,</span> <span class="bp">Ellipsis</span><span class="p">)</span>
    <span class="n">RESAMPLER_DTYPES</span> <span class="o">=</span> <span class="n">CloneMergeResampler</span><span class="o">.</span><span class="n">RESAMPLER_DTYPES</span> <span class="o">+</span> \
                       <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># fields that can be used for a table like representation</span>
    <span class="n">RESAMPLER_RECORD_FIELDS</span> <span class="o">=</span> <span class="n">CloneMergeResampler</span><span class="o">.</span><span class="n">RESAMPLER_RECORD_FIELDS</span> <span class="o">+</span> \
                              <span class="p">(</span><span class="s1">&#39;branching_level&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="s1">&#39;new_leaf_id&#39;</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pmin</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">pmax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                 <span class="n">distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">max_n_regions</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                 <span class="n">max_region_sizes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">),</span>
                 <span class="n">init_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor for the WExploreResampler.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        seed : None or int</span>
<span class="sd">            The random seed. If None the system (random) one will be used.</span>

<span class="sd">        distance : object implementing Distance</span>
<span class="sd">            The distance metric to compare walkers to region images with.</span>

<span class="sd">        init_state : WalkerState object</span>
<span class="sd">            The state that seeds the first region in the region hierarchy.</span>

<span class="sd">        max_n_regions : tuple of int</span>
<span class="sd">            The number of allowed sub-regions for a region at each</span>
<span class="sd">            level of the region hierarchy.</span>

<span class="sd">        max_region_sizes : tuple of float</span>
<span class="sd">            The cutoff distances that trigger the creation of new</span>
<span class="sd">            regions at each level of the hierarchy.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># we call the common methods in the CloneMergeResampler</span>
        <span class="c1"># superclass. We set the min and max number of walkers to be</span>
        <span class="c1"># constant</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pmin</span><span class="o">=</span><span class="n">pmin</span><span class="p">,</span> <span class="n">pmax</span><span class="o">=</span><span class="n">pmax</span><span class="p">,</span>
                         <span class="n">min_num_walkers</span><span class="o">=</span><span class="bp">Ellipsis</span><span class="p">,</span>
                         <span class="n">max_num_walkers</span><span class="o">=</span><span class="bp">Ellipsis</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># TODO refactor out the distance things to a superclass</span>
        <span class="k">assert</span> <span class="n">distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Distance object must be given.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span>

        <span class="k">assert</span> <span class="n">init_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;An initial state must be given.&quot;</span>

        <span class="c1"># the region tree which keeps track of the regions and can be</span>
        <span class="c1"># balanced for cloning and merging between them, is</span>
        <span class="c1"># initialized the first time resample is called because it</span>
        <span class="c1"># needs an initial walker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_region_tree</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rand</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_n_regions</span> <span class="o">=</span> <span class="n">max_n_regions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_n_regions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_region_sizes</span> <span class="o">=</span> <span class="n">max_region_sizes</span> <span class="c1"># in nanometers!</span>


        <span class="c1"># we do not know the shape and dtype of the images until</span>
        <span class="c1"># runtime so we determine them here</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="n">init_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_dtype</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span>


        <span class="c1"># initialize the region tree with the first state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_region_tree</span> <span class="o">=</span> <span class="n">RegionTree</span><span class="p">(</span><span class="n">init_state</span><span class="p">,</span>
                                       <span class="n">max_n_regions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_n_regions</span><span class="p">,</span>
                                       <span class="n">max_region_sizes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_region_sizes</span><span class="p">,</span>
                                       <span class="n">distance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span>
                                       <span class="n">pmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pmin</span><span class="p">,</span>
                                       <span class="n">pmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pmax</span><span class="p">)</span>

<div class="viewcode-block" id="WExploreResampler.resampler_field_shapes"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.WExploreResampler.resampler_field_shapes">[docs]</a>    <span class="k">def</span> <span class="nf">resampler_field_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># index of the image idx</span>
        <span class="n">image_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampler_field_names</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;image&#39;</span><span class="p">)</span>

        <span class="c1"># shapes adding the image shape</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">resampler_field_shapes</span><span class="p">())</span>
        <span class="n">shapes</span><span class="p">[</span><span class="n">image_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span></div>

<div class="viewcode-block" id="WExploreResampler.resampler_field_dtypes"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.WExploreResampler.resampler_field_dtypes">[docs]</a>    <span class="k">def</span> <span class="nf">resampler_field_dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># index of the image idx</span>
        <span class="n">image_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampler_field_names</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;image&#39;</span><span class="p">)</span>

        <span class="c1"># dtypes adding the image dtype</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">resampler_field_dtypes</span><span class="p">())</span>
        <span class="n">dtypes</span><span class="p">[</span><span class="n">image_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_dtype</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">region_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The RegionTree instance used to manage the region hierachy.</span>

<span class="sd">        This is really only used internally to this class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_region_tree</span>


<div class="viewcode-block" id="WExploreResampler.assign"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.WExploreResampler.assign">[docs]</a>    <span class="k">def</span> <span class="nf">assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walkers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign walkers to regions in the tree, with region creation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        walkers : list of Walker objects</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        assignments : list of tuple of int</span>
<span class="sd">            The leaf_id for each walker that it was assigned to.</span>

<span class="sd">        resampler_data : list of dict of str: value</span>
<span class="sd">            The list of resampler records recording each branching event.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">## Assign the walkers based on the current defined Voronoi</span>
        <span class="c1">## images which assign them to bins/leaf-nodes, possibly</span>
        <span class="c1">## creating new regions, do this by calling the method to</span>
        <span class="c1">## &quot;place_walkers&quot;  on the tree which changes the tree&#39;s state</span>
        <span class="n">new_branches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region_tree</span><span class="o">.</span><span class="n">place_walkers</span><span class="p">(</span><span class="n">walkers</span><span class="p">)</span>

        <span class="c1"># data records about changes to the resampler, here is just</span>
        <span class="c1"># the new branches data</span>
        <span class="n">resampler_data</span> <span class="o">=</span> <span class="n">new_branches</span>

        <span class="c1"># the assignments</span>
        <span class="n">assignments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region_tree</span><span class="o">.</span><span class="n">walker_assignments</span><span class="p">)</span>

        <span class="c1"># return the assignments and the resampler records of changed</span>
        <span class="c1"># resampler state, which is addition of new regions</span>
        <span class="k">return</span> <span class="n">assignments</span><span class="p">,</span> <span class="n">resampler_data</span></div>

<div class="viewcode-block" id="WExploreResampler.decide"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.WExploreResampler.decide">[docs]</a>    <span class="k">def</span> <span class="nf">decide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_walkers</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make decisions for resampling for a single step.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        delta_walkers : int</span>
<span class="sd">            The net change in the number of walkers to make.</span>
<span class="sd">             (Default value = 0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        resampling_data : list of dict of str: value</span>
<span class="sd">            The resampling records resulting from the decisions.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">## Given the assignments (which are on the tree nodes) decide</span>
        <span class="c1">## on which to merge and clone</span>

        <span class="c1"># do this by &quot;balancing&quot; the tree. delta_walkers can be</span>
        <span class="c1"># specified to increase or decrease the total number of</span>
        <span class="c1"># walkers</span>
        <span class="n">merge_groups</span><span class="p">,</span> <span class="n">walkers_num_clones</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">region_tree</span><span class="o">.</span><span class="n">balance_tree</span><span class="p">(</span><span class="n">delta_walkers</span><span class="o">=</span><span class="n">delta_walkers</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;merge_groups</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">merge_groups</span><span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Walker number of clones</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">walkers_num_clones</span><span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Walker assignments</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region_tree</span><span class="o">.</span><span class="n">walker_assignments</span><span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Walker weights</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region_tree</span><span class="o">.</span><span class="n">walker_weights</span><span class="p">))</span>

        <span class="c1"># check to make sure we have selected appropriate walkers to clone</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;images_assignments</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region_tree</span><span class="o">.</span><span class="n">regions</span><span class="p">))</span>

        <span class="c1"># take the specs for cloning and merging and generate the</span>
        <span class="c1"># actual resampling actions (instructions) for each walker,</span>
        <span class="c1"># this does not change the state of the resampler or region</span>
        <span class="c1"># tree</span>
        <span class="n">resampling_actions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assign_clones</span><span class="p">(</span><span class="n">merge_groups</span><span class="p">,</span> <span class="n">walkers_num_clones</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_debug_on</span><span class="p">:</span>
            <span class="c1"># check that the actions were performed correctly</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_resampling_data</span><span class="p">(</span><span class="n">resampling_actions</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ResamplerError</span> <span class="k">as</span> <span class="n">resampler_err</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">resampler_err</span><span class="p">)</span>
                <span class="kn">import</span> <span class="nn">ipdb</span><span class="p">;</span> <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>


        <span class="k">return</span> <span class="n">resampling_actions</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_resampling_data</span><span class="p">(</span><span class="n">resampling_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resampling_data :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># in WExplore we don&#39;t increase or decrease the number of</span>
        <span class="c1"># walkers and thus all slots must be filled so we go through</span>
        <span class="c1"># each decision that targets slots in the next stop and</span>
        <span class="c1"># collect all of those</span>

        <span class="n">n_slots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">resampling_data</span><span class="p">)</span>

        <span class="n">taken_slot_idxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">squash_slot_idxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">keep_merge_slot_idxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rec_d</span> <span class="ow">in</span> <span class="n">resampling_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rec_d</span><span class="p">[</span><span class="s1">&#39;decision_id&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
                <span class="n">taken_slot_idxs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rec_d</span><span class="p">[</span><span class="s1">&#39;target_idxs&#39;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">rec_d</span><span class="p">[</span><span class="s1">&#39;decision_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">squash_slot_idxs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rec_d</span><span class="p">[</span><span class="s1">&#39;target_idxs&#39;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">rec_d</span><span class="p">[</span><span class="s1">&#39;decision_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">keep_merge_slot_idxs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rec_d</span><span class="p">[</span><span class="s1">&#39;target_idxs&#39;</span><span class="p">])</span>


        <span class="c1"># see if there are any repeated targets</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">taken_slot_idxs</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">taken_slot_idxs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ResamplerError</span><span class="p">(</span><span class="s2">&quot;repeated slots to be used&quot;</span><span class="p">)</span>

        <span class="c1"># check that the number of targets is exactly the number of slots available</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">taken_slot_idxs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_slots</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ResamplerError</span><span class="p">(</span><span class="s2">&quot;Number of slots used is less than the number of slots&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">taken_slot_idxs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_slots</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ResamplerError</span><span class="p">(</span><span class="s2">&quot;Number of slots used is greater than the number of slots&quot;</span><span class="p">)</span>

        <span class="c1"># check that all squashes are going to a merge slot</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="kc">False</span> <span class="k">if</span> <span class="n">squash_slot_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep_merge_slot_idxs</span> <span class="k">else</span> <span class="kc">True</span>
         <span class="k">for</span> <span class="n">squash_slot_idx</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">squash_slot_idxs</span><span class="p">)]):</span>
            <span class="k">raise</span> <span class="n">ResamplerError</span><span class="p">(</span><span class="s2">&quot;Not all squashes are assigned to keep_merge slots&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_resample_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walkers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        walkers :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_resample_init</span><span class="p">(</span><span class="n">walkers</span><span class="o">=</span><span class="n">walkers</span><span class="p">)</span>

        <span class="c1"># then get the walker nums using our methods to get it for</span>
        <span class="c1"># this resampling and just give that to the region tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region_tree</span><span class="o">.</span><span class="n">max_num_walkers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_walkers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region_tree</span><span class="o">.</span><span class="n">min_num_walkers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_num_walkers</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_debug_on</span><span class="p">:</span>

            <span class="c1"># cache a copy of the region_tree in its state before putting</span>
            <span class="c1"># these walkers through it so we can replay steps if necessary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cached_region_tree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_region_tree</span><span class="p">)</span>

            <span class="c1"># and keep the walkers too</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_input_walkers</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">walkers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_resample_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resampling_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">resampler_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">resampled_walkers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resampling_data :</span>
<span class="sd">            </span>
<span class="sd">        resampler_data :</span>
<span class="sd">            </span>
<span class="sd">        resampled_walkers :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_debug_on</span><span class="p">:</span>

            <span class="c1"># check that the weights of the resampled walkers are not</span>
            <span class="c1"># beyond the bounds of what they are supposed to be</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_resampled_walkers</span><span class="p">(</span><span class="n">resampled_walkers</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ResamplerError</span> <span class="k">as</span> <span class="n">resampler_err</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">resampler_err</span><span class="p">)</span>
                <span class="kn">import</span> <span class="nn">ipdb</span><span class="p">;</span> <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

                <span class="c1"># keep the tree we just used</span>
                <span class="n">curr_region_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_region_tree</span>

                <span class="c1"># replace the region tree with the cached region_tree</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_region_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_region_tree</span>

                <span class="c1"># then run resample again with the original walkers</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_walkers</span><span class="p">)</span>

                <span class="c1"># then reset the old region tree</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_region_tree</span> <span class="o">=</span> <span class="n">curr_region_tree</span>

                <span class="c1"># and clean out the debug variables</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_region_tree</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_walkers</span>

        <span class="c1"># clear the tree of walker information for the next resampling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region_tree</span><span class="o">.</span><span class="n">clear_walkers</span><span class="p">()</span>

        <span class="c1"># just use the superclass method</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_resample_cleanup</span><span class="p">()</span>

        <span class="c1"># then get the walker nums using our methods to get it for</span>
        <span class="c1"># this resampling and just give that to the region tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region_tree</span><span class="o">.</span><span class="n">max_num_walkers</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region_tree</span><span class="o">.</span><span class="n">min_num_walkers</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="WExploreResampler.resample"><a class="viewcode-back" href="../../../../api/wepy.resampling.resamplers.wexplore.html#wepy.resampling.resamplers.wexplore.WExploreResampler.resample">[docs]</a>    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walkers</span><span class="p">):</span>

        <span class="c1"># do some initialiation routines and debugging preparations if</span>
        <span class="c1"># necessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resample_init</span><span class="p">(</span><span class="n">walkers</span><span class="o">=</span><span class="n">walkers</span><span class="p">)</span>

        <span class="c1">## assign/score the walkers, also getting changes in the</span>
        <span class="c1">## resampler state</span>
        <span class="n">assignments</span><span class="p">,</span> <span class="n">resampler_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">walkers</span><span class="p">)</span>


        <span class="c1"># make the decisions for the the walkers for only a single</span>
        <span class="c1"># step</span>
        <span class="n">resampling_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decide</span><span class="p">(</span><span class="n">delta_walkers</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># add the walker idxs</span>
        <span class="k">for</span> <span class="n">walker_idx</span><span class="p">,</span> <span class="n">walker_record</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">resampling_data</span><span class="p">):</span>
            <span class="n">walker_record</span><span class="p">[</span><span class="s1">&#39;walker_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">walker_idx</span>

        <span class="c1"># perform the cloning and merging, the action function expects</span>
        <span class="c1"># records a lists of lists for steps and walkers</span>
        <span class="n">resampled_walkers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DECISION</span><span class="o">.</span><span class="n">action</span><span class="p">(</span><span class="n">walkers</span><span class="p">,</span> <span class="p">[</span><span class="n">resampling_data</span><span class="p">])</span>

        <span class="c1"># normally decide is only for a single step and so does not</span>
        <span class="c1"># include the step_idx, so we add this to the records</span>
        <span class="k">for</span> <span class="n">walker_idx</span><span class="p">,</span> <span class="n">walker_record</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">resampling_data</span><span class="p">):</span>

            <span class="n">walker_record</span><span class="p">[</span><span class="s1">&#39;step_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># convert the target idxs and decision_id to feature vector arrays</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">resampling_data</span><span class="p">:</span>
            <span class="n">record</span><span class="p">[</span><span class="s1">&#39;target_idxs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="s1">&#39;target_idxs&#39;</span><span class="p">])</span>
            <span class="n">record</span><span class="p">[</span><span class="s1">&#39;decision_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">record</span><span class="p">[</span><span class="s1">&#39;decision_id&#39;</span><span class="p">]])</span>
            <span class="n">record</span><span class="p">[</span><span class="s1">&#39;walker_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">record</span><span class="p">[</span><span class="s1">&#39;walker_idx&#39;</span><span class="p">]])</span>


        <span class="c1"># then add the assignments and distance to image for each walker</span>
        <span class="k">for</span> <span class="n">walker_idx</span><span class="p">,</span> <span class="n">assignment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">assignments</span><span class="p">):</span>
            <span class="n">resampling_data</span><span class="p">[</span><span class="n">walker_idx</span><span class="p">][</span><span class="s1">&#39;region_assignment&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assignment</span>



        <span class="bp">self</span><span class="o">.</span><span class="n">_resample_cleanup</span><span class="p">(</span><span class="n">resampling_data</span><span class="o">=</span><span class="n">resampling_data</span><span class="p">,</span>
                               <span class="n">resampler_data</span><span class="o">=</span><span class="n">resampler_data</span><span class="p">,</span>
                               <span class="n">resampled_walkers</span><span class="o">=</span><span class="n">resampled_walkers</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">resampled_walkers</span><span class="p">,</span> <span class="n">resampling_data</span><span class="p">,</span> <span class="n">resampler_data</span></div></div>


</pre></div>

          </div>
            
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">wepy  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="../../../../_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2018, Samuel D. Lotz. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>