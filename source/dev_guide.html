
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Development &#8212; wepy 1.0.0rc6 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="development">
<h1>Development<a class="headerlink" href="#development" title="Permalink to this headline">¶</a></h1>
<div class="section" id="getting-set-up">
<h2>Getting Set Up<a class="headerlink" href="#getting-set-up" title="Permalink to this headline">¶</a></h2>
<div class="section" id="obtaining-the-source-code">
<h3>Obtaining the source code<a class="headerlink" href="#obtaining-the-source-code" title="Permalink to this headline">¶</a></h3>
<p>We do development on github:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git clone https://github.com/ADicksonLab/wepy --recurse-submodules
<span class="nb">cd</span> wepy
</pre></div>
</div>
</div>
<div class="section" id="tooling">
<h3>Tooling<a class="headerlink" href="#tooling" title="Permalink to this headline">¶</a></h3>
<p>To make things easier for developers we provide a set automation scripts
implemented in <code class="docutils literal notranslate"><span class="pre">invoke</span></code> (similar to a makefile if you are familiar
with that).</p>
<p>So you will want to install invoke somehow to use this tooling. The
easiest most contained way to do this we have found is to use <code class="docutils literal notranslate"><span class="pre">pipx</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pipx install invoke
</pre></div>
</div>
</div>
<div class="section" id="virtual-environments">
<h3>Virtual Environments<a class="headerlink" href="#virtual-environments" title="Permalink to this headline">¶</a></h3>
<p>This is for managing environments which are just for the purpose of
developing wepy, and not necessarily just for running it (as a user).
See <em>Managing Dependencies</em> for details on managing dependencies of the
installable project.</p>
<p>To develop on <code class="docutils literal notranslate"><span class="pre">wepy</span></code> we require OpenMM. By far the easiest way to get
this is to use conda. Since we already dependent on anaconda for this we
currently also use anaconda virtual environments rather than the
standard library ones. It also makes a few things we depend on like
<code class="docutils literal notranslate"><span class="pre">pandoc</span></code> easier to install for building docs.</p>
<p>We also require a few shell environmental variables which are exported
in the <code class="docutils literal notranslate"><span class="pre">env.bash</span></code> file. Go ahead and source this before doing anything
else:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> env.bash
</pre></div>
</div>
<p>To create an env called <code class="docutils literal notranslate"><span class="pre">wepy.dev</span></code> just run the <code class="docutils literal notranslate"><span class="pre">env</span></code> target from
<code class="docutils literal notranslate"><span class="pre">invoke</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>inv env
</pre></div>
</div>
<p>Then activate it:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>conda activate wepy.dev
</pre></div>
</div>
<p>If you ever have problems with an environment just rerun this to get a
clean one. A practice we encourage to do frequently so that developers
don’t diverge in their envs with local modifications. So while you can
make your env, try to use this one unless you have problems.</p>
<p>We maintain a number of preconfigured environments in the <code class="docutils literal notranslate"><span class="pre">envs</span></code>
directory which are used for different purposes. Calling <code class="docutils literal notranslate"><span class="pre">inv</span> <span class="pre">env</span> <span class="pre">-n</span>
<span class="pre">dev</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">inv</span> <span class="pre">dev</span></code> since it is the default, but any other
environment can be created by passing the matching name. For instance
there is an environment that mimics the user’s installation environment
so that we can test experiences upon install, to make sure we haven’t
accidentally depended on something in the dev env. For instance:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>inv env -n trial
conda activate wepy.trial
</pre></div>
</div>
<p>If you want to make another environment it is straightforward to copy
the examples in the <code class="docutils literal notranslate"><span class="pre">envs</span></code> dir.</p>
</div>
</div>
<div class="section" id="tasks">
<h2>Tasks<a class="headerlink" href="#tasks" title="Permalink to this headline">¶</a></h2>
<div class="section" id="licenses-and-copyright">
<h3>Licenses and Copyright<a class="headerlink" href="#licenses-and-copyright" title="Permalink to this headline">¶</a></h3>
<p>The license can be found in the LICENSE file and shouldn’t need to be
updated usually.</p>
<p>However, according to copyright laws (hand waves…) the original date in
the license establishes the earliest copyright claim to the work. The
date shouldn’t need updated in principle. The only thing you could do is
add dates to this. Adding dates may be useful if significant changes to
the software are made.</p>
<p>So rule of thumbs are:</p>
<ul class="simple">
<li><p>never remove the original date in the license copyright</p></li>
<li><p>you can add dates if you want when you make big changes, but it is
probably not necessary</p></li>
</ul>
</div>
<div class="section" id="managing-dependencies">
<h3>Managing Dependencies<a class="headerlink" href="#managing-dependencies" title="Permalink to this headline">¶</a></h3>
<p>Reminder that there are two separate goals of managing dependencies and
where they are managed:</p>
<dl class="simple">
<dt>Python Libraries</dt><dd><p>These dependencies are managed in <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> and in PyPI or other
indices.</p>
</dd>
<dt>Python Applications/Deployments</dt><dd><p>These are dependencies managed in
<code class="docutils literal notranslate"><span class="pre">requirements.in~/~requirements.txt</span></code> and used for developer
environments and deployment environments.</p>
</dd>
</dl>
<p>So for the library aspect we use abstract requirements. These should
essentially be the same as <code class="docutils literal notranslate"><span class="pre">requirements.in</span></code>.</p>
<p>For the deployment side of things we use <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>. Don’t
manually edit this. We use <code class="docutils literal notranslate"><span class="pre">pip-tools</span></code> to “compile” dependencies for
this.</p>
<p>To initially pin an environment or when you add requirements run this
target:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>inv deps-pin
</pre></div>
</div>
<p>To update it (should be accompanied by a reason why):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>inv deps-pin-update
</pre></div>
</div>
</div>
<div class="section" id="documentation-and-website">
<h3>Documentation and Website<a class="headerlink" href="#documentation-and-website" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>Editing and Building Docs</p>
<p>To compile and build the docs just run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>inv docs-build
</pre></div>
</div>
<p>Which will output them to a temporary build directory
<code class="docutils literal notranslate"><span class="pre">_build/html</span></code>.</p>
<p>You can clean this build with:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>inv clean-docs
</pre></div>
</div>
<p>To view how the docs would look as a website you can point your
browser at the <code class="docutils literal notranslate"><span class="pre">_build/html</span></code> folder or run a python http web server
with this target:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>inv docs-serve
</pre></div>
</div>
</li>
<li></li>
<li><p>Deploying the website</p>
<p>We are using github pages. To avoid having to keep the entire built
website in the main tree we use the alternate <code class="docutils literal notranslate"><span class="pre">gh-pages</span></code> branch. To
make this process easy to deploy we have a script
<code class="docutils literal notranslate"><span class="pre">sphinx/deploy.sh</span></code> that checks the <code class="docutils literal notranslate"><span class="pre">gh-pages</span></code> branch out, does
some necessary cleaning up, and copies the built website to the
necesary folder (which is the toplevel), commits the changes and
pushes to github, and then returns to your working branch.</p>
<p>The invoke target is:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>inv website-deploy
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="testing">
<h3>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>Getting the wepy-tests submodule</p>
<p>The tests for wepy are included as a submodule because some of the
associated data is large and we want to make the install base for the
program smaller than that. Development of this is tracked in
<a class="reference external" href="https://gitlab.com/salotz/wepy-tests">https://gitlab.com/salotz/wepy-tests</a>.</p>
<p>If you cloned without the recurse-submodules flag you can always pull
them in later like this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git submodule update --init --recursive
</pre></div>
</div>
<p>WARNING: before you start editing the <code class="docutils literal notranslate"><span class="pre">wepy-tests</span></code> submodule you
need to check out master.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git checkout master
</pre></div>
</div>
<p>How many times I have edited it before I checked out master…</p>
<p>If you do edit and commit try to get the hash of the commit and then
merge with master. If you don’t then you need to figure out which
commit that was.</p>
</li>
</ol>
</div>
<div class="section" id="code-quality-metrics">
<h3>Code Quality Metrics<a class="headerlink" href="#code-quality-metrics" title="Permalink to this headline">¶</a></h3>
<p>Just run the end target:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>inv quality
</pre></div>
</div>
<p>This will write files to <code class="docutils literal notranslate"><span class="pre">metrics</span></code>.</p>
</div>
<div class="section" id="releases">
<h3>Releases<a class="headerlink" href="#releases" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>Choosing a version number</p>
<dl class="simple">
<dt>semver</dt><dd><p>major, minor, patch</p>
</dd>
</dl>
<ul class="simple">
<li><p>release candidates</p></li>
<li><p>dev</p></li>
<li><p>post release</p></li>
</ul>
</li>
<li><p>Changing the version number</p>
<p>You can check the current version number with this command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>inv version-which
</pre></div>
</div>
<p>Increase the version number we currently do it by hand (although an
automatic way would be nice and <code class="docutils literal notranslate"><span class="pre">bumpversion</span></code> wasn’t working for
us). So go in and manually edit them. For reference see PEP 440 for
valid ones.</p>
<p>The targets are in the <code class="docutils literal notranslate"><span class="pre">.bumpversion.cfg</span></code> for reference, but at a
high level:</p>
<ul class="simple">
<li><p>[ ] <code class="docutils literal notranslate"><span class="pre">setup.py</span></code></p></li>
<li><p>[ ] <code class="docutils literal notranslate"><span class="pre">src/wepy/__init__.py</span></code></p></li>
<li><p>[ ] <code class="docutils literal notranslate"><span class="pre">sphinx/config.py</span></code></p></li>
<li><p>[ ] <code class="docutils literal notranslate"><span class="pre">conda/conda-forge/meta.yaml</span></code></p></li>
</ul>
</li>
</ol>
</div>
</div>
</div>
<div class="section" id="architecture">
<h1>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h1>
<div class="section" id="record-groups">
<h2>Record Groups<a class="headerlink" href="#record-groups" title="Permalink to this headline">¶</a></h2>
<p>The protocol by which non-trajectory data is given by the resampler and
boundary conditions (BC) is unified that makes it simpler to save in
formats like HDF5.</p>
<p>The resampler and BC both have multiple record groups:</p>
<ul class="simple">
<li><p>resampler</p>
<ul>
<li><p>resampling</p></li>
<li><p>resampler</p></li>
</ul>
</li>
<li><p>BC</p>
<ul>
<li><p>warping</p></li>
<li><p>progress</p></li>
<li><p>boundary conditions</p></li>
</ul>
</li>
</ul>
<p>A record group can be thought of as a single table in a relational
database. Each record group corresponds to a class of events that occur
and each record in a record group corresponds to one event.</p>
<p>Record groups can be <strong>continual</strong> or <strong>sporadic</strong>.</p>
<p>A continual record is recorded once per cycle. A continual record
reports on the event of a cycle.</p>
<p>A sporadic record can be reported 0 or many times per cycle and responds
to the event determined by the record group.</p>
<ul class="simple">
<li><p>continual</p>
<ul>
<li><p>progress</p></li>
</ul>
</li>
<li><p>sporadic</p>
<ul>
<li><p>resampler</p></li>
<li><p>resampling</p></li>
<li><p>warping</p></li>
<li><p>boundary conditions</p></li>
</ul>
</li>
</ul>
<p>As you can see currently most records are sporadic. This distinction is
really only used internally within the <code class="docutils literal notranslate"><span class="pre">WepyHDF5</span></code> class to distinguish
how it stores them, but this distinction is useful in data analysis as
well.</p>
<p>Resampling Records</p>
<p>The <code class="docutils literal notranslate"><span class="pre">'resampling'</span></code> records are probably the most important records for
<code class="docutils literal notranslate"><span class="pre">wepy</span></code> because they are what records the cloning and merging of
walkers.</p>
<p>Without the <code class="docutils literal notranslate"><span class="pre">'resampling'</span></code> your <code class="docutils literal notranslate"><span class="pre">wepy</span></code> simulation would have been
wasted since you no longer will know the history of any given frame. You
will just have a bag full of unconnected pictures.</p>
<p>Records for <code class="docutils literal notranslate"><span class="pre">'resampling'</span></code> happen for each “assignment” event of a
walker during resampling, this minimally should contain two fields:
<code class="docutils literal notranslate"><span class="pre">'decision_id'</span></code> and <code class="docutils literal notranslate"><span class="pre">'target_idxs'</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">'decision_id'</span></code> is an integer corresponding to an enumeration of
the possible decisions that can be made as to the fate of the walker
during resampling. While technically these decisions are also modular it
is likely that 99.9% of all users will use the <code class="docutils literal notranslate"><span class="pre">CloneMergeDecision</span></code>.</p>
<p>Detailed knowledge of this formalism is not usually needed in the
practice of writing resamplers that behave well, which is another topic,
and the next few paragraphs can be safely skipped.</p>
<p>The enumerated decisions in this are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 93%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">NOTHING</span></code></p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">CLONE</span></code></p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SQUASH</span></code></p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">KEEP_MERGE</span></code></p></td>
<td><p>4</p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">NOTHING</span></code> decision means don’t clone or merge this walker.</p>
<p><code class="docutils literal notranslate"><span class="pre">CLONE</span></code> means clone this walker.</p>
<p><code class="docutils literal notranslate"><span class="pre">SQUASH</span></code> and <code class="docutils literal notranslate"><span class="pre">KEEP_MERGE</span></code> are related in that both involve merging.</p>
<p>A single merge includes a set of walkers that will be merged together,
there must be at least 2 such walkers in this “merge group”.</p>
<p>From the merge group only a single <em>state</em> will be preserved in the
single resulting walker, while the weight of the final walker will be
the sum of all those walkers.</p>
<p>The state of the final walker will be drawn from the set of walkers in
the merge group based on the behavior of the resampler (usually a choice
weighted by their weights), but will always be identical to one of the
walkers. The walker with the chosen state is the <code class="docutils literal notranslate"><span class="pre">KEEP_MERGE</span></code> walker.
The rest are the <code class="docutils literal notranslate"><span class="pre">SQUASH</span></code> walkers.</p>
<p>The second field, <code class="docutils literal notranslate"><span class="pre">'target_idxs'</span></code>, actually determines which walkers
will be merged with what other walkers, and is a tuple of integers
indicating the location, or slot.</p>
<p>A ‘slot’ is simply an available position in the lineup of walkers that
will be simulated in a single cycle of WE. The number of slots is the
number of walkers that will be simulated in the next cycle.</p>
<p>As an aside: In general the number of walkers used in a WE simulation is
not specified (other than there needs to be more than 1). You can have a
constant number of walkers, or a dynamic one with the number fluctuating
during the simulation.</p>
<p>If you have too small a number of walkers then you will have a
relatively sparse coverage of the sample space.</p>
<p>If you have too many the cycle throughput will be very slow.</p>
<p>Additionally, simulations run with GPUs will want to have a number of
walkers each cycle that is a multiple of the number of GPUs or a number
of the GPUs will be lying idle when the task queue of running walker
runner segments is depleted.</p>
<p>So typically there is some constraint on the the number of slots
available in the next WE cycle. The constraint is decided on and
enforced by the resampler. So if there is a mismatch in the resampling
records and the walkers produced the <code class="docutils literal notranslate"><span class="pre">wepy</span></code> simulation manager will
not complain.</p>
<p>WARNING: Currently the <code class="docutils literal notranslate"><span class="pre">WepyHDF5</span></code> storage backend and reporter do not
support dynamic numbers of simulations. While technically the none of
the other code has any problem with this.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">'target_idxs'</span></code> value for <code class="docutils literal notranslate"><span class="pre">NOTHING</span></code> and <code class="docutils literal notranslate"><span class="pre">KEEP_MERGE</span></code> is a
1-tuple of the integer index of slot where the resultant walker will be
placed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">'target_idxs'</span></code> for <code class="docutils literal notranslate"><span class="pre">CLONE</span></code> is an n-tuple of integer indices of
slots where n is the number of children of the clone and n must be at
least 2 (or it would’ve been a <code class="docutils literal notranslate"><span class="pre">NOTHING</span></code>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">'target_idxs'</span></code> of <code class="docutils literal notranslate"><span class="pre">SQUASH</span></code> is also a 1-tuple like <code class="docutils literal notranslate"><span class="pre">NOTHING</span></code>
except since a <code class="docutils literal notranslate"><span class="pre">SQUASH</span></code> has no child it indicates the <code class="docutils literal notranslate"><span class="pre">KEEP_MERGE</span></code>
walker that it’s weight is added to. Note that this slot index is the
slot index that the <code class="docutils literal notranslate"><span class="pre">KEEP_MERGE</span></code> record itself specifies and not the
slot the <code class="docutils literal notranslate"><span class="pre">KEEP_MERGE</span></code> walker previously occupied (as that index is of
no consequence to the current collection of walkers).</p>
<p>Thus a <code class="docutils literal notranslate"><span class="pre">KEEP_MERGE</span></code> walker defines a single merge group, and the
members of that merge group are given by which <code class="docutils literal notranslate"><span class="pre">SQUASH</span></code> targets.</p>
<p>Critically, the <code class="docutils literal notranslate"><span class="pre">'step_idx'</span></code> and <code class="docutils literal notranslate"><span class="pre">'walker_idx'</span></code> (slot index of
walker in last cycle) fields should also be supplied so that the lineage
histories can be generated.</p>
<p>In addition to the Decision class record fields any other amount of data
can be attached to these records to report on a resampling event.</p>
<p>For example in the WExplore resampler the region the walker was assigned
to is also given.</p>
<p>Warping Records</p>
<p>The next most important record is the warping records.</p>
<p>These are of course only relevant if you are using boundary conditions,
but among the three BC these are the principal object.</p>
<p>Warping records determine the action that was taken on a walker after it
met the criteria for a boundary condition event.</p>
<p>Minimally it should specify the <code class="docutils literal notranslate"><span class="pre">'walker_idx'</span></code> that was acted on, and
if any warping event can be discontinuous the ‘weight’ of it so this can
be accounted for in analysis.</p>
<p>The rest of the specification for boundary conditions does not have a
protocol similar to the one for cloning and merging records and is left
up to the developer of the class to decide.</p>
<p>For simple boundary conditions where there is only one result an
additional field is not even necesary.</p>
<p>The colored trajectories examples provides a possible example. In this
case you could have a field called <code class="docutils literal notranslate"><span class="pre">'color'</span></code> which is the new “color”
of the walker which indicates the last boundary it crossed and could be
a string or an integer enumeration.</p>
<p>Boundary Condition Records</p>
<p>This and all the other record groups are really optional.</p>
<p>A single boundary condition record reports on the event of a change in
the state of the boundary condition object.</p>
<p>For example if the cutoff value for a ligand unbinding boundary
condition changes during a simulation.</p>
<p>Resampler Records</p>
<p>These records report on events changing of the state of the resampler.</p>
<p>For example in WExplore a single record is generated every time a new
region/image is defined giving details on the values that triggered this
event as well as the image that was created.</p>
<p>This interpretation is semantically useful but in practice this reporter
could also report on collective attributes of the walkers, such as
all-to-all distances or histograms of the current batch of walkers.</p>
<p>Its up to the writer of the resampler to decide.</p>
<p>Progress Records</p>
<p>Progress records are provided mainly as a convenience to get on-line
data analysis of walkers during a simulation.</p>
<p>For instance in ligand unbinding the progress may be the distance to the
cutoff, or RMSD to the original state.</p>
<p>While the active observer may note that these calculations may also have
been implemented in a reporter as well.</p>
<p>There are a few tradeoffs for that approach though.</p>
<p>One, the value may have already been calculated in the process of
evaluating walkers for warping and double calculation is potentially
unacceptably wasteful (although one might imagine complex systems where
reporters perform their actions asynchronously to the flow of the
simulation manager moving onto new cycles).</p>
<p>Second, the flow of data will be forked. For example when using the
<code class="docutils literal notranslate"><span class="pre">WepyHDF5Reporter</span></code> all the data it will report on is assumed to be
contained in records returned by the runner, resampler, and boundary
conditions and can’t know of another reporter. Nor is it easy nor wise
to have two reporters acting on the same database.</p>
<p>Perhaps such analysis could be implemented as analysis submodules in the
<code class="docutils literal notranslate"><span class="pre">WepyHDF5Reporter</span></code> to keep a single stream of data, if you think that
way go ahead and make a pull request.</p>
<div class="section" id="specifying-record-group-fields">
<h3>Specifying Record Group Fields<a class="headerlink" href="#specifying-record-group-fields" title="Permalink to this headline">¶</a></h3>
<p>Each record group should have three class constants defined for it.</p>
<p>This is strictly not necessary from the perspective of either the
simulation manager or the primary consumer of these records, the
<code class="docutils literal notranslate"><span class="pre">WepyHDF5Reporter</span></code>, but is a very good practice as it will help catch
bugs and will clarify the results your BC or resampler will produce for
those inspecting them.</p>
<p>The three definitions are:</p>
<ul class="simple">
<li><p>field names</p></li>
<li><p>shapes</p></li>
<li><p>dtypes</p></li>
</ul>
<p>Each should be defined as a class constant prefixed by the name of the
record group followed by the definition type, for example the resampling
record group of WExplore looks like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">DECISION</span> <span class="o">=</span> <span class="n">MultiCloneMergeDecision</span>
<span class="n">RESAMPLING_FIELDS</span> <span class="o">=</span> <span class="n">DECISION</span><span class="o">.</span><span class="n">FIELDS</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;step_idx&#39;</span><span class="p">,</span> <span class="s1">&#39;walker_idx&#39;</span><span class="p">,</span> <span class="s1">&#39;region_assignment&#39;</span><span class="p">,)</span>
<span class="n">RESAMPLING_SHAPES</span> <span class="o">=</span> <span class="n">DECISION</span><span class="o">.</span><span class="n">SHAPES</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="bp">Ellipsis</span><span class="p">,)</span>
<span class="n">RESAMPLING_DTYPES</span> <span class="o">=</span> <span class="n">DECISION</span><span class="o">.</span><span class="n">DTYPES</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,)</span>
</pre></div>
</div>
<p>For the “fields” this is the name of the field and should be a string.
In the example we are using fields defined from the
<code class="docutils literal notranslate"><span class="pre">MultiCloneMergeDecision</span></code> class.</p>
<p>The shapes are the expected shapes of a single element of the field.
Three types of values are accepted here:</p>
<ol class="upperalpha simple">
<li><p>A tuple of ints that specify the shape of the field element array.</p></li>
</ol>
<p>B. Ellipsis, indicating that the field is variable length and limited to
being a rank one array (e.g. <code class="docutils literal notranslate"><span class="pre">(3,)</span></code> or <code class="docutils literal notranslate"><span class="pre">(1,)</span></code>).</p>
<p>C. None, indicating that the first instance of this field will not be
known until runtime. Any field that is returned by a record producing
method will automatically interpreted as None if not specified here.</p>
<p>Note that the shapes must be tuple and not simple integers for rank-1
arrays.</p>
<p>It is suggested that if possible use option A. Option B will use a
special datatype in HDF5 for variable length datasets that can only be 1
dimensional, in addition to being much less efficient to store.</p>
<p>Option C is not advisable but is there because I know people will be
lazy and not want to define all these things. By defining things ahead
of time you will reduce errors by catching differences in what you
expect a field to look like and what you actually receive at runtime.</p>
<p>If you are actually saving the wrong thing and don’t specify the shape
and dtype then you may run weeks of simulations and never realize you
never saved the right thing there.</p>
<p>The dtypes have similar options but there is no Ellipsis option.</p>
<p>Each non-None dtype should be a numpy dtype object. This is necessary
for serializing the datatype to the HDF5 (using the
<code class="docutils literal notranslate"><span class="pre">numpy.dtype.descr</span></code> attribute).</p>
</div>
<div class="section" id="record-fields">
<h3>Record Fields<a class="headerlink" href="#record-fields" title="Permalink to this headline">¶</a></h3>
<p>One additional class constant can be defined to make analysis in the
future easier.</p>
<p>When accessing records from a <code class="docutils literal notranslate"><span class="pre">WepyHDF5</span></code> object you can automatically
generate <code class="docutils literal notranslate"><span class="pre">pandas.DataFrames</span></code> from the records, which will select from
a subset of the fields for a record group. This is because large arrays
don’t fit well into tables!</p>
<p>So you can define a subset of fields to be used as a nice “table” report
that could be serialized to CSV. For instance in WExplore’s resampler
record group we leave out the multidimensional <code class="docutils literal notranslate"><span class="pre">'image'</span></code> field:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">RESAMPLER_FIELDS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;branching_level&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="s1">&#39;new_leaf_id&#39;</span><span class="p">,</span> <span class="s1">&#39;image&#39;</span><span class="p">)</span>
<span class="n">RESAMPLER_SHAPES</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="bp">Ellipsis</span><span class="p">,</span> <span class="bp">Ellipsis</span><span class="p">)</span>
<span class="n">RESAMPLER_DTYPES</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># fields that can be used for a table like representation</span>
<span class="n">RESAMPLER_RECORD_FIELDS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;branching_level&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="s1">&#39;new_leaf_id&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, its not necessary, but its there to use.</p>
</div>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/wepy.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">wepy</h1>
    
  </a>
</p>



<p class="blurb">A Weighted Ensemble  (WE) simulation framework</p>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_source/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_source/quick_start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_source/introduction.html">Introduction &amp; Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_source/introduction.html#bibliography">Bibliography</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_source/tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_source/users_guide.html">User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_source/troubleshooting.html">Common Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_source/troubleshooting.html#faq">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_source/reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_source/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_source/api.html">API Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_api/modules.html">Full API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_source/general_info.html">General Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_source/news.html">News and Updates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_source/changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_source/dev_guide.html">Development Guide</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Samuel D. Lotz.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/source/dev_guide.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/ADicksonLab/wepy" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>