<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Continue the Simulation &#8212; Wepy Documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=2d51484f" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/basic.css?v=47a5fdc3" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=bc181c52" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css?v=4f057836" />
    <script src="../../../../_static/documentation_options.js?v=2413df15"></script>
    <script src="../../../../_static/doctools.js?v=dcc2bf79"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="canonical" href="https://adicksonlab.github.io/wepy/_source/tutorials/multiple_runs/continue_simulation/README.html" />
    <link rel="icon" href="../../../../_static/wepy-icon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Merge Multiple Simulation Data" href="../merge_data/README.html" />
    <link rel="prev" title="Starting Parallel Runs" href="../parallel_runs/README.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="../parallel_runs/README.html" title="Previous document">Starting Parallel Runs</a>
        </li>
        <li>
          <a href="../merge_data/README.html" title="Next document">Merge Multiple Simulation Data</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="continue-the-simulation">
<h1>Continue the Simulation<a class="headerlink" href="#continue-the-simulation" title="Link to this heading">¶</a></h1>
<p>Easiest way to continue a wepy simulation is to use the pickle file that was saved in the previous simulation. You can use the walker states from the previous simulation to continue where you left off. It is a good idea to seperate the folders of the two simulations to avoid any confusion. Later on, you can merge the hdf5 files and continue your analysis. Let’s first define the input and output directories for the new simulation, input being the previous simulation folder.</p>
<p>While initializing the previous simulation, we set up a WalkerPklReporter to save the simulation state. Depending on the parameters you set, you can find the last pickkle files in your simulation folder. For example, if you have <cite>num_backups=1</cite> and <cite>save_dir=’pkls’</cite>, you can find the state of the last cycle in <cite>pkls/walkers_cycle_&lt;last_cycle&gt;.pkl</cite>.</p>
<p>Let’s start by importing the necessary libraries for the new simulation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">osp</span>
<span class="kn">import</span> <span class="nn">pickle</span> <span class="k">as</span> <span class="nn">pkl</span>

<span class="kn">import</span> <span class="nn">simtk.openmm.app</span> <span class="k">as</span> <span class="nn">omma</span>
<span class="kn">import</span> <span class="nn">simtk.openmm</span> <span class="k">as</span> <span class="nn">omm</span>
<span class="kn">import</span> <span class="nn">simtk.unit</span> <span class="k">as</span> <span class="nn">unit</span>

<span class="kn">import</span> <span class="nn">mdtraj</span> <span class="k">as</span> <span class="nn">mdj</span>

<span class="kn">from</span> <span class="nn">wepy.sim_manager</span> <span class="kn">import</span> <span class="n">Manager</span>
<span class="kn">from</span> <span class="nn">wepy.resampling.resamplers.revo</span> <span class="kn">import</span> <span class="n">REVOResampler</span>
<span class="kn">from</span> <span class="nn">wepy.resampling.distances.receptor</span> <span class="kn">import</span> <span class="n">UnbindingDistance</span>
<span class="kn">from</span> <span class="nn">wepy.runners.openmm</span> <span class="kn">import</span> <span class="n">OpenMMGPUWalkerTaskProcess</span><span class="p">,</span> <span class="n">OpenMMRunner</span><span class="p">,</span> <span class="n">OpenMMWalker</span><span class="p">,</span> <span class="n">OpenMMState</span><span class="p">,</span> <span class="n">gen_sim_state</span>
<span class="kn">from</span> <span class="nn">wepy.boundary_conditions.receptor</span> <span class="kn">import</span> <span class="n">UnbindingBC</span>
<span class="kn">from</span> <span class="nn">wepy.reporter.hdf5</span> <span class="kn">import</span> <span class="n">WepyHDF5Reporter</span>
<span class="kn">from</span> <span class="nn">wepy.work_mapper.task_mapper</span> <span class="kn">import</span> <span class="n">TaskMapper</span>
<span class="kn">from</span> <span class="nn">wepy.util.mdtraj</span> <span class="kn">import</span> <span class="n">mdtraj_to_json_topology</span>

<span class="kn">from</span> <span class="nn">walker_pkl_reporter</span> <span class="kn">import</span> <span class="n">WalkersPickleReporter</span>

<span class="kn">from</span> <span class="nn">wepy.reporter.dashboard</span> <span class="kn">import</span> <span class="n">DashboardReporter</span>
<span class="kn">from</span> <span class="nn">wepy.reporter.openmm</span> <span class="kn">import</span> <span class="n">OpenMMRunnerDashboardSection</span>
</pre></div>
</div>
<p>Let’s assume that your previous run had 150 cycles and you want to continue the simulation with 150 more cycles. Since the cycle indices start from 0, 150th cycle will have the index of 149. You can confirm how many cycles that your previous run had by (1) checking the last pickle file or (2) in <cite>wepy.dashboard.org</cite> denoted as ‘Number of Cycles’. It is important to note that simulation folders for previous and continuing simulation should be different. If not, the new simulation will not proceed since the <cite>.h5</cite> file already exists. Later on, you can merge the <cite>.h5</cite> files to continue your analysis.</p>
<p>You can set the parameters for the new simulation as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># These parameters can be different for your system, make sure to change them accordingly</span>
<span class="n">num_walkers</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">n_run</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># Run number</span>
<span class="n">n_steps</span> <span class="o">=</span> <span class="mi">100000</span> <span class="c1"># Number of steps for the new simulation</span>
<span class="n">n_cycles</span> <span class="o">=</span> <span class="mi">150</span> <span class="c1"># Number of cycles for the new simulation</span>
<span class="n">n_last_cycles</span> <span class="o">=</span> <span class="mi">150</span> <span class="c1"># How many cycles last simulation had</span>
<span class="n">last_cycle</span> <span class="o">=</span> <span class="mi">149</span> <span class="c1"># ID for the pickle file of the last cycle</span>

<span class="n">inp_path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span>
<span class="n">pdb_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">inp_path</span><span class="si">}</span><span class="s1">/step3_input.pdb&#39;</span>
<span class="n">rst_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">inp_path</span><span class="si">}</span><span class="s1">/step5_10.rst&#39;</span>
<span class="n">system_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">inp_path</span><span class="si">}</span><span class="s1">/system.pkl&#39;</span>
<span class="n">topology_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">inp_path</span><span class="si">}</span><span class="s1">/topology.pkl&#39;</span>
<span class="n">input_dir</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;simdata_run</span><span class="si">{</span><span class="n">n_run</span><span class="si">}</span><span class="s1">_steps</span><span class="si">{</span><span class="n">n_steps</span><span class="si">}</span><span class="s1">_cycs</span><span class="si">{</span><span class="n">n_last_cycles</span><span class="si">}</span><span class="s1">_1&#39;</span> <span class="c1"># Previous simulation directory</span>
<span class="n">output_dir</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;simdata_run</span><span class="si">{</span><span class="n">n_run</span><span class="si">}</span><span class="s1">_steps</span><span class="si">{</span><span class="n">n_steps</span><span class="si">}</span><span class="s1">_cycs</span><span class="si">{</span><span class="n">n_last_cycles</span><span class="si">}</span><span class="s1">_2&#39;</span> <span class="c1"># New simulation directory</span>
<span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">outputs_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we can setup the simulation as we did in the <cite>Unbinding Simulation</cite> tutorial. You can use the same setup for the simulation with the addition of loading the last cycle of the previous simulation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">system_path</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">pkl</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">topology_path</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">omm_top</span> <span class="o">=</span> <span class="n">pkl</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="c1"># Get positions and box vectors from an rst file</span>
<span class="c1"># This is typically a restart file post nvt/npt from openmm</span>
<span class="c1"># However, you can build it from scratch using omma.PDBFile() too</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">rst_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">simtk_state</span> <span class="o">=</span> <span class="n">omm</span><span class="o">.</span><span class="n">XmlSerializer</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    <span class="n">bv</span> <span class="o">=</span> <span class="n">simtk_state</span><span class="o">.</span><span class="n">getPeriodicBoxVectors</span><span class="p">()</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">simtk_state</span><span class="o">.</span><span class="n">getPositions</span><span class="p">()</span>

<span class="n">system</span><span class="o">.</span><span class="n">setDefaultPeriodicBoxVectors</span><span class="p">(</span><span class="n">bv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">bv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

<span class="k">with</span> <span class="nb">open</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">input_dir</span><span class="si">}</span><span class="s1">/pkls/walkers_cycle_</span><span class="si">{</span><span class="n">last_cycle</span><span class="si">}</span><span class="s1">.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">last_cycle</span> <span class="o">=</span> <span class="n">pkl</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Now that we have our previous pickle file, we can extract the walkers. This is the important step that allows us to continue the simulation. We will use these walkers to set walker states and walker weights for our simulation objects.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">init_walkers</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">walker</span> <span class="ow">in</span> <span class="n">last_cycle</span><span class="p">:</span>
    <span class="n">init_walkers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">walker</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we need an integrator and a runner for our simulation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">integrator</span> <span class="o">=</span> <span class="n">omm</span><span class="o">.</span><span class="n">LangevinIntegrator</span><span class="p">(</span><span class="mi">300</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">kelvin</span><span class="p">,</span>
                                <span class="mi">1</span><span class="o">/</span><span class="n">unit</span><span class="o">.</span><span class="n">picosecond</span><span class="p">,</span>
                                <span class="mf">0.002</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">picoseconds</span><span class="p">)</span>

<span class="n">runner</span> <span class="o">=</span> <span class="n">OpenMMRunner</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">omm_top</span><span class="p">,</span> <span class="n">integrator</span><span class="p">,</span> <span class="n">platform</span><span class="o">=</span><span class="s1">&#39;CUDA&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now that we have the walkers and the runner, we need to introduce the distance metric for measuring differences between states as we did in <cite>Unbinding Simulation</cite> tutorial.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pdb</span> <span class="o">=</span> <span class="n">mdj</span><span class="o">.</span><span class="n">load_pdb</span><span class="p">(</span><span class="n">pdb_path</span><span class="p">)</span>
<span class="n">json_top</span> <span class="o">=</span> <span class="n">mdtraj_to_json_topology</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>

<span class="c1"># Save some relevant indices</span>
<span class="n">lig_idxs</span> <span class="o">=</span> <span class="n">pdb</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;resname UNK&#39;</span><span class="p">)</span> <span class="c1"># TODO: Update</span>
<span class="n">protein_idxs</span> <span class="o">=</span> <span class="n">pdb</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;protein and not resname UNK&#39;</span><span class="p">)</span> <span class="c1"># TODO: update</span>
<span class="n">binding_selection_idxs</span> <span class="o">=</span>  <span class="n">mdj</span><span class="o">.</span><span class="n">compute_neighbors</span><span class="p">(</span><span class="n">pdb</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">lig_idxs</span><span class="p">,</span> <span class="n">haystack_indices</span><span class="o">=</span><span class="n">protein_idxs</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Distance metric to be used in REVO</span>
<span class="n">unb_distance</span> <span class="o">=</span> <span class="n">UnbindingDistance</span><span class="p">(</span><span class="n">lig_idxs</span><span class="p">,</span>
                                 <span class="n">binding_selection_idxs</span><span class="p">,</span>
                                 <span class="p">[</span><span class="n">walker</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">walker</span> <span class="ow">in</span> <span class="n">init_walkers</span><span class="p">])</span>
</pre></div>
</div>
<p>Next, we will setup the boundary conditions for the simulation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ubc</span> <span class="o">=</span> <span class="n">UnbindingBC</span><span class="p">(</span><span class="n">cutoff_distance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># nm</span>
                  <span class="n">initial_state</span><span class="o">=</span><span class="p">[</span><span class="n">walker</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">walker</span> <span class="ow">in</span> <span class="n">init_walkers</span><span class="p">],</span>
                  <span class="n">initial_weights</span><span class="o">=</span><span class="p">[</span><span class="n">walker</span><span class="o">.</span><span class="n">weight</span> <span class="k">for</span> <span class="n">walker</span> <span class="ow">in</span> <span class="n">init_walkers</span><span class="p">],</span>
                  <span class="n">topology</span><span class="o">=</span><span class="n">json_top</span><span class="p">,</span>
                  <span class="n">ligand_idxs</span><span class="o">=</span><span class="n">lig_idxs</span><span class="p">,</span>
                  <span class="n">receptor_idxs</span><span class="o">=</span><span class="n">protein_idxs</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we will use the REVOResampler class from the wepy library to setup the resampler.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up the REVO Resampler with the parameters</span>
<span class="n">resampler</span> <span class="o">=</span> <span class="n">REVOResampler</span><span class="p">(</span><span class="n">distance</span><span class="o">=</span><span class="n">unb_distance</span><span class="p">,</span>
                          <span class="n">init_state</span><span class="o">=</span><span class="p">[</span><span class="n">walker</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">walker</span> <span class="ow">in</span> <span class="n">init_walkers</span><span class="p">],</span>
                          <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">pmax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                          <span class="n">dist_exponent</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                          <span class="n">merge_dist</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
                          <span class="n">char_dist</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>And finally, we need to setup the reporters for recording the simulation data, define the task mapper and the simulation manager.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up the HDF5 reporter</span>
<span class="n">hdf5_reporter</span> <span class="o">=</span> <span class="n">WepyHDF5Reporter</span><span class="p">(</span><span class="n">save_fields</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;positions&#39;</span><span class="p">,</span><span class="s1">&#39;box_vectors&#39;</span><span class="p">),</span>
                            <span class="n">file_path</span><span class="o">=</span><span class="n">osp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputs_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;wepy.results.h5&#39;</span><span class="p">)</span> <span class="p">,</span>
                            <span class="n">resampler</span><span class="o">=</span><span class="n">resampler</span><span class="p">,</span>
                            <span class="n">boundary_conditions</span><span class="o">=</span><span class="n">ubc</span><span class="p">,</span>
                            <span class="n">topology</span><span class="o">=</span><span class="n">json_top</span><span class="p">)</span>

<span class="c1"># Set up the pickle reporter (Essential for restarts)</span>
<span class="n">out_folder_pkl</span> <span class="o">=</span> <span class="n">osp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputs_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;pkls&#39;</span><span class="p">)</span>
<span class="n">pkl_reporter</span> <span class="o">=</span> <span class="n">WalkersPickleReporter</span><span class="p">(</span><span class="n">save_dir</span> <span class="o">=</span> <span class="n">out_folder_pkl</span><span class="p">,</span>
                                 <span class="n">freq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                 <span class="n">num_backups</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># Set up the dashboard reporter</span>
<span class="n">dashboard_path</span> <span class="o">=</span> <span class="n">osp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputs_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;wepy.dash.org&#39;</span><span class="p">)</span>
<span class="n">openmm_dashboard_sec</span> <span class="o">=</span> <span class="n">OpenMMRunnerDashboardSection</span><span class="p">(</span><span class="n">runner</span><span class="p">)</span>
<span class="n">dashboard_reporter</span> <span class="o">=</span> <span class="n">DashboardReporter</span><span class="p">(</span><span class="n">file_path</span> <span class="o">=</span> <span class="n">dashboard_path</span><span class="p">,</span>
                                    <span class="n">runner_dash</span> <span class="o">=</span> <span class="n">openmm_dashboard_sec</span><span class="p">)</span>


<span class="c1"># Create a work mapper for NVIDIA GPUs for a GPU cluster</span>
<span class="n">mapper</span> <span class="o">=</span> <span class="n">TaskMapper</span><span class="p">(</span><span class="n">walker_task_type</span><span class="o">=</span><span class="n">OpenMMGPUWalkerTaskProcess</span><span class="p">,</span>
                    <span class="n">num_workers</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">platform</span><span class="o">=</span><span class="s1">&#39;CUDA&#39;</span><span class="p">,</span>
                    <span class="n">device_ids</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Build the simulation manager</span>
<span class="n">sim_manager</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">(</span><span class="n">init_walkers</span><span class="p">,</span>
                      <span class="n">runner</span><span class="o">=</span><span class="n">runner</span><span class="p">,</span>
                      <span class="n">resampler</span><span class="o">=</span><span class="n">resampler</span><span class="p">,</span>
                      <span class="n">boundary_conditions</span><span class="o">=</span><span class="n">ubc</span><span class="p">,</span>
                      <span class="n">work_mapper</span><span class="o">=</span><span class="n">mapper</span><span class="p">,</span>
                      <span class="n">reporters</span><span class="o">=</span><span class="p">[</span><span class="n">hdf5_reporter</span><span class="p">,</span> <span class="n">pkl_reporter</span><span class="p">,</span> <span class="n">dashboard_reporter</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running the simulation...&#39;</span><span class="p">)</span>
<span class="c1"># run a simulation with the manager for &#39;n_cycles&#39; with &#39;n_steps&#39; of integrator steps in each</span>
<span class="n">steps_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_steps</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cycles</span><span class="p">)]</span>

<span class="c1"># and..... go!</span>
<span class="n">sim_manager</span><span class="o">.</span><span class="n">run_simulation</span><span class="p">(</span><span class="n">n_cycles</span><span class="p">,</span>
                           <span class="n">steps_list</span><span class="p">)</span>
</pre></div>
</div>
<p>And that is it! Now you can start the simulation by running <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">wepy_run.py</span></code>. The simulation will continue for the specified number of cycles and steps. The simulation data will be saved in the <code class="docutils literal notranslate"><span class="pre">outputs_dir</span></code> directory. Later on, we will cover how to merge the hdf5 files from the two simulations to continue the analysis.</p>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="../parallel_runs/README.html" title="Previous document">Starting Parallel Runs</a>
        </li>
        <li>
          <a href="../merge_data/README.html" title="Next document">Merge Multiple Simulation Data</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../../index.html">
    <img class="logo" src="../../../../_static/wepy.svg" alt="Logo" />
    
    <h1 class="logo logo-name">wepy</h1>
    
  </a>
</p>



<p class="blurb">Wepy Documentation</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=ADicksonLab&repo=wepy&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction &amp; Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quick_start/index.html">Quick Start</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../users_guide.html">Comprehensive User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../troubleshooting.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Overview</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../general_info.html">General Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">News and Updates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev_guide.html">Development Guide</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Tutorials</a><ul>
  <li><a href="../index.html">Running Multiple Simulations</a><ul>
      <li>Previous: <a href="../parallel_runs/README.html" title="previous chapter">Starting Parallel Runs</a></li>
      <li>Next: <a href="../merge_data/README.html" title="next chapter">Merge Multiple Simulation Data</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Michigan State University.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.0.2</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../../../_sources/_source/tutorials/multiple_runs/continue_simulation/README.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>