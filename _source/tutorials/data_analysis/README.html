
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Introduction to Weighted Ensemble Data Analysis in wepy &#8212; wepy 1.0.1+3.gd209e73 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Using Orchestrators" href="../Orchestrator/README.html" />
    <link rel="prev" title="A First Look at wepy Data" href="../extended_test_drive/README.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="../extended_test_drive/README.html" title="Previous document">A First Look at wepy Data</a>
        </li>
        <li>
          <a href="../Orchestrator/README.html" title="Next document">Using Orchestrators</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container,
div.nbinput.container div.prompt,
div.nbinput.container div.input_area,
div.nbinput.container div[class*=highlight],
div.nbinput.container div[class*=highlight] pre,
div.nboutput.container,
div.nboutput.container div.prompt,
div.nboutput.container div.output_area,
div.nboutput.container div[class*=highlight],
div.nboutput.container div[class*=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    min-width: 5.5ex;
    padding-top: 0.3rem;
    padding-right: 0.3rem;
    text-align: right;
    flex: 0;
}
@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    background: #f5f5f5;
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 0.3rem;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt a.copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
</style>
<div class="section" id="Introduction-to-Weighted-Ensemble-Data-Analysis-in-wepy">
<h1>Introduction to Weighted Ensemble Data Analysis in wepy<a class="headerlink" href="#Introduction-to-Weighted-Ensemble-Data-Analysis-in-wepy" title="Permalink to this headline">¶</a></h1>
<p>By: Samuel Lotz</p>
<p>Before we move on to the interesting stuff we first just set up some boilerplate stuff for running the tutorial.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">osp</span>
<span class="kn">import</span> <span class="nn">random</span> <span class="k">as</span> <span class="nn">rand</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">shutil</span> <span class="k">as</span> <span class="nn">sh</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

<span class="n">rand</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">33</span><span class="p">)</span>

<span class="c1">## Inputs and Outputs</span>
<span class="n">input_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>
<span class="n">outputs_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;_output&quot;</span><span class="p">)</span>

<span class="n">media_dir</span> <span class="o">=</span> <span class="n">input_dir</span> <span class="o">/</span> <span class="s1">&#39;media&#39;</span>

<span class="n">sh</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">outputs_dir</span><span class="p">)</span>
<span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">outputs_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function to show the images at the right scale&quot;&quot;&quot;</span>
    <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">dim</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
    <span class="n">new_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">Image</span><span class="o">.</span><span class="n">ANTIALIAS</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_image</span>

<span class="c1"># load all the images</span>
<span class="n">CSN_workflow_longway_im</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">media_dir</span> <span class="o">/</span> <span class="s2">&quot;CSN_workflow_longway.png&quot;</span><span class="p">)</span>
<span class="n">walker_history_im</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">media_dir</span> <span class="o">/</span> <span class="s2">&quot;walker_history_schematic.png&quot;</span><span class="p">)</span>
<span class="n">sim_manager_dataflow_im</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">media_dir</span> <span class="o">/</span> <span class="s2">&quot;sim_manager_dataflow.png&quot;</span><span class="p">)</span>

<span class="n">trad_md_windows_im</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">media_dir</span> <span class="o">/</span> <span class="s2">&quot;trad_MD_windows.png&quot;</span><span class="p">)</span>
<span class="n">we_md_windows_im</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">media_dir</span> <span class="o">/</span> <span class="s2">&quot;we_MD_windows.png&quot;</span><span class="p">)</span>
<span class="n">continuation_runs_im</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">media_dir</span> <span class="o">/</span> <span class="s2">&quot;continuation_runs.png&quot;</span><span class="p">)</span>
<span class="n">contig_tree_im</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">media_dir</span> <span class="o">/</span> <span class="s2">&quot;contig_tree.png&quot;</span><span class="p">)</span>
<span class="n">CSN_workflow_shortway_im</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">media_dir</span> <span class="o">/</span> <span class="s2">&quot;CSN_workflow_shortway.png&quot;</span><span class="p">)</span>
<span class="n">linking_files_im</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">media_dir</span> <span class="o">/</span> <span class="s2">&quot;linking_files.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="Running-the-simulation">
<h2>Running the simulation<a class="headerlink" href="#Running-the-simulation" title="Permalink to this headline">¶</a></h2>
<p>Here we run some simulations so that we can showcase combining them for analysis. Since this tutorial isn’t about running simulations we won’t discuss this part much.</p>
<p>This first block is just to set up all the parameters and components for the simulation. We will be running multiple simulations with these and just change the reporters we are using.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">osp</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.spatial.distance</span> <span class="k">as</span> <span class="nn">scidist</span>

<span class="kn">import</span> <span class="nn">simtk.openmm.app</span> <span class="k">as</span> <span class="nn">omma</span>
<span class="kn">import</span> <span class="nn">simtk.openmm</span> <span class="k">as</span> <span class="nn">omm</span>
<span class="kn">import</span> <span class="nn">simtk.unit</span> <span class="k">as</span> <span class="nn">unit</span>

<span class="kn">from</span> <span class="nn">openmm_systems.test_systems</span> <span class="kn">import</span> <span class="n">LennardJonesPair</span>
<span class="kn">import</span> <span class="nn">mdtraj</span> <span class="k">as</span> <span class="nn">mdj</span>
<span class="kn">from</span> <span class="nn">wepy.util.mdtraj</span> <span class="kn">import</span> <span class="n">mdtraj_to_json_topology</span>

<span class="kn">from</span> <span class="nn">wepy.sim_manager</span> <span class="kn">import</span> <span class="n">Manager</span>

<span class="kn">from</span> <span class="nn">wepy.resampling.distances.distance</span> <span class="kn">import</span> <span class="n">Distance</span>
<span class="kn">from</span> <span class="nn">wepy.resampling.resamplers.wexplore</span> <span class="kn">import</span> <span class="n">WExploreResampler</span>
<span class="kn">from</span> <span class="nn">wepy.walker</span> <span class="kn">import</span> <span class="n">Walker</span>
<span class="kn">from</span> <span class="nn">wepy.runners.openmm</span> <span class="kn">import</span> <span class="n">OpenMMRunner</span><span class="p">,</span> <span class="n">OpenMMState</span>
<span class="kn">from</span> <span class="nn">wepy.runners.openmm</span> <span class="kn">import</span> <span class="n">UNIT_NAMES</span><span class="p">,</span> <span class="n">GET_STATE_KWARG_DEFAULTS</span>
<span class="kn">from</span> <span class="nn">wepy.work_mapper.mapper</span> <span class="kn">import</span> <span class="n">Mapper</span>
<span class="kn">from</span> <span class="nn">wepy.boundary_conditions.unbinding</span> <span class="kn">import</span> <span class="n">UnbindingBC</span>
<span class="kn">from</span> <span class="nn">wepy.reporter.hdf5</span> <span class="kn">import</span> <span class="n">WepyHDF5Reporter</span>

<span class="kn">from</span> <span class="nn">wepy.hdf5</span> <span class="kn">import</span> <span class="n">WepyHDF5</span>



<span class="c1">## PARAMETERS</span>

<span class="c1"># we use the Reference platform because this is just a test</span>
<span class="n">PLATFORM</span> <span class="o">=</span> <span class="s1">&#39;Reference&#39;</span>

<span class="c1"># Langevin Integrator</span>
<span class="n">TEMPERATURE</span><span class="o">=</span> <span class="mf">300.0</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">kelvin</span>
<span class="n">FRICTION_COEFFICIENT</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">unit</span><span class="o">.</span><span class="n">picosecond</span>
<span class="c1"># step size of time integrations</span>
<span class="n">STEP_SIZE</span> <span class="o">=</span> <span class="mf">0.002</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">picoseconds</span>

<span class="c1"># Resampler parameters</span>

<span class="c1"># the maximum weight allowed for a walker</span>
<span class="n">PMAX</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="c1"># the minimum weight allowed for a walker</span>
<span class="n">PMIN</span> <span class="o">=</span> <span class="mf">1e-12</span>

<span class="c1"># the maximum number of regions allowed under each parent region</span>
<span class="n">MAX_N_REGIONS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

<span class="c1"># the maximum size of regions, new regions will be created if a walker</span>
<span class="c1"># is beyond this distance from each voronoi image unless there is an</span>
<span class="c1"># already maximal number of regions</span>
<span class="n">MAX_REGION_SIZES</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">.</span><span class="mi">35</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">)</span> <span class="c1"># nanometers</span>

<span class="c1"># boundary condition parameters</span>

<span class="c1"># maximum distance between between any atom of the ligand and any</span>
<span class="c1"># other atom of the protein, if the shortest such atom-atom distance</span>
<span class="c1"># is larger than this the ligand will be considered unbound and</span>
<span class="c1"># restarted in the initial state</span>
<span class="n">CUTOFF_DISTANCE</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># nm</span>

<span class="c1"># reporting parameters</span>

<span class="c1"># these are the properties of the states (i.e. from OpenMM) which will</span>
<span class="c1"># be saved into the HDF5</span>
<span class="n">SAVE_FIELDS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;positions&#39;</span><span class="p">,</span> <span class="s1">&#39;box_vectors&#39;</span><span class="p">,</span> <span class="s1">&#39;velocities&#39;</span><span class="p">)</span>

<span class="c1"># make a dictionary of units for adding to the HDF5</span>
<span class="n">units</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">UNIT_NAMES</span><span class="p">)</span>



<span class="c1">## System</span>

<span class="c1"># make the test system</span>
<span class="n">test_sys</span> <span class="o">=</span> <span class="n">LennardJonesPair</span><span class="p">()</span>

<span class="c1">## Molecular Topology</span>

<span class="n">mdtraj_topology</span> <span class="o">=</span> <span class="n">mdj</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">from_openmm</span><span class="p">(</span><span class="n">test_sys</span><span class="o">.</span><span class="n">topology</span><span class="p">)</span>

<span class="n">json_str_top</span> <span class="o">=</span> <span class="n">mdtraj_to_json_topology</span><span class="p">(</span><span class="n">mdtraj_topology</span><span class="p">)</span>

<span class="c1">## Runner</span>


<span class="c1"># make the integrator</span>
<span class="n">integrator</span> <span class="o">=</span> <span class="n">omm</span><span class="o">.</span><span class="n">LangevinIntegrator</span><span class="p">(</span><span class="n">TEMPERATURE</span><span class="p">,</span>
                                    <span class="n">FRICTION_COEFFICIENT</span><span class="p">,</span>
                                    <span class="n">STEP_SIZE</span><span class="p">)</span>

<span class="c1"># make a context and set the positions</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">omm</span><span class="o">.</span><span class="n">Context</span><span class="p">(</span><span class="n">test_sys</span><span class="o">.</span><span class="n">system</span><span class="p">,</span>
                      <span class="n">copy</span><span class="p">(</span><span class="n">integrator</span><span class="p">))</span>
<span class="n">context</span><span class="o">.</span><span class="n">setPositions</span><span class="p">(</span><span class="n">test_sys</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>

<span class="c1"># get the data from this context so we have a state to start the</span>
<span class="c1"># simulation with</span>
<span class="n">get_state_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">GET_STATE_KWARG_DEFAULTS</span><span class="p">)</span>
<span class="n">init_sim_state</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">getState</span><span class="p">(</span><span class="o">**</span><span class="n">get_state_kwargs</span><span class="p">)</span>
<span class="n">init_state</span> <span class="o">=</span> <span class="n">OpenMMState</span><span class="p">(</span><span class="n">init_sim_state</span><span class="p">)</span>

<span class="c1"># initialize the runner</span>
<span class="n">runner</span> <span class="o">=</span> <span class="n">OpenMMRunner</span><span class="p">(</span><span class="n">test_sys</span><span class="o">.</span><span class="n">system</span><span class="p">,</span>
                      <span class="n">test_sys</span><span class="o">.</span><span class="n">topology</span><span class="p">,</span>
                      <span class="n">integrator</span><span class="p">,</span>
                      <span class="n">platform</span><span class="o">=</span><span class="n">PLATFORM</span><span class="p">)</span>

<span class="c1">## Distance Metric</span>
<span class="c1"># we define a simple distance metric for this system, assuming the</span>
<span class="c1"># positions are in a &#39;positions&#39; field</span>
<span class="k">class</span> <span class="nc">PairDistance</span><span class="p">(</span><span class="n">Distance</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">scidist</span><span class="o">.</span><span class="n">euclidean</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>

    <span class="k">def</span> <span class="nf">image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;positions&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">image_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_a</span><span class="p">,</span> <span class="n">image_b</span><span class="p">):</span>
        <span class="n">dist_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">(</span><span class="n">image_a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image_a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">dist_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">(</span><span class="n">image_b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image_b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dist_a</span> <span class="o">-</span> <span class="n">dist_b</span><span class="p">)</span>


<span class="c1"># make a distance object which can be used to compute the distance</span>
<span class="c1"># between two walkers, for our scorer class</span>
<span class="n">distance</span> <span class="o">=</span> <span class="n">PairDistance</span><span class="p">()</span>

<span class="c1">## Resampler</span>
<span class="n">resampler</span> <span class="o">=</span> <span class="n">WExploreResampler</span><span class="p">(</span><span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                               <span class="n">init_state</span><span class="o">=</span><span class="n">init_state</span><span class="p">,</span>
                               <span class="n">max_region_sizes</span><span class="o">=</span><span class="n">MAX_REGION_SIZES</span><span class="p">,</span>
                               <span class="n">max_n_regions</span><span class="o">=</span><span class="n">MAX_N_REGIONS</span><span class="p">,</span>
                               <span class="n">pmin</span><span class="o">=</span><span class="n">PMIN</span><span class="p">,</span> <span class="n">pmax</span><span class="o">=</span><span class="n">PMAX</span><span class="p">)</span>

<span class="c1">## Boundary Conditions</span>


<span class="c1"># initialize the unbinding boundary conditions</span>
<span class="n">ubc</span> <span class="o">=</span> <span class="n">UnbindingBC</span><span class="p">(</span><span class="n">cutoff_distance</span><span class="o">=</span><span class="n">CUTOFF_DISTANCE</span><span class="p">,</span>
                  <span class="n">initial_state</span><span class="o">=</span><span class="n">init_state</span><span class="p">,</span>
                  <span class="n">topology</span><span class="o">=</span><span class="n">json_str_top</span><span class="p">,</span>
                  <span class="n">ligand_idxs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_sys</span><span class="o">.</span><span class="n">ligand_indices</span><span class="p">),</span>
                  <span class="n">receptor_idxs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_sys</span><span class="o">.</span><span class="n">receptor_indices</span><span class="p">))</span>


<span class="c1">## Work Mapper</span>

<span class="c1"># a simple work mapper</span>
<span class="n">mapper</span> <span class="o">=</span> <span class="n">Mapper</span><span class="p">()</span>

<span class="c1">## initial walkers</span>
<span class="n">n_walkers</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">init_weight</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n_walkers</span>
<span class="n">init_walkers</span> <span class="o">=</span> <span class="p">[</span><span class="n">Walker</span><span class="p">(</span><span class="n">OpenMMState</span><span class="p">(</span><span class="n">init_sim_state</span><span class="p">),</span> <span class="n">init_weight</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_walkers</span><span class="p">)]</span>

<span class="c1">## run parameters</span>
<span class="n">n_cycles</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">n_steps</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="c1"># steps for each cycle</span>
<span class="n">steps</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_steps</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cycles</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="section" id="First-Simulation">
<h3>First Simulation<a class="headerlink" href="#First-Simulation" title="Permalink to this headline">¶</a></h3>
<p>Nothing fancy here, we just make a reporter that will generate the <code class="docutils literal notranslate"><span class="pre">WepyHDF5</span></code> file. We need to do <code class="docutils literal notranslate"><span class="pre">deepcopy</span></code> on all the components because we will be reusing this initial state for the other simulations and passing them by reference here will mutate them. The <code class="docutils literal notranslate"><span class="pre">Manager</span></code> won’t do copies automatically for you as this may be expensive in some situations.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">run1_hdf5_reporter</span> <span class="o">=</span> <span class="n">WepyHDF5Reporter</span><span class="p">(</span>
    <span class="n">file_path</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">outputs_dir</span> <span class="o">/</span> <span class="s2">&quot;results_run1.wepy.h5&quot;</span><span class="p">),</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>
                                 <span class="n">save_fields</span><span class="o">=</span><span class="n">SAVE_FIELDS</span><span class="p">,</span>
                                 <span class="n">resampler</span><span class="o">=</span><span class="n">resampler</span><span class="p">,</span>
                                 <span class="n">boundary_conditions</span><span class="o">=</span><span class="n">ubc</span><span class="p">,</span>
                                 <span class="n">topology</span><span class="o">=</span><span class="n">json_str_top</span><span class="p">,</span>
                                 <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">)</span>

<span class="n">sim_manager_1</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">init_walkers</span><span class="p">),</span>
                        <span class="n">runner</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">runner</span><span class="p">),</span>
                        <span class="n">resampler</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">resampler</span><span class="p">),</span>
                        <span class="n">boundary_conditions</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ubc</span><span class="p">),</span>
                        <span class="n">work_mapper</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mapper</span><span class="p">),</span>
                        <span class="n">reporters</span><span class="o">=</span><span class="p">[</span><span class="n">run1_hdf5_reporter</span><span class="p">]</span>
                    <span class="p">)</span>
<span class="p">(</span><span class="n">run1_walkers</span><span class="p">,</span>
 <span class="p">(</span><span class="n">run1_runner</span><span class="p">,</span> <span class="n">run1_bc</span><span class="p">,</span> <span class="n">run1_resampler</span><span class="p">))</span> <span class="o">=</span> \
             <span class="n">sim_manager_1</span><span class="o">.</span><span class="n">run_simulation</span><span class="p">(</span><span class="n">n_cycles</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>

</pre></div>
</div>
</div>
</div>
<div class="section" id="Second-Simulation">
<h3>Second Simulation<a class="headerlink" href="#Second-Simulation" title="Permalink to this headline">¶</a></h3>
<p>Same as the first one but we just want a separate dataset so we can demonstrate how to aggregate independently generated datasets later.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">run2_hdf5_reporter</span> <span class="o">=</span> <span class="n">WepyHDF5Reporter</span><span class="p">(</span>
    <span class="n">file_path</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">outputs_dir</span> <span class="o">/</span> <span class="s2">&quot;results_run2.wepy.h5&quot;</span><span class="p">),</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>
                                 <span class="n">save_fields</span><span class="o">=</span><span class="n">SAVE_FIELDS</span><span class="p">,</span>
                                 <span class="n">resampler</span><span class="o">=</span><span class="n">resampler</span><span class="p">,</span>
                                 <span class="n">boundary_conditions</span><span class="o">=</span><span class="n">ubc</span><span class="p">,</span>
                                 <span class="n">topology</span><span class="o">=</span><span class="n">json_str_top</span><span class="p">,</span>
                                 <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">)</span>

<span class="c1"># run two simulations from the initial conditions</span>
<span class="n">sim_manager_2</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">init_walkers</span><span class="p">),</span>
                        <span class="n">runner</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">runner</span><span class="p">),</span>
                        <span class="n">resampler</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">resampler</span><span class="p">),</span>
                        <span class="n">boundary_conditions</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ubc</span><span class="p">),</span>
                        <span class="n">work_mapper</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mapper</span><span class="p">),</span>
                        <span class="n">reporters</span><span class="o">=</span><span class="p">[</span><span class="n">run2_hdf5_reporter</span><span class="p">]</span>
                    <span class="p">)</span>
<span class="p">(</span><span class="n">run2_walkers</span><span class="p">,</span>
 <span class="p">(</span><span class="n">run2_runner</span><span class="p">,</span> <span class="n">run2_bc</span><span class="p">,</span> <span class="n">run2_resampler</span><span class="p">))</span> <span class="o">=</span> \
             <span class="n">sim_manager_2</span><span class="o">.</span><span class="n">run_simulation</span><span class="p">(</span><span class="n">n_cycles</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="Third-Simulation">
<h4>Third Simulation<a class="headerlink" href="#Third-Simulation" title="Permalink to this headline">¶</a></h4>
<p>For this simulation we will continue the second simulation using the outputs. While this isn’t something you would likely do in practice all in the same script, this is something that must be dealt with when running very long simulations on machines which have restrictions on how long you can run them. To support this in a more robust way, there is the <code class="docutils literal notranslate"><span class="pre">orchestration</span></code> module which we encourage you to check out.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">run3_hdf5_reporter</span> <span class="o">=</span> <span class="n">WepyHDF5Reporter</span><span class="p">(</span>
    <span class="n">file_path</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">outputs_dir</span> <span class="o">/</span> <span class="s2">&quot;results_run3.wepy.h5&quot;</span><span class="p">),</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>
                                 <span class="n">save_fields</span><span class="o">=</span><span class="n">SAVE_FIELDS</span><span class="p">,</span>
                                 <span class="n">resampler</span><span class="o">=</span><span class="n">run2_resampler</span><span class="p">,</span>
                                 <span class="n">boundary_conditions</span><span class="o">=</span><span class="n">run2_bc</span><span class="p">,</span>
                                 <span class="n">topology</span><span class="o">=</span><span class="n">json_str_top</span><span class="p">,</span>
                                 <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">)</span>

<span class="c1"># run two simulations from the initial conditions</span>
<span class="n">sim_manager_3</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">init_walkers</span><span class="p">),</span>
                        <span class="n">runner</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">run2_runner</span><span class="p">),</span>
                        <span class="n">resampler</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">run2_resampler</span><span class="p">),</span>
                        <span class="n">boundary_conditions</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">run2_bc</span><span class="p">),</span>
                        <span class="n">work_mapper</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mapper</span><span class="p">),</span>
                        <span class="n">reporters</span><span class="o">=</span><span class="p">[</span><span class="n">run3_hdf5_reporter</span><span class="p">]</span>
                    <span class="p">)</span>
<span class="p">(</span><span class="n">run3_walkers</span><span class="p">,</span>
 <span class="p">(</span><span class="n">run3_runner</span><span class="p">,</span> <span class="n">run3_bc</span><span class="p">,</span> <span class="n">run3_resampler</span><span class="p">))</span> <span class="o">=</span> \
             <span class="n">sim_manager_3</span><span class="o">.</span><span class="n">run_simulation</span><span class="p">(</span><span class="n">n_cycles</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Analysis-Workflow">
<h4>Analysis Workflow<a class="headerlink" href="#Analysis-Workflow" title="Permalink to this headline">¶</a></h4>
<p>Now that we have generated all of our simulation data we can start analyzing it.</p>
<p>We will start with a workflow something like this, where on one branch (green) we want to do some dimensionally reduction and cluster the states we collected into “macrostates”.</p>
<p>On the other branch (blue, red, purple) we will do the necessary bookkeeping to get the walker family tree taking into account both the cloning &amp; merging as well as any walkers that have warped through boundary conditions.</p>
<p>In the end we can combine these states with the walker family tree to calculate the transition probabilities between those macrostates. This end result is something similar to a Markov State Model (MSM) which we call a Conformation State Model (CSN). The distinction merely refers to some rather rigorous requirements a true Markov State Model must have that we aren’t directly attempting to verify here.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">rescale</span><span class="p">(</span><span class="n">CSN_workflow_longway_im</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../../../_images/_source_tutorials_data_analysis_README_11_0.png" src="../../../_images/_source_tutorials_data_analysis_README_11_0.png" />
</div>
</div>
</div>
</div>
<div class="section" id="Calculating-Observables">
<h3>Calculating Observables<a class="headerlink" href="#Calculating-Observables" title="Permalink to this headline">¶</a></h3>
<p>In order to do the macrostate clustering we need to calculate some interesting observables over the state data. You could use absolute positions of the particles or the energies or something that is calculated on-the-fly by the simulations but we want to showcase how to do this yourself. For a real molecular system this might be the solvent accessible surface area or the radius of gyration.</p>
<p>Because our example is very simple (just two particles) there isn’t much we can do. So we’ll just calculate the Euclidean distance between the two particles. Not coincidentally, this is also the distance metric we used. We are actually using this distance for a similar purpose (clustering) except while the resampler (WExplore) was doing this “on-the-fly” we have all of the simulation data at once and so will likely get better boundaries between clusters than our resampler.</p>
<p>To do this we have to define a function <code class="docutils literal notranslate"><span class="pre">pair_dist_obs</span></code> of a particular form that we can then pass to the <code class="docutils literal notranslate"><span class="pre">WepyHDF5.compute_observable</span></code> function which maps it over the data. Since this is a small simulation with small molecules we can do it in memory in a single process. Real simulation data can be much larger, for this you are free to implement your own computational strategies using a lower level API or you can see if the methods in the <code class="docutils literal notranslate"><span class="pre">wepy.analysis.distributed</span></code> module are suitable,
which uses the distributed computing framework <code class="docutils literal notranslate"><span class="pre">dask</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">pair_dist_obs</span><span class="p">(</span><span class="n">fields_d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">atomA_coords</span> <span class="o">=</span> <span class="n">fields_d</span><span class="p">[</span><span class="s1">&#39;positions&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">atomB_coords</span> <span class="o">=</span> <span class="n">fields_d</span><span class="p">[</span><span class="s1">&#39;positions&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">scidist</span><span class="o">.</span><span class="n">euclidean</span><span class="p">(</span><span class="n">atomA_coords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                        <span class="n">atomB_coords</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">atomA_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                     <span class="p">])</span>
    <span class="k">return</span> <span class="n">dists</span>


<span class="n">wepy1</span> <span class="o">=</span> <span class="n">WepyHDF5</span><span class="p">(</span><span class="n">outputs_dir</span> <span class="o">/</span> <span class="s1">&#39;results_run1.wepy.h5&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">wepy1</span><span class="p">:</span>

    <span class="c1"># compute the observable with the function</span>
    <span class="c1"># and automatically saving it as an extra trajectory field</span>
    <span class="n">obs</span> <span class="o">=</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">compute_observable</span><span class="p">(</span><span class="n">pair_dist_obs</span><span class="p">,</span>
                                   <span class="p">[</span><span class="s1">&#39;positions&#39;</span><span class="p">],</span>
                                   <span class="p">(),</span>
                                   <span class="n">save_to_hdf5</span><span class="o">=</span><span class="s1">&#39;pair_dist&#39;</span><span class="p">,</span>
                                   <span class="n">return_results</span><span class="o">=</span><span class="kc">True</span>
                                  <span class="p">)</span>
</pre></div>
</div>
</div>
<p>When we run <code class="docutils literal notranslate"><span class="pre">compute_observable</span></code> it both returns the values and saves them into the HDF5 file. Depending on your workflow you may favor one over the other. In the end having the observables saved in the same HDF5 file makes indexing them easier and allows for some fancy queries when you rearrange the data into networks and trees.</p>
<p>We can see what the shape of this data is and that it matches the number of walkers (4) and cycles (100) we ran the simulation with.</p>
<p>We can also see that the computed feature is a 1-D feature vector. We retain the rank of a vector rather than a scalar because in most machine learning pipelines a vector is expected. Even if in this case its only length one.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of walkers:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of cycles:&quot;</span><span class="p">,</span> <span class="n">obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;feature vector shape:&quot;</span><span class="p">,</span> <span class="n">obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
number of walkers: 4
number of cycles: 100
feature vector shape: (1,)
</pre></div></div>
</div>
<div class="section" id="Clustering-Simulation-Samples">
<h4>Clustering Simulation Samples<a class="headerlink" href="#Clustering-Simulation-Samples" title="Permalink to this headline">¶</a></h4>
<p>For a larger dataset clustering can be significantly more involved as it will likely need to be done either using special clustering algorithms (like the <code class="docutils literal notranslate"><span class="pre">KCenters</span></code> algorithm implemented in <code class="docutils literal notranslate"><span class="pre">MSMBuilder</span></code>) and you will probably want to partition your data into training and test sets to validate your model.</p>
<p>For our purposes here we will just use a simple fast clustering method from <code class="docutils literal notranslate"><span class="pre">sklearn</span></code>, i.e. the <code class="docutils literal notranslate"><span class="pre">MiniBatchKMeans</span></code> algorithm just so you can appreciate the mechanism and so we have some macrostate labels to use for the later analyses.</p>
<p>First we have to get our data as a uniform array of feature vectors which is simple as concatenating the features for each walker trajectory together:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">with</span> <span class="n">wepy1</span><span class="p">:</span>
    <span class="n">features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">wepy1</span><span class="o">.</span><span class="n">get_traj_field</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s1">&#39;observables/pair_dist&#39;</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wepy1</span><span class="o">.</span><span class="n">num_run_trajs</span><span class="p">(</span><span class="mi">0</span><span class="p">))])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">features</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(400, 1)
</pre></div></div>
</div>
<p>Then we can choose our classifier hyperparameters and train it:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">MiniBatchKMeans</span>

<span class="n">clf</span> <span class="o">=</span> <span class="n">MiniBatchKMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                      <span class="n">batch_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                      <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">labels_</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">labels_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(400,)
[3 1 3 1 1 2 0 2 0 3]
</pre></div></div>
</div>
<p>Once we have the trained classifier and we don’t have a test set, we can just use the already determined labels for the feature vectors and then assign this to the simulation dataset as it’s own observable. To do this we just need to destructure the feature set back into trajectory shapes and use the <code class="docutils literal notranslate"><span class="pre">add_observable</span></code> method on our <code class="docutils literal notranslate"><span class="pre">WepyHDF5</span></code> dataset:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">with</span> <span class="n">wepy1</span><span class="p">:</span>

    <span class="c1"># destructure the features</span>
    <span class="n">obs_trajs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">start_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">traj_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wepy1</span><span class="o">.</span><span class="n">num_run_trajs</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
        <span class="n">num_traj_frames</span> <span class="o">=</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">num_traj_frames</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">traj_idx</span><span class="p">)</span>

        <span class="n">obs_trajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">labels_</span><span class="p">[</span><span class="n">start_idx</span> <span class="p">:</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">num_traj_frames</span><span class="p">])</span>

        <span class="n">start_idx</span> <span class="o">+=</span> <span class="n">num_traj_frames</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;observables shape:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_trajs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># add it as an observable</span>
    <span class="n">wepy1</span><span class="o">.</span><span class="n">add_observable</span><span class="p">(</span><span class="s1">&#39;minibatch-kmeans_pair-dist_4_10_1&#39;</span><span class="p">,</span>
                        <span class="p">[</span><span class="n">obs_trajs</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
observables shape: 4 100
</pre></div></div>
</div>
<p>Thats it for clustering!</p>
<p>For now we will leave it as is and do more things with the macrostate networks once we calculate the transition probabilities.</p>
<p>Just remember that even though we are dealing with data as nice big chunks that we are even calling “trajs” or “trajectories” they are not! The name “trajectory” is simply a convenient name for a collection of molecular dynamics frames, i.e. a slice of data containing positions, box vectors, and potentially velocities and energies, that is familiar to the community.</p>
<p>A single trajectory may be linear for portions where cloning and merging did not occur, but in others the cloned walkers will be swapped in and out along the “trajectory”.</p>
<p>However, if we ran a simulation in which no cloning and merging occurs (say with the <code class="docutils literal notranslate"><span class="pre">NoResampler</span></code>) then the trajectories indeed would be valid continuous trajectories. Strictly speaking nothing in <code class="docutils literal notranslate"><span class="pre">wepy</span></code> enforces this and in reality resamplers are free to mangle the contiguity of each trajectory. That is, never rely on the well-orderdness of trajectories in <code class="docutils literal notranslate"><span class="pre">WepyHDF5</span></code> runs!</p>
<p>The following sections show the correct approach and how to extract contiguous trajectories from walker trees.</p>
</div>
<div class="section" id="Computing-Macrostate-Transition-Counts-&amp;-Probabilities">
<h4>Computing Macrostate Transition Counts &amp; Probabilities<a class="headerlink" href="#Computing-Macrostate-Transition-Counts-&-Probabilities" title="Permalink to this headline">¶</a></h4>
<p>Now that we have computed the observables and clustered them we can compute the transitions between those macrostates. The first step is a purely mechanical process and is just book-keeping about where and when walkers were cloned and merged. You can think of it as just making the family lineage. During the simulation the individual clones and merges are recorded as distinct events, like individual facts. Now we have to go back through this and assemble it into a tree-like data structure.</p>
<p>In the second revision of this workflow we will show a higher-level way to do this, but which also makes use of multiple branching simulations. For now we do it the semi-manual way of transforming the “resampling records” to a “resampling panel” (the <code class="docutils literal notranslate"><span class="pre">run_resampling_panel</span></code> method) and then condensing this to a “net parent table” (the <code class="docutils literal notranslate"><span class="pre">parent_panel</span></code> function). Finally we add a mask to this table to account for any walkers that warped through boundary conditions (the
<code class="docutils literal notranslate"><span class="pre">parent_table_discontinuities</span></code>). This is necessary for getting transition probabilities correctly since movement through a boundary acts like a probability sink and doesn’t represent a physical transition.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">resampler.DECISION</span></code> and <code class="docutils literal notranslate"><span class="pre">UnbindingBC</span></code> classes are simply the ones we used in the simulations above. These classes contain methods that allow for proper accounting to be done. The <code class="docutils literal notranslate"><span class="pre">resampler.DECISION</span></code> is just <code class="docutils literal notranslate"><span class="pre">MultiCloneMergeDecision</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[32]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">wepy.analysis.parents</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">parent_panel</span><span class="p">,</span>
    <span class="n">net_parent_table</span><span class="p">,</span>
    <span class="n">parent_table_discontinuities</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">with</span> <span class="n">wepy1</span><span class="p">:</span>
    <span class="c1"># make a parent matrix from the hdf5 resampling records for run 0</span>
    <span class="n">resampling_panel</span> <span class="o">=</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">run_resampling_panel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># get the warping records</span>
    <span class="n">warping_records</span> <span class="o">=</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">warping_records</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

<span class="n">parent_panel</span> <span class="o">=</span> <span class="n">parent_panel</span><span class="p">(</span>
    <span class="n">resampler</span><span class="o">.</span><span class="n">DECISION</span><span class="p">,</span>
    <span class="n">resampling_panel</span><span class="p">)</span>

<span class="n">parent_table</span> <span class="o">=</span> <span class="n">net_parent_table</span><span class="p">(</span><span class="n">parent_panel</span><span class="p">)</span>

<span class="n">parent_table_discs</span> <span class="o">=</span> <span class="n">parent_table_discontinuities</span><span class="p">(</span>
    <span class="n">UnbindingBC</span><span class="p">,</span>
    <span class="n">parent_table</span><span class="p">,</span>
    <span class="n">warping_records</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="Side-Notes-on-Lineages-and-Continuous-Trajectories">
<h3>Side Notes on Lineages and Continuous Trajectories<a class="headerlink" href="#Side-Notes-on-Lineages-and-Continuous-Trajectories" title="Permalink to this headline">¶</a></h3>
<p>Now that we have the entire table (which represents the walker tree) we can find contiguous trajectories from it. One way to do this is via the <code class="docutils literal notranslate"><span class="pre">ancestors</span></code> function which works on the parent table. We just need to choose a walker at a certain point of time and it will retrieve the entire history of this walker up until that point.</p>
<p>In this example I picked one of the walkers at the end of the simulation and showed the first few entries from the resulting “trace”. Traces in <code class="docutils literal notranslate"><span class="pre">wepy</span></code> are essentially collections of complex indices on the runs, trajectories, and frames (and also <em>contigs</em> which will be discussed later) in the data. Because these traces are untyped it can sometimes be confusing as to what the indices are. Be sure to pay close attention to the documentation which should tell you. There are also some
disambiguations in the glossary as to the different types of traces.</p>
<p>Also pay attention to the fact that we are using the <code class="docutils literal notranslate"><span class="pre">parent_table</span></code>, not <code class="docutils literal notranslate"><span class="pre">parent_table_discs</span></code>. A discontinuous warp breaks a lineage from the <code class="docutils literal notranslate"><span class="pre">ancestors</span></code> function.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[33]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">wepy.analysis.parents</span> <span class="kn">import</span> <span class="n">ancestors</span>

<span class="n">lineage_trace</span> <span class="o">=</span> <span class="n">ancestors</span><span class="p">(</span><span class="n">parent_table</span><span class="p">,</span>
                          <span class="mi">100</span><span class="p">,</span>
                          <span class="mi">3</span>
                         <span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">lineage_trace</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[(3, 0), (3, 1), (3, 2)]
</pre></div></div>
</div>
<p>In this trace the tuples are complex indices where the values are: <code class="docutils literal notranslate"><span class="pre">traj_idx</span></code>, <code class="docutils literal notranslate"><span class="pre">cycle_idx</span></code>. Which uniquely identifies a walker at a single point in time relative to the parent table. Because the parent table was created straight from run 0 these indices are valid for that run.</p>
<p>Using this information we can extract the fields of these walkers as a collection of arrays. For this kind of trace we use the <code class="docutils literal notranslate"><span class="pre">get_run_trace_fields</span></code> since we only are concerned with a single run. Here we are getting the weights of the walkers and the pair distance which calculated earlier.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[34]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">with</span> <span class="n">wepy1</span><span class="p">:</span>
    <span class="n">lineage_fields</span> <span class="o">=</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">get_run_trace_fields</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
                                                <span class="n">lineage_trace</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                               <span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">,</span>
                                               <span class="s1">&#39;observables/pair_dist&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;weights:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lineage_fields</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LJ-pair distance:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lineage_fields</span><span class="p">[</span><span class="s1">&#39;observables/pair_dist&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
weights:
[[0.25]
 [0.25]
 [0.25]]
LJ-pair distance:
[[0.36995744]
 [0.39919709]
 [0.37443133]]
</pre></div></div>
</div>
<p>Notice that we are excluding the last entry in the trace. Is this an error? It is not, but sometimes the indexes can be confusing. When trying to debug these kinds of issues, it can be very useful to have these two diagrams handy as a reference to the order of events taking place in the simulation.</p>
<p>The first is a schematic that focuses on the generation and inheritance of walker states at an abstract level. In this diagram the colors indicate unique states and the boxes they sit in represent the walker index, which is the trajectory index in a <code class="docutils literal notranslate"><span class="pre">WepyHDF5</span></code> run.</p>
<p>This figure is particularly helpful in understanding things like the parent table, especially when combined with boundary conditions. The dot and slash in the boundary condition lines indicate that boundary warping can be continuous or discontinuous. As you can see the slash is a discontinuous even because the purple state is replaced with the original white state. Indicating a source-sink non-equilibrium cycle. The dotted line in the resampling portion indicates that walker 1 was merged into
walker 2 (AKA “squashed”) and donated its weight to it but ending the lineage of it’s state.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[35]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">rescale</span><span class="p">(</span><span class="n">walker_history_im</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[35]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../../../_images/_source_tutorials_data_analysis_README_30_0.png" src="../../../_images/_source_tutorials_data_analysis_README_30_0.png" />
</div>
</div>
<p>In this diagram we show the actual flow of data in the <code class="docutils literal notranslate"><span class="pre">wepy</span></code> simulation manager and components.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[36]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">rescale</span><span class="p">(</span><span class="n">sim_manager_dataflow_im</span><span class="p">,</span> <span class="mf">0.65</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[36]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../../../_images/_source_tutorials_data_analysis_README_32_0.png" src="../../../_images/_source_tutorials_data_analysis_README_32_0.png" />
</div>
</div>
<p>To explain the wrinkle in the trace indexing above we must consider that the parent table above was generated from all of the resampling records available. Resampling occurs after dynamics is finished, and as the name implies generates no novel samples. And so rather than recording frames twice in the HDF5 before and after sampling we simply record the action of what happens.</p>
<p>When we ran the simulation above and returned the walkers from <code class="docutils literal notranslate"><span class="pre">run_simulation</span></code> these walkers were the resampled walkers, but those in the HDF5 are those directly produced by the runner. This way we never lose any sampled data. Even if that walker is subsequently warped or merged away.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">wepy</span></code> is focused on molecular dynamics simulations we even provide a method for generating <code class="docutils literal notranslate"><span class="pre">mdtraj</span></code> trajectories from traces. This is hugely useful for quickly converting to a more common format that can be then read by molecular structure viewers like VMD, PyMOL, or Chimera. This relies on the topology of the molecule also being stored in the HDF5 file (currently this is achieved using a JSON format file). But just know that you never need to rely on this method to get the data you
need for this kind of conversion i.e. positions and box vectors.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[37]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">with</span> <span class="n">wepy1</span><span class="p">:</span>
    <span class="n">mdj_traj</span> <span class="o">=</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">run_trace_to_mdtraj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
                                         <span class="n">lineage_trace</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mdj_traj</span><span class="p">)</span>
<span class="c1"># save one of the frames as a PDB as a reference topology</span>
<span class="n">mdj_traj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">save_pdb</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">outputs_dir</span> <span class="o">/</span> <span class="s1">&#39;lj-pair.pdb&#39;</span><span class="p">))</span>
<span class="c1"># save the lineage as a DCD trajectory</span>
<span class="n">mdj_traj</span><span class="o">.</span><span class="n">save_dcd</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">outputs_dir</span> <span class="o">/</span> <span class="s1">&#39;lj-pair_walker_lineage.pdb&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;mdtraj.Trajectory with 100 frames, 2 atoms, 2 residues, and unitcells&gt;
</pre></div></div>
</div>
<p>Also note that these trajectories do not include the actual initial structures that started the simulations. These too can be accessed if you need them via the <code class="docutils literal notranslate"><span class="pre">initial_walker_fields</span></code> and <code class="docutils literal notranslate"><span class="pre">initial_walkers_to_mdtraj</span></code> methods.</p>
</div>
<div class="section" id="Back-to-calculating-Transition-Probabilities">
<h3>Back to calculating Transition Probabilities<a class="headerlink" href="#Back-to-calculating-Transition-Probabilities" title="Permalink to this headline">¶</a></h3>
<p>Now that we have a better idea of the continuity of walker trajectories in our simulation data we can turn our attention back to generating transition probabilities between our labelled macrostates.</p>
<p>The simplest way to do this is simply to go through the continuous trajectories and take each pair of states <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span></code>, look at the labels and then tally the macrostate transition counts.</p>
<p>Naively it seems our job is done. However, things get complicated when we want to consider lag times over the trajectories. That is recording the macrostate transition between not just <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span></code> but rather the <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">C</span></code> transition given <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span> <span class="pre">-&gt;</span> <span class="pre">C</span></code>. This is desirable for a number of reasons when computing probabilities using stochastic methods like Markov State Models where we want memoryless transitions.</p>
<p>Doing this over trajectory trees is not as trivial. First consider what this lag time of 3 would look like for linear MD.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[38]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">rescale</span><span class="p">(</span><span class="n">trad_md_windows_im</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[38]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../../../_images/_source_tutorials_data_analysis_README_37_0.png" src="../../../_images/_source_tutorials_data_analysis_README_37_0.png" />
</div>
</div>
<p>Now consider a branchpoint in a tree of trajectories. We must be very careful not to double count or undercount transitions.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[39]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">rescale</span><span class="p">(</span><span class="n">we_md_windows_im</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[39]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../../../_images/_source_tutorials_data_analysis_README_39_0.png" src="../../../_images/_source_tutorials_data_analysis_README_39_0.png" />
</div>
</div>
<p>The algorithm to achieve this has been implemented in the <code class="docutils literal notranslate"><span class="pre">sliding_window</span></code> function which generates traces corresponding to the red segments in the above figures.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[42]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">wepy.analysis.parents</span> <span class="kn">import</span> <span class="n">sliding_window</span>
<span class="kn">from</span> <span class="nn">wepy.analysis.transitions</span> <span class="kn">import</span> <span class="n">run_transition_probability_matrix</span>

<span class="c1"># use the parent matrix to generate the sliding windows</span>
<span class="n">windows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sliding_window</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">parent_table_discs</span><span class="p">),</span> <span class="mi">10</span><span class="p">))</span>

</pre></div>
</div>
</div>
<p>These window traces can then be combined with cluster labels (as an observable) to produce a transition probability matrix directly. See the <code class="docutils literal notranslate"><span class="pre">wepy.analysis.transitions</span></code> module for other similar functions if you want to control how you are aggregating forward and backward transitions.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[44]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># make the transition matrix from the windows</span>
<span class="k">with</span> <span class="n">wepy1</span><span class="p">:</span>
    <span class="n">transprob_mat</span> <span class="o">=</span> <span class="n">run_transition_probability_matrix</span><span class="p">(</span>
        <span class="n">wepy1</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;observables/minibatch-kmeans_pair-dist_4_10_1&quot;</span><span class="p">,</span>
        <span class="n">windows</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">transprob_mat</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[[0.26923077 0.27586207 0.28571429 0.22727273]
 [0.34615385 0.27586207 0.35714286 0.36363636]
 [0.23076923 0.13793103 0.21428571 0.13636364]
 [0.15384615 0.31034483 0.14285714 0.27272727]]
</pre></div></div>
</div>
<div class="section" id="Contig-Trees">
<h4>Contig Trees<a class="headerlink" href="#Contig-Trees" title="Permalink to this headline">¶</a></h4>
<p>The final step before we can construct a network of macrostates is to combine everything into a <code class="docutils literal notranslate"><span class="pre">ContigTree</span></code> abstract data type. In early prototypes we supported construction of networks from both <code class="docutils literal notranslate"><span class="pre">ContigTree</span></code> and parent-table/transition-matrix. This was cumbersome and confusing and so we consolidated this interface to only use <code class="docutils literal notranslate"><span class="pre">ContigTree</span></code> as it is more general, powerful, and easier to use as a user.</p>
<p>If you have fastidiously followed up until this point you may be disappointed to learn that most of these steps are also not exactly needed when using the <code class="docutils literal notranslate"><span class="pre">ContigTree</span></code>. However, these data structures are still used in certain contexts and are useful in helping to understand all the layers of structure.</p>
<p>So lets update our original workflow to see where the <code class="docutils literal notranslate"><span class="pre">ContigTree</span></code> fits in.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[45]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">rescale</span><span class="p">(</span><span class="n">CSN_workflow_shortway_im</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[45]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../../../_images/_source_tutorials_data_analysis_README_45_0.png" src="../../../_images/_source_tutorials_data_analysis_README_45_0.png" />
</div>
</div>
<p>As you can see most of those complex intermediary formats are folded into the <code class="docutils literal notranslate"><span class="pre">ContigTree</span></code> representation. The <code class="docutils literal notranslate"><span class="pre">ContigTre</span></code> is a combination of a network data structure (<code class="docutils literal notranslate"><span class="pre">networkx.DiGraph</span></code>) and the <code class="docutils literal notranslate"><span class="pre">WepyHDF5</span></code> data.</p>
<p>In this tree each node is a single cycle of a simulation. Thus it can express not only ensembles of walkers cloning and merging but whole simulations of ensembles which are branching. Its like there is a tree inside of a tree. Technically, they are forests as well since there is often multiple roots. This whole tree inside a tree is too much complexity for what we are doing at the moment so we will defer our discussion of it until we need it when analyzing multiple simulations.</p>
<p>What we want is to get back to the part where we had a transition probability matrix and combine that with our macrostate labels to make a CSN.</p>
<p>So we simply construct the <code class="docutils literal notranslate"><span class="pre">ContigTree</span></code> with our dataset and the classes that describe the cloning &amp; merging and boundary conditions like we did before.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[63]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">wepy.analysis.contig_tree</span> <span class="kn">import</span> <span class="n">ContigTree</span>
<span class="n">contigtree</span> <span class="o">=</span> <span class="n">ContigTree</span><span class="p">(</span><span class="n">wepy1</span><span class="p">,</span>
                         <span class="n">decision_class</span><span class="o">=</span><span class="n">resampler</span><span class="o">.</span><span class="n">DECISION</span><span class="p">,</span>
                         <span class="n">boundary_condition_class</span><span class="o">=</span><span class="n">UnbindingBC</span><span class="p">,</span>
                        <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[64]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">resampler</span><span class="o">.</span><span class="n">DECISION</span><span class="o">.</span><span class="n">ENUM</span><span class="o">.</span><span class="n">SQUASH</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[64]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;CloneMergeDecisionEnum.SQUASH: 3&gt;
</pre></div></div>
</div>
<p>What have we done? Well the <code class="docutils literal notranslate"><span class="pre">ContigTree</span></code> has an extensive API for a lot of stuff so lets try to focus in on a few interesting ones before we get to the transition probabilities.</p>
<p>One of the main features is a richer set of functions for generating commonly useful continuous trajectories.</p>
<p>Here we can get the indices (as unorderd traces) for:</p>
<ul class="simple">
<li><p>all walkers were warped</p></li>
<li><p>all of the final walkers in the simulation</p></li>
<li><p>all of the squashed walkers</p></li>
</ul>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[70]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">warp_events</span> <span class="o">=</span> <span class="n">contigtree</span><span class="o">.</span><span class="n">warp_trace</span><span class="p">()</span>
<span class="n">final_walkers</span> <span class="o">=</span> <span class="n">contigtree</span><span class="o">.</span><span class="n">final_trace</span><span class="p">()</span>
<span class="n">squashed_walkers</span> <span class="o">=</span> <span class="n">contigtree</span><span class="o">.</span><span class="n">resampling_trace</span><span class="p">(</span><span class="n">resampler</span><span class="o">.</span><span class="n">DECISION</span><span class="o">.</span><span class="n">ENUM</span><span class="o">.</span><span class="n">SQUASH</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>And then we can take these events and generate all of the full lineages for them in one line.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[76]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">warp_lineages</span> <span class="o">=</span> <span class="n">contigtree</span><span class="o">.</span><span class="n">lineages</span><span class="p">(</span><span class="n">squashed_walkers</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">warp_lineages</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[]
</pre></div></div>
</div>
<p>Since we only have a single run our contig tree is really just a single contig which we can get with this little bit of magic:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[58]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">with</span> <span class="n">contigtree</span><span class="p">:</span>
    <span class="n">contig</span> <span class="o">=</span> <span class="n">contigtree</span><span class="o">.</span><span class="n">make_contig</span><span class="p">(</span><span class="n">contigtree</span><span class="o">.</span><span class="n">spanning_contig_traces</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;wepy.analysis.contig_tree.Contig object at 0x7f77633def50&gt;
</pre></div></div>
</div>
<p>This <code class="docutils literal notranslate"><span class="pre">Contig</span></code> object is a subclass of the <code class="docutils literal notranslate"><span class="pre">ContigTree</span></code> but isn’t a tree. This restriction opens a few more doors to us that we will use, but for now it makes the abstraction simpler.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">contig_tree</span><span class="o">.</span><span class="n">sliding_windows</span><span class="p">(</span><span class="mi">3</span><span class="p">)[</span><span class="o">-</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Multi-Run-Data-Analysis">
<h4>Multi-Run Data Analysis<a class="headerlink" href="#Multi-Run-Data-Analysis" title="Permalink to this headline">¶</a></h4>
<p>So far we have assumed nice contiguous data. This is not so with MD data in general which may be split up into different runs.</p>
<p>If you’ve checked out thinking about meta-trees, don’t worry. You don’t really have to think about it. The benefit is however that if the need ever arises and you have multiple simulations run from a single intermediary checkpoint, you won’t have to throw out one or the other continuations</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[47]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">rescale</span><span class="p">(</span><span class="n">continuation_runs_im</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[47]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../../../_images/_source_tutorials_data_analysis_README_58_0.png" src="../../../_images/_source_tutorials_data_analysis_README_58_0.png" />
</div>
</div>
<p>We want to be able to get transitions between the original run and all of its continuations without double counting.</p>
</div>
<div class="section" id="Contig-Tree">
<h4>Contig Tree<a class="headerlink" href="#Contig-Tree" title="Permalink to this headline">¶</a></h4>
<p>The contig tree is a tree (technically forest) of continuous simulations. For us the branchings happen when a run is continued multiple times.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[46]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">rescale</span><span class="p">(</span><span class="n">contig_tree_im</span><span class="p">,</span> <span class="mf">0.85</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[46]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../../../_images/_source_tutorials_data_analysis_README_61_0.png" src="../../../_images/_source_tutorials_data_analysis_README_61_0.png" />
</div>
</div>
<p>The Spanning Contigs are the contigs drawn before: (0,3) (0,4) (0,5) (1,) (2,)</p>
</div>
<div class="section" id="Storage-Implementation:-Continuations">
<h4>Storage Implementation: Continuations<a class="headerlink" href="#Storage-Implementation:-Continuations" title="Permalink to this headline">¶</a></h4>
<p>The only thing that must exist is a specification of the continuations that exist in a <code class="docutils literal notranslate"><span class="pre">WepyHDF5</span></code> file.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Runs in this file:&quot;</span><span class="p">,</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">run_idxs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Continuations using the API method:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">continuations</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Where it is actually stored in the HDF5:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">h5</span><span class="p">[</span><span class="s1">&#39;_settings/continuations&#39;</span><span class="p">][:])</span>
</pre></div>
</div>
</div>
<p>Run 1 continues run 0, and run 2 continues run 0.</p>
<p>This only works within a single file (but we can do interfile linking).</p>
</div>
<div class="section" id="API-for-interacting-with-continuations:-Contigs">
<h4>API for interacting with continuations: Contigs<a class="headerlink" href="#API-for-interacting-with-continuations:-Contigs" title="Permalink to this headline">¶</a></h4>
<p>A contig is a list of runs that form a contiguous dataset.</p>
<p>For the continuation (1,0) the contig is (0,1).</p>
<p>Contigs can be any number of runs.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Contig </span><span class="si">{}</span><span class="s2"> has </span><span class="si">{}</span><span class="s2"> frames&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">contig_n_cycles</span><span class="p">([</span><span class="mi">0</span><span class="p">])))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Contig </span><span class="si">{}</span><span class="s2"> has </span><span class="si">{}</span><span class="s2"> frames&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">contig_n_cycles</span><span class="p">([</span><span class="mi">1</span><span class="p">])))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Contig </span><span class="si">{}</span><span class="s2"> has </span><span class="si">{}</span><span class="s2"> frames&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">contig_n_cycles</span><span class="p">([</span><span class="mi">2</span><span class="p">])))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Contig </span><span class="si">{}</span><span class="s2"> has </span><span class="si">{}</span><span class="s2"> frames&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">contig_n_cycles</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Contig </span><span class="si">{}</span><span class="s2"> has </span><span class="si">{}</span><span class="s2"> frames&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">contig_n_cycles</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])))</span>
<span class="c1">#wepy1.resampling_records_dataframe([0,1])</span>
</pre></div>
</div>
</div>
<p>A <em>spanning contig</em> is a contig which goes from a root run (a run that does not continue another run) and a leaf run (a run which is not continued). These can be enumerated:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">spanning_contigs</span> <span class="o">=</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">spanning_contigs</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The spanning contigs:&quot;</span><span class="p">,</span> <span class="n">spanning_contigs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="The-Contig-Tree-Class">
<h3>The Contig Tree Class<a class="headerlink" href="#The-Contig-Tree-Class" title="Permalink to this headline">¶</a></h3>
<p>Since we have given it everything it needs to make the parent table from the previous example it can automate it all with the appropriate sliding windows algorithms for multiple runs!</p>
<div class="section" id="The-Macro-State-Network-Class">
<h4>The Macro-State Network Class<a class="headerlink" href="#The-Macro-State-Network-Class" title="Permalink to this headline">¶</a></h4>
<p>In order to make a Conformation State Network (CSN) we need to have the transitions (end-points of sliding windows) and the labels of the micro-states (frames of simulations) which can be from clustering or whatever else.</p>
<p>Because, a ContigTree can in the most degenerate form be a single run it is the most appropriate inputs for a general macro-state network.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">wepy.analysis.network</span> <span class="kn">import</span> <span class="n">MacroStateNetwork</span>

<span class="n">random_state_net</span> <span class="o">=</span> <span class="n">MacroStateNetwork</span><span class="p">(</span><span class="n">contig_tree</span><span class="p">,</span> <span class="n">transition_lag_time</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                     <span class="n">assg_field_key</span><span class="o">=</span><span class="s2">&quot;observables/rand_assg_idx&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Because this object directly wraps the WepyHDF5 file, we have access to all the data including weights, positions, box sizes etc. and so we can perform all kinds of fancy operations on a macrostate basis.</p>
</div>
<div class="section" id="Weights/Free-Energy-of-the-Macrostates">
<h4>Weights/Free Energy of the Macrostates<a class="headerlink" href="#Weights/Free-Energy-of-the-Macrostates" title="Permalink to this headline">¶</a></h4>
<p>Since we are principally interested in the free energy of macrostates the weights of the macrostates are a canonical example.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># compute the weights of the macrostates and set them as node attributes</span>
<span class="n">random_state_net</span><span class="o">.</span><span class="n">set_nodes_field</span><span class="p">(</span><span class="s1">&#39;Weight&#39;</span><span class="p">,</span> <span class="n">random_state_net</span><span class="o">.</span><span class="n">macrostate_weights</span><span class="p">())</span>

<span class="c1"># get the weight of a node</span>
<span class="nb">print</span><span class="p">(</span><span class="n">random_state_net</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="mi">39</span><span class="p">][</span><span class="s1">&#39;Weight&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Transition-Probabilitiy-Matrix">
<h4>Transition Probabilitiy Matrix<a class="headerlink" href="#Transition-Probabilitiy-Matrix" title="Permalink to this headline">¶</a></h4>
<p>To make an actual network we would need the transition probabilities as well, which were calculated with the lag time given when we created the network.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="nb">print</span><span class="p">(</span><span class="n">random_state_net</span><span class="o">.</span><span class="n">probmat</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Updated-User-Workflow">
<h4>Updated User Workflow<a class="headerlink" href="#Updated-User-Workflow" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="Synergism-with-CSNAnalysis">
<h4>Synergism with CSNAnalysis<a class="headerlink" href="#Synergism-with-CSNAnalysis" title="Permalink to this headline">¶</a></h4>
<p>This is the assymetric probability matrix. You can calculate interesting things with it related to paths etc. with the <code class="docutils literal notranslate"><span class="pre">CSNAnalysis</span></code> package from here on.</p>
<p>The purpose of this class is to calculate transition probabilities and create a direct interface to microstates in the HDF5 from a macrostate perspective.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">csnanalysis.csn</span> <span class="kn">import</span> <span class="n">CSN</span>
<span class="kn">from</span> <span class="nn">csnanalysis.matrix</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">csn</span> <span class="o">=</span> <span class="n">CSN</span><span class="p">(</span><span class="n">random_state_net</span><span class="o">.</span><span class="n">countsmat</span><span class="p">,</span> <span class="n">symmetrize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Committor-Probabilities">
<h4>Committor Probabilities<a class="headerlink" href="#Committor-Probabilities" title="Permalink to this headline">¶</a></h4>
<p>Calculate the distance between the two particles:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">euclidean</span>

<span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">field_d</span> <span class="ow">in</span> <span class="n">random_state_net</span><span class="o">.</span><span class="n">iter_nodes_fields</span><span class="p">([</span><span class="s1">&#39;positions&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

    <span class="c1"># just use the positions of the first frame in the cluster</span>
    <span class="n">pos_A</span><span class="p">,</span> <span class="n">pos_B</span> <span class="o">=</span> <span class="n">field_d</span><span class="p">[</span><span class="s1">&#39;positions&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">field_d</span><span class="p">[</span><span class="s1">&#39;positions&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean</span><span class="p">(</span><span class="n">pos_A</span><span class="p">,</span> <span class="n">pos_B</span><span class="p">)</span>
    <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

</pre></div>
</div>
</div>
<p>Determine the source and sink basins and compute the committor probabilities:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># the sink basins are those close to the unbinding cutoff</span>
<span class="n">sink_basin</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">2.5</span><span class="p">)]</span>
<span class="c1"># the source basins are where they are close together</span>
<span class="n">source_basin</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.37</span><span class="p">)]</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of sink states:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sink_basin</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of source states:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_basin</span><span class="p">))</span>

<span class="n">committor_probabilities</span> <span class="o">=</span> <span class="n">csn</span><span class="o">.</span><span class="n">calc_committors</span><span class="p">([</span><span class="n">source_basin</span><span class="p">,</span> <span class="n">sink_basin</span><span class="p">])</span>
<span class="n">committor_probabilities</span><span class="p">[</span><span class="mi">39</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Microstates-in-the-Macrostate">
<h4>Microstates in the Macrostate<a class="headerlink" href="#Microstates-in-the-Macrostate" title="Permalink to this headline">¶</a></h4>
<p>The macrostate keeps track of the microstates by a ‘trace’ which in <code class="docutils literal notranslate"><span class="pre">wepy</span></code> parlance is just a list of indices into the main wepy HDF5 data structure to a specific microstate, i.e. list of (run index, walker index, cycle index) tuples.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">node8_trace</span> <span class="o">=</span> <span class="n">random_state_net</span><span class="o">.</span><span class="n">node_assignments</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">node8_trace</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Visualizing-Microstates">
<h4>Visualizing Microstates<a class="headerlink" href="#Visualizing-Microstates" title="Permalink to this headline">¶</a></h4>
<p>This is used to make it very easy to visualize the microstates by allowing export to other trajectory software better supported by viewers like <code class="docutils literal notranslate"><span class="pre">mdtraj</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># get an mdtraj trajectory object from the microstates in a node</span>
<span class="n">node8_traj</span> <span class="o">=</span> <span class="n">random_state_net</span><span class="o">.</span><span class="n">state_to_mdtraj</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">node8_traj</span><span class="o">.</span><span class="n">superpose</span><span class="p">(</span><span class="n">node8_traj</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> frames in macrostate </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node8_traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="kn">import</span> <span class="nn">nglview</span> <span class="k">as</span> <span class="nn">nv</span>
<span class="n">view</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">show_mdtraj</span><span class="p">(</span><span class="n">node8_traj</span><span class="p">)</span>
<span class="n">view</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Linking-Runs-Together">
<h4>Linking Runs Together<a class="headerlink" href="#Linking-Runs-Together" title="Permalink to this headline">¶</a></h4>
<p>When doing many runs over different jobs and with continuations we found that it would be useful to be able to link them all into a single file and thus not have to worry about different files when doing analysis.</p>
<p>Luckily, the HDF5 standard provides a way to do this and is now incorporated into <code class="docutils literal notranslate"><span class="pre">wepy.hdf5</span></code>.</p>
<p>The main methods we can use to accomplish this are: - <code class="docutils literal notranslate"><span class="pre">clone</span></code> : copy the header information in a file without run data - <code class="docutils literal notranslate"><span class="pre">add_continuation</span></code> : manually specify a continuation within a file - <code class="docutils literal notranslate"><span class="pre">link_run</span></code> : link a single run from another file, optionally creating a continuation - <code class="docutils literal notranslate"><span class="pre">link_file_runs</span></code> : link all runs from another file, preserving their internal continuations</p>
</div>
</div>
<div class="section" id="Example-Datasets">
<h3>Example Datasets<a class="headerlink" href="#Example-Datasets" title="Permalink to this headline">¶</a></h3>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">rescale</span><span class="p">(</span><span class="n">linking_files_im</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">wepy2</span> <span class="o">=</span> <span class="n">WepyHDF5</span><span class="p">(</span><span class="n">wepy2_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">wepy3</span> <span class="o">=</span> <span class="n">WepyHDF5</span><span class="p">(</span><span class="n">wepy3_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">wepy2</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;File 2 runs:&quot;</span><span class="p">,</span> <span class="n">wepy2</span><span class="o">.</span><span class="n">run_idxs</span><span class="p">)</span>
<span class="k">with</span> <span class="n">wepy3</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;File 3 runs:&quot;</span><span class="p">,</span> <span class="n">wepy3</span><span class="o">.</span><span class="n">run_idxs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="Code:">
<h4>Code:<a class="headerlink" href="#Code:" title="Permalink to this headline">¶</a></h4>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># now we are going to link them all under one linker file</span>
<span class="n">linker_h5_path</span> <span class="o">=</span> <span class="n">osp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputs_dir</span><span class="p">,</span> <span class="s2">&quot;all_runs.wepy.h5&quot;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">wepy1</span><span class="p">:</span>
    <span class="n">all_wepy</span> <span class="o">=</span> <span class="n">wepy1</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linker_h5_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">all_wepy</span><span class="p">:</span>

    <span class="c1"># link the whole file for wepy1 to preserve the continuations</span>
    <span class="n">wepy1_run_idxs</span> <span class="o">=</span> <span class="n">all_wepy</span><span class="o">.</span><span class="n">link_file_runs</span><span class="p">(</span><span class="n">wepy1_path</span><span class="p">)</span>

    <span class="c1"># do the same for wepy2 just to test it on only one run in a file and</span>
    <span class="c1"># because it is easier</span>
    <span class="n">wepy2_run_idxs</span> <span class="o">=</span> <span class="n">all_wepy</span><span class="o">.</span><span class="n">link_file_runs</span><span class="p">(</span><span class="n">wepy2_path</span><span class="p">)</span>

    <span class="c1"># now we need to link the run from the continuation file for wepy2 and</span>
    <span class="c1"># add in the continuation records</span>
    <span class="n">all_wepy</span><span class="o">.</span><span class="n">link_run</span><span class="p">(</span><span class="n">wepy3_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">continue_run</span><span class="o">=</span><span class="n">wepy2_run_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">all_wepy</span><span class="o">.</span><span class="n">spanning_contigs</span><span class="p">())</span>

</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">all_wepy</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
<span class="n">wepy1</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
<span class="n">wepy2</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
<span class="n">wepy3</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Future-Topics">
<h4>Future Topics<a class="headerlink" href="#Future-Topics" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Automatic exit point ancestry trees and trajectories</p></li>
<li><p>Easier restarts and continuations</p></li>
</ul>
</div>
</div>
<div class="section" id="Requests-and-Challenges?">
<h3>Requests and Challenges?<a class="headerlink" href="#Requests-and-Challenges?" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>stripping waters</p></li>
<li><p>clustering featurization examples</p></li>
<li><p>linking files with different amount of solvent</p></li>
</ul>
</div>
<div class="section" id="TODO">
<h3>TODO<a class="headerlink" href="#TODO" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>wepy paper</p></li>
</ul>
</div>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="../extended_test_drive/README.html" title="Previous document">A First Look at wepy Data</a>
        </li>
        <li>
          <a href="../Orchestrator/README.html" title="Next document">Using Orchestrators</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/wepy.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">wepy</h1>
    
  </a>
</p>



<p class="blurb">A Weighted Ensemble  (WE) simulation framework</p>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quick_start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction &amp; Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html#bibliography">Bibliography</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users_guide.html">User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../troubleshooting.html">Common Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../troubleshooting.html#faq">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_api/modules.html">Full API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../general_info.html">General Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../news.html">News and Updates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev_guide.html">Development Guide</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Tutorials</a><ul>
      <li>Previous: <a href="../extended_test_drive/README.html" title="previous chapter">A First Look at wepy Data</a></li>
      <li>Next: <a href="../Orchestrator/README.html" title="next chapter">Using Orchestrators</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Samuel D. Lotz.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/_source/tutorials/data_analysis/README.ipynb.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/ADicksonLab/wepy" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>